<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Steven's Blog]]></title>
  <link href="http://isunix.github.io/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-06-15T18:23:07+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第四章 引用入门]]></title>
    <link href="http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men/"/>
    <updated>2014-06-11T18:45:27+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men</id>
    <content type="html"><![CDATA[<p>引用是Perl的复杂的数据结构，面向对象编程还有花哨的子程序的基石。它们是在Perl4还有Perl5这段时间被添加进去的。    </p>

<p>一个Perl的标量变量存有一个单一的值。一个数组存有一个或者多个标量的有序列表。一个哈希存有一组标量作为值， 然后以另外一组值作为键。尽管一个标量可以是一个任意的字符串，那样就允许复杂的数据被嵌入到数组或者哈希里面去，但是上面的三种数据类型没有一种是很合适复杂的数据间的相互关系的。这就是引用的活了。让我们以一个例子开头看下引用的重要性。  </p>

<h2 id="section">在许多数组上面执行同样的任务</h2>

<p>在Minnow开始一个短途旅途的(例如，一个3小时的观光), 我们应该检查每一个乘客还有全体乘务人员来确保他们都拥有必备的旅行用品。比如说， 为了还上航行的安全，Minnow穿上的每个人都得有个救生圈，一些遮光剂，一个水壶还有一个雨衣。我们可以写一些代码来检查Skipper的储备。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@skipper</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;skipper is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>grep在标量上下文中返回表达式 $item eq $_ 返回 true 的次数，当这件东西在清单里的时候就是1，不在的话就是0. 如果值是0的话，就是假,这个时候我们就把信息给打印出来。   </p>

<p>当然如果我们想要检查Gilligan还有Professor的话，我们可能会写如下的代码:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@gilligan</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;gilligan is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@professor</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;professor is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可能开始注意到这里有很多的冗余的代码，并且想到我们应该把它重构到一个可以重用的通用的子程序中(你是正确的):   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@_</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">			<span class="k">print</span> <span class="s">&quot;$who is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;gilligan&#39;</span><span class="p">,</span> <span class="nv">@gilligan</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl一开始通过它的@_数组给了子程序5个条款：名字gilligan还有属于Gilligan的4个东西。在shift操作之后，@_就只有4个东西了。因此grep通过和清单比对来检查每个所必备的东西。   </p>

<p>到目前为止，一切都很好。我们可以同过一点多余的代码来检查Skipper还有Professor的：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;skipper&#39;</span><span class="p">,</span> <span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;professor&#39;</span><span class="p">,</span> <span class="nv">@professor</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于其他的乘客，我们在需要的地方重复下就行了。尽管这个代码符合一开始的要求，我们有两个问题得处理: </p>

<p>*为了创建@_, Perl把数组的整个内容都拷下下来扫描。对于一个元素的话这没什么问题，但是如果数组很大的话，把数据拷贝然后仅仅就是为了传给子程序的话就显得有点浪费了。   </p>

<p>*假如我们想要修改原先的数组来迫使供应清单包括一些必备的东西，因为我们在子程序中有一个副本(传值),对@_做的任何的修改都不会自动地反映到对应的供应清单数组中去。   </p>

<p>为了解决一个或者两个问题，我们需要的是引用传递而非值传递。这就是doctor(或者Professor)所要求的。  </p>

<h2 id="section-1">对一个数组做引用</h2>

<p>在反斜线()的很多的其他的意思当中，它还是”对某项东西进行引用”的操作符。当我们把它用在一个数组名的前面的时候，比如， \@skipper， 他的结果就是对那个数组的引用。对数组的引用就像是指针: 它指向数组，但是它不是数组本身。  </p>

<p>任何变量适宜地方都是适用于引用。它可以作用于一个数组或者哈希的元素，或者一个普通的标量变量， 像下面这样:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$reference_to_skipper</span> <span class="o">=</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>引用可以被拷贝:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$second_reference_to_skipper</span> <span class="o">=</span> <span class="nv">$reference_to_skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>甚至于：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$third_reference_to_skipper</span> <span class="o">=</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们可以相互交换这3个引用。我们甚至可以说它们是相同的，因为事实上，它们就是相同的东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="nv">$reference_to_skipper</span> <span class="o">=</span> <span class="o">=</span> <span class="nv">$second_reference_to_skipper</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;They are identical references.\n&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个等式比较两个引用的数值形式。这里引用的数值形式是@skipper内部数据结构的唯一的内存地址, 它在变量的生命周期里是不会改变的。如果我们使用eq或者print来查看它的字符串形式，我们会得到调试出来的字符串:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">ARRAY</span><span class="p">(</span><span class="mh">0x1a2b3c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>对于这个数组它也是唯一的，因为它包含了数组的唯一地址的16进制表示。调试出来的字符串同样也表示了这是个数组引用。当然要是我们在我们的代码中看到类似的输出，那就基本上表示了有bug。使用我们代码的用户是对16进制的存储地址块没有兴趣的。  </p>

<p>因为我们可以拷贝一个引用，向一个子程序传递一个参数事实上就是拷贝，我们可以使用下面的代码来向子程序中的数组传递一个引用:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&quot;The Skipper&quot;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="o">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在子程序中的$items是对数组@skipper的一个引用。但是我么怎么能够从一个引用得到我们原先的数组呢? 那当然是我们对引用进行解引用了。</p>

<h2 id="section-2">对数组引用进行解引用</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第三章 使用模块]]></title>
    <link href="http://isunix.github.io/blog/2014/06/08/intermediate-perl-di-san-zhang-shi-yong-mo-kuai/"/>
    <updated>2014-06-08T01:16:53+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/08/intermediate-perl-di-san-zhang-shi-yong-mo-kuai</id>
    <content type="html"><![CDATA[<p>模块是我们的程序的基础部分。他们提供可重用的子程序，变量，甚至面向对象的类。在我们建造自己的模块的过程中， 我们会向你展现一些你可能会感兴趣的。我们同样会看一些别人已经写好的模块的用法。   </p>

<h2 id="section">标准发布版本</h2>

<p>Perl本身已经自带了很多的流行的模块。事实上， 最新进的50+MB的发布版本中的绝大部分都是来自于模块。在1996年10月， Perl 5.003_07版本中有98个模块。今天， 在2006年年初， Perl5.8.8有359个模块。事实上这是Perl的一个优势之一:它已经自带了很多的你在写有用的还有复杂的程序的时候所需要的东西， 那样就省了你的很多的工作了。   </p>

<p>在整本书中， 我们都会试着识别出哪些模块是Perl自带的(在大部分情况下， 识别出它们是自哪一版开始进入Perl的)。我们将称呼这些为”核心模块” 或者强调它们是在”标准发布版本”中。如果你安装了Perl, 你应该就有了这些模块。由于当我们在写作本书的时候， 我们使用的是Perl 5.8.7, 我们将假定这就是当前的Perl的版本。    </p>

<p>当你在开发自己的代码的时候， 你可能会考虑自己是否想要只使用核心模块，那样你就可以确信任何其他只要是和你的Perl版本是一样的人， 都将会有那些模块。我们将会避开这个争论， 主要是因为我们太爱CPAN了， 简直离不开它了。   </p>

<h2 id="section-1">使用模块</h2>
<p>几乎每一个Perl模块都跟有文档，即使我们可能不知道所有的幕后的魔术是怎么运作的，当我们知道如何使用接口的时候我们真的没必要担心那些。毕竟那就是接口存在的原因: 隐藏细节。   </p>

<p>在我们的本地机器上， 我们可以使用perldoc命令来阅读模块的文档。我们把感兴趣的模块的名称给它，它就会帮我们输出模块的文档。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">NAME</span>
</span><span class="line">	<span class="n">fileparse</span> <span class="err">−</span> <span class="nb">split</span> <span class="n">a</span> <span class="n">pathname</span> <span class="n">into</span> <span class="n">pieces</span>
</span><span class="line">
</span><span class="line">	<span class="n">basename</span> <span class="err">−</span> <span class="n">extract</span> <span class="n">just</span> <span class="n">the</span> <span class="n">filename</span> <span class="n">from</span> <span class="n">a</span> <span class="n">path</span>
</span><span class="line">
</span><span class="line">	<span class="n">dirname</span> <span class="err">−</span> <span class="n">extract</span> <span class="n">just</span> <span class="n">the</span> <span class="n">directory</span> <span class="n">from</span> <span class="n">a</span> <span class="n">path</span>
</span><span class="line">	
</span><span class="line"><span class="n">SYNOPSIS</span>
</span><span class="line">	<span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="p">(</span><span class="nv">$name</span><span class="p">,</span><span class="nv">$path</span><span class="p">,</span><span class="nv">$suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">fileparse</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">,</span><span class="nv">@suffixlist</span><span class="p">)</span>
</span><span class="line">	<span class="n">fileparse_set_fstype</span><span class="p">(</span><span class="nv">$os_string</span><span class="p">);</span>
</span><span class="line">	<span class="nv">$basename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">,</span><span class="nv">@suffixlist</span><span class="p">);</span>
</span><span class="line">	<span class="nv">$dirname</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们把文档的顶部的那段包含了进来是为了向你展示最重要的部分(至少是在你刚开始的时候是最重要的)。模块的文档一般都会遵循过去的unix主页的格式， 也就是以NAME还有SYNOPSIS部分开始。   </p>

<p>大纲部分给出了模块使用的例子。如果我们能够停止一会儿理解， 然后跟着例子来， 我们就可以使用某个模块了。也就是说，可能你还不是很熟悉大纲中的某些Perl的技巧和语法，但是你可以仅仅是跟着例子来然后让一切运行完好。   </p>

<p>现在由于Perl是过程式，函数式，面向对象以及其它的语言类型的综合体， Perl的模块也有着不同接口。我们将会以稍微有点不同的方式来使用这些模块，但是只要我们能够去查阅文档，就应该不会有问题的。   </p>

<h2 id="section-2">功能性接口</h2>
<p>为了加载一个模块，我们使用Perl内建的use。我们在这里不会进入所有具体的细节，但是在第10章还有第15章我们会的。现在我们只是想使用模块。让我们以File::Basename这个核心发布版本中的模块来开始。为了把它加载到我们的脚本中去， 我们来：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当我们这么做的时候， File::Basename向我们的脚本中引进三个子例程，fileparse, basename 以及 dirname， 从此刻起， 我们可以这么来:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$basename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span> <span class="nv">$some_full_path</span> <span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$dirname</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span> <span class="nv">$some_full_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这就好像是我们自己写了basename还有dirname这两个子例程， 或者它们像是(接近是)内建的Perl函数一样。 这些子程序会把路径名中的文件名还有目录名找出来。例如， 如果 $some_full_path 是 D:\Projects\IsIandRescue\plan7.rtf(假定程序是在windows机器上运行的), 那么$basename将会是plan7.rtf, $dirname将会是D:\Projects\IsIandRescue。    </p>

<p>File::Basename这个模块自己会知道它是在何种机器上运行的, 因此它的函数能够明白怎么正确地针对我们可能遇到的分隔符来解析字符串。   </p>

<p>然而，假定我们已经有了一个叫dirname的子程序， 现在我们就会用File::Basename中的定义把它覆盖掉了. 如果我们已经开启了warnings，我们将会看到一个消息声明。否则的话，Perl就完全地不关心了。   </p>

<h2 id="section-3">选择引入什么</h2>

<p>幸运的是， 我们可以告诉use操作通过在模块名的后面明确一组子程序的名字，也叫做引入列表， 来限制它的行为:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">(</span><span class="s">&#39;fileparse&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">basename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在这个模块仅仅给我们提供了两个子程序， 不会干扰我们自己的dirname子程序了。当然，那样输入起来很别扭, 所以更经常的我们看到的是用引用字操作符写出来的形:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span> <span class="sx">qw(fileparse basename)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>事实上，即使只有一个条款，为了连贯还有维护我们也倾向于用qw()列表来写出来；经常地我们会返回去说”在这了再给我加一条”, 这个时候如果已经是个qw()列表的话会更容易的。   </p>

<p>我们已经保护了本地的dirname子程序，但是如果我们依然想要File::Basename提供的功能呢？没问题，我们只要用它的完整的包的指定形式写出来就可以了：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$dirname</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">dirname</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>use后面的一组名字不会改变到底有哪些子程序在模块的包中定义好了(在我们的情况下是File::Basename)。 我们总是可以使用完整的包的名字的形式而不用管引用列表， 就如同下面一样:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$basename</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">basename</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在极端的情况下(但是极其的有用)，我们可以指定为引用列表制定一个空的列表， 如下： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">();</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$base</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">basename</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>一个空的列表和一个缺失的列表是有所不同的。 一个空的列表意味着”不要给我任何的东西”, 而一个缺失的列表意味着给我默认的”。如果模块的作者做的很好的话，默认的情况就是我们所需要的。  </p>

<h2 id="section-4">面向对象接口</h2>

<p>通过看下File::Spec模块， 我们来比较下File::Basename引入的子程序和其之间的区别。File::Spec模块是设计来支持通常作用在文件指定上的操作的。(一个文件指定通常是一个文件或者一个路径名，但它可能是一个不存在的文件-在这种情况下，它就不是一个真正的文件名，对不对？) </p>

<p>同File::Basename模块不同的是，File::Spec有着一个主要的面向对象接口。如同我们之前的那样， 我们也用use来加载模块:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Spec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然而，由于这个模块有着面向对象的接口，它不支持任何的子程序。作为替代，这个接口告诉我们使用它的类方法来获取它的模块的功能。catfile方法把一组字符串用合适的目录分割符来连接起来:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$filespec</span> <span class="o">=</span> <span class="nn">File::</span><span class="n">Spec</span><span class="o">-&gt;</span><span class="n">catfile</span><span class="p">(</span> <span class="nv">$homedir</span><span class="p">{</span><span class="n">gilligan</span><span class="p">},</span> <span class="s">&#39;web_docs&#39;</span><span class="p">,</span> <span class="s">&#39;photos&#39;</span><span class="p">,</span>           	<span class="s">&#39;USS_Minnow.gif&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这样就会调用File::Spec类中的catfile类方法， 它会构造一个适合于本地的操作系统的路径然后返回一个单一的字符串。 在语法上这同File::Spec所提供的将近两打的其他的操作是相似的。  </p>

<p>File::Spec模块以一种可移植的方式为处理文件路径提供了好几个其他的方式。 你可以在perlport文档中阅读更多的关于可移植性的问题。   </p>

<h2 id="mathbigint">一个更典型的面向对象模块:Math::BigInt</h2>

<p>由于File::Spec模块没有对象，为了不被它看起来非面向对象的特征所失望，让我们看一下另外的一个核心的模块，Math::BigInt, 他可以在Perl的一般能力范围之外处理整数。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">Math::</span><span class="n">BigInt</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nn">Math::</span><span class="n">BigInt</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">#以2开始；</span>
</span><span class="line"><span class="nv">$value</span><span class="o">-&gt;</span><span class="n">bpow</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>   			   <span class="c1">#2**100-</span>
</span><span class="line"><span class="k">print</span> <span class="nv">$value</span><span class="o">-&gt;</span><span class="n">bstr</span><span class="p">(),</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span> 	   <span class="c1">#打印出来</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>同之前的一样，这个模块什么都没有引入。它的完整的接口使用类方法，诸如new, 接在类名后面来生成实例，然后接在这些实例之后调用实例方法，像bpow还有bstr。   </p>

<h2 id="perlcpan">详尽的Perl存档网络(CPAN)</h2>

<p>(未翻!)   </p>

<h2 id="cpan">从CPAN来安装模块</h2>

<p>从CPAN来安装一个简单的模块可以是很直接的：我们下载模块发布版本的存档，解压出来，切换到它的目录中去。 我们在这儿使用wget，但其实你使用哪个工具是无关紧要的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">wget</span> <span class="n">http:</span><span class="sr">//</span><span class="n">www</span><span class="o">.</span><span class="n">cpan</span><span class="o">.</span><span class="n">org</span><span class="sr">/.../</span><span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">tar</span> <span class="err">−</span><span class="n">xzf</span> <span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">cd</span> <span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>从那儿起我们可以走两条路中的一种。如果我们找到一个叫Makefile.PL的文件，我们可以运行下面的命令来build, test还有最终的安装这个源码:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Makefile</span><span class="o">.</span><span class="n">PL</span> <span class="nv">%</span> <span class="nv">make</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">make</span> <span class="n">test</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">make</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果你没有权限在系统范围的目录中安装模块，我们可以通过使用PREFIX参数来告诉Perl在别的路径下安装：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Makefile</span><span class="o">.</span><span class="n">PL</span> <span class="n">INSTALL_BASE</span><span class="o">=</span><span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了让Perl在那个目录中寻找模块，我们可以设置PERL5LIB环境变量。Perl会把那些目录添加到它的模块搜获列表中去。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">export</span> <span class="n">PERL5LIB</span><span class="o">=</span><span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们也可以使用lib指令来添加到模块搜索路径中去，尽管这看起来不是很友好，因为我们得改变代码，但也因为可能它不是我们在其他的我们想要代码跑起来的机器上的路径:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="c1">#!/usr/bin/perl</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="sx">qw(/Users/home/Ginger)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>先后退一小会儿，如果我们找到的是Build.PL这个文件而不是Makefile.Pl这个文件，过程将会是一样的。 这些发布版本使用Module::Build来build还有install代码。由于Module::Build不是核心的Perl模块，我们得在我们能够安装使用它的发布版本之前安装它:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span><span class="o">.</span><span class="n">PL</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span> <span class="n">test</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了用Module::Build安装到我们的私有的目录，我们添加 –install_base 参数。我们以和前面的同样的方式告诉Perl如何来找到模块:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span><span class="o">.</span><span class="n">PL</span> <span class="err">−−</span><span class="n">install_base</span> <span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>有的时候我们会在一个发布版本中看到Makefile.PL还有Build.PL这两个文件。那个时候我们该怎么做呢？我们可以使用任意一个。选择你最喜欢的来玩！  </p>

<h2 id="section-5">在合适的时间来设定路径</h2>

<p>Perl通过在特殊的Perl数组@INC中定义的路径来查找模块。use声明在编译时执行，所以它会在编译时查看模块搜索路径@INC。除非我们把@INC考虑在内，否则那会以一种很难理解的方式让我们的程序崩溃掉。   </p>

<p>例如，假设我们有自己的目录/home/giliigan/lib, 我们把自己的模块Navigation::SeatOfPants放在/home/gilligan/lib/Navigation/SeatOfPants.pm里。当我们加载自己的模块的时候，Perl就找不到了。 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>Perl会向我们抱怨它在@INC中找不到模块， 并且会展现给我们看在那个数组里的所有的路径:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">Can</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">locate</span> <span class="n">Navigation</span><span class="o">/</span><span class="n">SeatofPants</span><span class="o">.</span><span class="n">pm</span> <span class="n">in</span> <span class="nv">@INC</span> <span class="p">(</span><span class="nv">@INC</span> <span class="n">contains:</span> <span class="o">...</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可能会想我们应该仅仅在调用use之前把我们的模块的路径添加到@INC中去。然而，即使添加如下的东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">unshift</span> <span class="nv">@INC</span><span class="p">,</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span> <span class="c1"># 崩溃</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>也不会起作用的。为什么呢？因为unshift在运行时才起作用，这是use在编译之后的很长时间才发生的。这两个声明在词法上很接近， 但是在时间上并不接近。仅仅因为我们把它们写在了一块并不表示它们是以那样的顺序来执行的。我们想在use执行前改变@INC。一种处理这个的方式是在unshift周围添加一个BEGIN块:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">unshift</span> <span class="nv">@INC</span><span class="p">,</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在这个BEGIN块就会在编译时编译还有运行了, 会接下来的use设置合适的路径。   </p>

<p>然而，这很烦人而且需要的解释可能超出了你觉得舒服的范围了，尤其是对于那些后来的可能需要维护修改你的代码的人。让我们以一种我们之前用过的一种简单的声明来代替那一团东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里， lib声明会接收一个或者多个参数然后把它们添加到@INC数组的开头，就如同之前的unshift所做的。这是行得通是因为它是在编译时执行的，而不是在运行时。因此它对紧接着的use是适时的。 </p>

<p>一个use lib声明通常总是有一个地址依赖的路径名，一般情况下我们鼓励大家把它放到文件的开头的部分。这样当我们得移动文件到一个新的系统或者lib的路径有变化的时候，我们在找的时候还有更新的时候会方便点的。(当然，如果我们能够在标准的@INC地址中安装我们的模块的话，我们就可以避免使用use lib了， 但那并不总是实际的.)    </p>

<p>要把use lib想成是“使用这个路径来找到我的库(还有模块)” 而不是使用这个目录。很经常的，我们会看到如下的代码:     </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="s">&#39;/Users/gilligan/lib/Navigation/SeatOfPants.pm&#39;</span><span class="p">;</span> <span class="c1"># 错误</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然后这个程序要会想为什么没有把定义给加载进来. 要注意use lib事实上是在编译时运行的，所以下面的也是不会起作用的:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$LIB_DIR</span> <span class="o">=</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="o">...</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="nv">$LIB_DIR</span><span class="p">;</span> <span class="c1"># 崩溃</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当然，Perl在编译时就会建立起$LIB_DIR的声明（所以用use strict的时候我们是不会得到错误警告的，尽管真正的use lib是会抱怨的)， 但是真正的/home/gilligan/lib的值是直到运行时才会赋值的。呀，又太迟了。  </p>

<p>此时此刻，我们得在BEGIN块里放进一些东西，或者依靠另一个编译时操作:用use constant来设置一个常数:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">constant</span> <span class="n">LIB_DIR</span> <span class="o">=&gt;</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="o">...</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="n">LIB_DIR</span><span class="p">;</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>啊哈，又解决了。就是这个样子了，除非我们需要模块依赖一个计算的结果。(啥时该休止啊，快来人让这个疯狂的行为停止掉吧!)这应该会解决99%我们的需要了。  </p>

<h2 id="section-6">解决模块的依赖性</h2>

<p>我们刚刚看到如果我们想要安装一个需要使用Module::Build的模块，我们得先安装Module::Build。那只是令我们头疼的依赖性问题中的很小的一个例子了。 我们可能得安装好几个其他的模块，它们当中的每一个又都反过来得依赖更多的模块。   </p>

<p>幸运的是， 我们有工具来帮助我们。CPAM.pm模块自从Perl5.004就是核心发布版本的一个部分了。它给了我们一个交互的安装shell.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">$</span> <span class="nv">perl</span> <span class="o">-</span><span class="n">MCPAN</span> <span class="o">-</span><span class="n">e</span> <span class="n">shell</span>
</span><span class="line"><span class="n">cpan</span> <span class="n">shell</span> <span class="o">--</span><span class="n">CPAN</span> <span class="n">exploration</span> <span class="o">....</span>
</span><span class="line"><span class="n">Readline</span> <span class="n">support</span>
</span><span class="line">
</span><span class="line"><span class="n">cpan</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了安装一个模块还有它的依赖，我们使用命令install然后跟着模块的名字.现在CPAN.pm处理所有的下载，解压，building, 测试嗨哟安装模块的过程， 而且它会递归地处理那些依赖:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span><span class="o">&gt;</span> <span class="n">install</span> <span class="nn">CGI::</span><span class="n">Prototype</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>只是那也太多了，所以Brian创建了一个脚本cpan，它也是跟着Perl发行版本的。我们只要把我们想要安装的模块列出来，它就会帮我们处理接下来的情况了:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span> <span class="nn">CGI::</span><span class="n">Prototype</span> <span class="nn">HTTP::Cookies::</span><span class="n">Safari</span> <span class="nn">Test::</span><span class="n">Pod</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另一个很酷的工具是CPANPLUS，是CPAN.pm的完全的重写，但是在我么写作本书的时候它还不是核心发布版本中的一部分.   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">$</span> <span class="nv">perl</span> <span class="o">-</span><span class="n">MCPANPLUS</span> <span class="o">-</span><span class="n">e</span> <span class="n">shell</span>
</span><span class="line"><span class="n">CPAN</span> <span class="n">Terminal</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了安装一个模块，我们使用i命令.  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">CPAN</span> <span class="n">Terminal</span><span class="o">&gt;</span> <span class="n">i</span> <span class="nn">CGI::</span><span class="n">Prototype</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>CPANPLUS模块带了一个很方便的脚本，叫cpanp。我们我们给它i开关还有一组模块，它就会像之前那样安装它们了    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span> <span class="n">i</span> <span class="nn">CGI::</span><span class="n">Prototype</span> <span class="nn">HTTP::Cookies::</span><span class="n">Safari</span> <span class="nn">Test::</span><span class="n">Pod</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-7">练习</h2>
<p>(未翻)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Php-cgi Not Found Error]]></title>
    <link href="http://isunix.github.io/blog/2014/06/07/php-cgi-not-found-error/"/>
    <updated>2014-06-07T14:56:33+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/07/php-cgi-not-found-error</id>
    <content type="html"><![CDATA[<p>Today while I was running a php script from the PHPStrom by a browser, I got the following error telling me that “php-cgi not found.”. I have no other way but to install a new version of php, my original version is 5.4.24, I then installed a 5.5 version.  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">curl -s http://php-osx.liip.ch/install.sh | bash -s 5.5</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and in my phpstorm, I use the path, “usr/local/php5/bin” as the interpreter’s path. It works now.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Up PHP and Apache on Mac OS]]></title>
    <link href="http://isunix.github.io/blog/2014/06/07/set-up-php-and-apache-on-mac-os/"/>
    <updated>2014-06-07T14:25:00+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/07/set-up-php-and-apache-on-mac-os</id>
    <content type="html"><![CDATA[<p>I have set up Apache and PHP on my computer many times, every time I googled or Baidued about it, it is high time to keep a note about those steps.    </p>

<ol>
  <li>sudo mate /etc/apache2/httpd.conf</li>
  <li>uncomment “#LoadModule php5_module libexec/apache2/libphp5.so”</li>
  <li>save the file and quit. </li>
  <li>sudo cp /etc/php.ini.default /etc/php.ini</li>
  <li>sudo apachectl start </li>
  <li>ln -s /Library/WebServer/Document $HOME/www</li>
  <li>rename the file “index.html.en” or just delete the file if you do not want to be botthered.  </li>
</ol>

<p>That’s the steps all it takes to set up your apache and PHP on a MAC OS machine.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第二章 中级基础]]></title>
    <link href="http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu/"/>
    <updated>2014-06-06T17:07:24+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu</id>
    <content type="html"><![CDATA[<p>在我们开始这本书的实质内容之前， 我们想介绍些在本书中使用的中级水平的Perl习语。通常就是这些东西把初级的还有中级水平的Perl程序员区别开的。 在这个过程中， 我们还会把你介绍给将在本书中的例子中使用的一组角色。   </p>

<h2 id="section">列表操作符</h2>

<p>你已经知道了一些Perl中的列表操作符， 但是你可能没有把它们想成是同列表相联系的。最常见的列表操作符可能是print。 我们给它一个或者更多的参数， 它会为我们把这些参数组织到一起。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">print 'Two castaways are ', 'Gilligan', ' and ', 'Skipper', "\n";</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有其他一些你已经在Learning Perl一书中理解到了的列表操作符。sort操作符把输入的列表排序。在这些被流放的人他们所表演的主题曲中，他们没有按照字母顺序出场， 但是sort可以帮我们解决这个问题。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而reverse操作符可以返回一个反序的列表：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl中还有很多其他的同列表用在一起的操作符， 一旦你习惯了它们，你将会发现自己字敲得更少了， 表达自己的意图更加地清晰了。   </p>

<h2 id="grep">用grep来进行列表过滤</h2>

<p>grep操作符接收一个列表还有一个“测试条件”。 然后它把别表中的值一个接着一个地拿出来，放到$_这个变量里。 接来下grep会在标量上下文中估值这个测试条件。如果这个表达式估值成一个true的值， grep就会把$_传递给输出列表。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @lunch_choices = grep &amp;is_edible($_), @gilligans_profession.</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在列表上下文中， grep操作符会返回所有选出来的条款。而在标量环境中， grep会返回选出来的条款的数量。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @results = grep EXPR, @input_list;
</span><span class="line">my $count = grep EXPR, @input_list;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里EXPR表示的是任意的适用于$_的标量表达式(明确地或者隐含着的)。例如， 为了找到所有大于10的数， 在我们的grep表达式中， 我们检查看$_是否大于10.   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
</span><span class="line">my @bigger_than_10 = grep $_ &gt; 10, @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>结果返回的是16， 32， 64. 这里显形地对$_进行了使用。 接下来是一个隐形的使用$_的例子， 它来自于模式匹配操作符。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @end_in_4 =  grep /4$/, @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们将会只得到4和64。   </p>

<p>当grep在运行的时候， 它会暂时地把$_中存在的值先遮住， 也就是说grep会借用这个变量， 但是在结束后会把原来的值给放回去。变量$_不是数据条款的一个简单复制， 它是数据条款的一个别名， 同foreach循环中的控制变量很相似。   </p>

<p>如果测试条件很复杂， 我们可以把它藏在一个子程序中：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers;
</span><span class="line">
</span><span class="line">sub digit_sum_is_odd {
</span><span class="line">	my $input = shift;
</span><span class="line">	my @digits = split //, $input; #假设没有非数字字符;
</span><span class="line">	my $sum;
</span><span class="line">	$sum += $_ for @digits;
</span><span class="line">	return $sun % 2;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们会得到一个含有1， 16， 32的列表。这些数字按位求和在子程序的最后一行会得到余数1， 这被认为是是1。  </p>

<p>这种语法是有两种形式的， 我们只是展示给你看了”表达式”的形式， 接下来的是”块”(block)形式。 与其定义一个我们只会在单个测试中使用的显式的子程序，我们不如使用块形式， 把子程序直接放到grep操作符的后面去:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @results = grep {
</span><span class="line">	block;
</span><span class="line">	of;
</span><span class="line">	code;
</span><span class="line">} @input_list;
</span><span class="line">
</span><span class="line">my $count = grep {
</span><span class="line">	block;
</span><span class="line">	of;
</span><span class="line">	code;
</span><span class="line">} @input_list;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就如同”表达式”的形式一样， grep会临时地把输入的列表中的每个元素都放到$_里。接下来它会对正个的代码块进行估值。在代码快中最后一个被估值的表达式是测试表达式。(同所有的测试表达式一样， 它是在标量上下文中被估值的)由于这是一个完整的代码块， 我们可以引进被限制在代码块中的变量。 让我们使用块状形式来重写上一个例子。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @odd_digit_sum = grep {
</span><span class="line">	my $input = $_ ;
</span><span class="line">	my @digit = split //, $input;     ##假设没有非数值的字符
</span><span class="line">	my $sum;
</span><span class="line">	$sum += $_ for @digits;
</span><span class="line">	$sum % 2;
</span><span class="line">} @input_numbers;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意这里的两个变化：输入值是通过$_而不是参数列表传进来的， 以及我们去掉了关键字return。事实上如果我们保留’return‘的话是错误的， 因为我们已经不在一个子程序中了：只是在一个程序块中。当然， 我们可以把那个子程序优化， 因为我们不需要这些中间变量：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @odd_digit_sum = grep {
</span><span class="line">	my $sum;
</span><span class="line">	$sum += $_ for split //;
</span><span class="line">	$sum % 2;
</span><span class="line">} @input_mumbers;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果对你还有你的合作者理解以及维护代码有帮助的话， 你可以随意地加大代码的清晰性。这才是有重要性的主要的事情。  </p>

<h2 id="map">用map来对列表进行变换</h2>

<p>map操作符同grep操作符有着非常相似的语法， 它们也共享很多的相同的操作步骤。 例如， 它临时地把列表中的每个元素一个一个地取出来放到$_中去， 它的语法也同时允许”表达式”以及”块”状形式。  </p>

<p>然而原先的测试条件变成了映射表达式。map操作符会在列表上下文中对这个表达式进行估值(而不是像grep的在标量上下文)。每次对表达式进行估值，都会给出很多结果中的部分。总得结果就是每个单个结果的列表连接。在标量上下文中，map返回在列表上下文中返回的元素的个数。但是除了在列表上下文中，请尽量不要在别的语境中使用map操作符。  </p>

<p>让我们以一个简单的例子来开始：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
</span><span class="line">my @result = map $_ + 100, @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>对这7个元素中的每一个， map都会把它替换到$_中去， 我们会得到一个简单的输出结果：比输入数字大100的数字。 所以@result的值是101， 102， 104， 108， 116， 132还有164。 </p>

<p>但是我们没有被限制在针对每个输入值只能有一个输出值。让我们看下当每一个输入值生成两个输出值是什么情形：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @result = map {$_, 3 * $_} @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在对于每个输入的 条款都有两个条款了： 1，3，2，6，4，12，8，24，16，48，32，96，64，和 192。如果我们需要一个哈希来展现哪个数是一个很小的2的阶乘的3倍的话， 我们可以使用哈希来存储那些数值对。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my %hash = @result;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>或者不使用产生自map的中间数组的话：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my %hash = map{$_, 3 * $_} @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可以看到， map是很灵活的。对于每个输入元素， 我们可以产生任意数目的输出元素。而且对于每个元素， 你没必要产生相同数目的输出元素。让我们看下当把每个位上的数字分开来是什么情况：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @result = map {split //, $_};</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>代码快的行内元素把每一个数字按位分割开来。对于1， 2， 4，还有 8， 我们得到了简单的单个的结果。对于16， 32还有64， 每个数字我们都会得到两个结果。当map连接这个最终的列表时， 我们得到了1，2，4，8，1，6，3，2，6 还有 4。   </p>

<p>如果某个特别的调用产生了一个空的列表的话， map会把那个空的列表连接到整个大的列表中去，对这个列表没有任何的贡献。我们可以使用这个特性来选择还有丢弃一些元素。例如， 假如我们只想要那些数字按位分开后是以4结尾的位：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my @result = map {
</span><span class="line">	my @digits = split //, $_;
</span><span class="line">	if ($digits[-1] == 4) {
</span><span class="line">		@digits;
</span><span class="line">	} else {
</span><span class="line">		();
</span><span class="line">	}
</span><span class="line">} @input_numbers;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果最后一位是4， 我们通过对@digits进行估值(在列表上下文中)， 来返回分割后的位。如果最后一位不是4， 我们返回一个空的列表， 这样就把那个特别的元素产生的结果有效地清除了。所以我们可以总是使用map来代替grep， 但反之则不行。   </p>

<p>当然， 我们使用map还有grep做的任何的事情， 我们同样可以使用显式的foreach循环来做。但是， 我们照样可以用汇编来编程或者把二进制位切换到仪表板上。这里的要点是合理地使grep还有map可以帮忙减少程序的复杂性， 从而允许我们集中精力关注在高层次的问题而不是繁枝末节上。  </p>

<h2 id="eval">使用eval来捕获错误</h2>

<p>如果某些地方出错的话， 许多普通的代码都是有过早地终止一个程序的可能的。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my $average = $total / $count;     #除以0？
</span><span class="line">print "okay\n" unless /$match/;    #非法的模式？   
</span><span class="line">
</span><span class="line">open MINNOW, '&gt;ship.txt'
</span><span class="line">or die "Can't create 'ship.txt': $!";   #用户定义的die？
</span><span class="line">
</span><span class="line">&amp;implement($_) foreach @issue_scheme;    #在子程序中死掉了？
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是仅仅因为我们的代码中的一部分出了问题， 不代表我们希望所有的东西都崩溃掉。Perl使用eval操作符来作为它的错误捕获机制。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">eval {$average = $total / $count};</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当在运行eval块中的代码的时候， 错误出现了， 这个代码快就会结束执行。但是即使块中的代码停止了执行， Perl会继续运行eval后面的代码。最常见的是在eval后面立马检查$@的值，这个值要么是零(意味着没有错误)或者是Perl从出错的代码中得到的崩溃信息，也许是像”除以0”或者一个更长的错误信息。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">eval { $average = $total / $count };
</span><span class="line">print "Counting after error: $@" if $@;    
</span><span class="line">
</span><span class="line">eval { &amp;rescue_scheme_42 };
</span><span class="line">print "Continuing after error: $@" if $@;
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>eval代码块后的分号是必须的， 因为eval是一个函数(而不是一个控制结构， 像if或者while那样)。但是这个块是真正的代码块并且可能包含词法变量(“my” 变量)还有其他的任意的声明。作为一个函数， eval像一个子程序那样是有着一个返回值的(最后一个被估值的表达式， 或者return关键字提前返回的值)。当然如果块中的代码失败了，没有值会返回。这在表两上下文中会给出undef，在列表上下文中会给出一个空的列表。因此， 另外一种计算均值的安全的方法是：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">my $average = eval { $total / $count };
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在$average要么是商要么是undef， 这取决于这个操作完成地成功与否。  </p>

<p>Perl甚至支持嵌套的eval代码块。只要eval在运行着， eval代码块在不或错误方面的的影响力就会延续下去， 所以eval能捕捉到嵌套的子程序调用的错误。尽管如此， eval没办法捕捉到那些最严重的错误， 就是那些Perl会停止运行的错误。 这些包括未捕获的信号， 内存溢出以及一些其他的灾难。 eval也不会捕捉语法的错误。因为Perl会把eval代码块同其余的代码一起编译， 它是在编译时而不是在运行时捕捉错误的。它也不会捕捉warnigns(警告)(尽管Perl提供了一种截取错误信息的方法，请参看$SIG{<strong>WARN</strong>}).  </p>

<h2 id="eval-1">用eval来操作动态代码</h2>

<p>还有第二种形式的eval， 它的参数是一个字符串表达式而不是一个块。它在运行时的时候编译运行来自字符串的代码。 尽管这个允许并且被支持的， 如果有不值得信任的数据进入到字符串中去的话， 会是很危险的。 除了几个很显著的例外之外， 我们建议你避免在字符串上使用eval。我们将会迟点使用它， 你可能在别人的代码中见到它， 所以我们还是在这里展示给你看它是怎么工作的把：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">eval '$sum = 2 + 2';
</span><span class="line">print "The sum is $sum\n";</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl会在这段代码的周围的词法上下文中去执行这些代码， 意味着这事实上如同我们就把代码直接输入在那里一样。eval的结果是最后被估值的表达式，所以其实我们并不需要eval中的整个的声明。 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#!/usr/bin/env perl     
</span><span class="line">
</span><span class="line">foreach my $operator (qw(+ - * /)) {
</span><span class="line">	my $result = eval "2 $operator 2";
</span><span class="line">	print "2 $operator 2 is $result\n";
</span><span class="line">
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里我们遍历了操作符 + - * /并且在我们的eval块中一个个地使用了它们。在我们传给eval的字符串中， 我们把$operator的值插入到字符串中去。 eval执行字符串所代表的代码， 然后返回最后被估值的表达式， 在前面我们把这个表达式赋值给了$result。   </p>

<p>如果eval不能正常地编译运行我们交给它的Perl代码的话， 它就会像在块形式中那样设置$@的值。在下面的例子中， 我们想要捕获除零错误， 但是我们啥值也没有除以(另一种类型的错误)。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">print 'The quotient is ', eval '5 /', "\n";
</span><span class="line">warn $@ if $@;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里eval会捕获语法错误， 把错误信息放到$@中， 在调用eval之后我们就会立即检查这个变量的。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">The quotient is  
</span><span class="line">syntax error at (eval 1) line 2, at EOF</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>后面在第10，17，还有18章中，我们会使用这个方式来选择性地加载模块。如果我们不能加载某个模块， Perl正常情况下会停止这个程序。 所以当这种情况发生的时候， 我们将会捕获到这个错误， 并且自行恢复。  </p>

<p>为了避免你没有注意到我们前面的警告，我们再说一遍: 在使用这种形式的eval的时候要非常的小心。如果能找到另外一种完成你要做的事情的方法的时候，先尝试那个方法。我们会在接来下的第10章中使用它来从外部的文件加载代码， 但是那个时候我们还会展现给你一种更好的做那件事的方法。   </p>

<h2 id="section-1">练习</h2>

<ol>
  <li>练习1[15 分钟] <br />
写一个程序来接收来自命令行的一组文件名，使用grep来选择大小按比特位来算的话小于1000的文件名。使用map来变换这个列表中的字符串， 在每个文件名前放上4个空格， 在后面放上一个换行符。打印最终的结果列表。   </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Find the Password for Pidgin]]></title>
    <link href="http://isunix.github.io/blog/2014/06/05/how-to-find-the-password-for-pidgin/"/>
    <updated>2014-06-05T20:49:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/05/how-to-find-the-password-for-pidgin</id>
    <content type="html"><![CDATA[<p>Use the following command line to find the password for your account on pidgin:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cat $HOME/.purple/accounts.xml | grep pass</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>and it works. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第一章 序言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-%5B%3F%5D-zhang-xu-yan/"/>
    <updated>2014-06-02T23:53:36+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-[?]-zhang-xu-yan</id>
    <content type="html"><![CDATA[<p>欢迎来到理解Perl的下一个阶段。 你来到这里可能是因为你想学写超过100行的Perl程序，又或者是因为你的老板让你学的。  </p>

<p>看， 我们的Learning Perl一书是很了不起的， 因为它介绍了如何在短的到中等长度的程序中使用Perl（用Perl所做的绝大多数编程都是如比）。但是为了避免“美洲驼书”（Learning Perl）变得太大让人恐惧， 我们刻意地小心地省略掉了很多地内容。   </p>

<p>在接下来的内容里， 你可以得到“故事的剩下的部分”， 它是同我们的好朋友“Learning Perl”中同样的风格的。它涵盖了你写100到1000行长的程序所需要的知识。   </p>

<p>例如， 你将学习到怎样和许多程序员在同一个项目上工作。这是很棒的， 因为除非你每天工作35个小时， 你在大的项目上是需要帮助的。你同样得确保当你在你的代码上进展到最终的应用的时候， 你的代码和别人的代码是能够一致的。    </p>

<p>这本书同样向你展示了如何处理更大的更加复杂的数据结构， 比如像我们或许会称作的“哈希的哈希” 或者“array of arrays of hashes of arrays”. 一旦你知道了点references(引用)， 你就开始进入到了任意复杂的数据结构的领域了。   </p>

<p>接着就是面向对象编程这个时髦的观念了， 它允许同一个项目里， 在有着微小或者重大变动的情况下， 可以部分重用你的代码（如果运气好的话，别人的代码）。    </p>

<p>团队合作的一个很重要的一方面是有着发布周期以及单元测试还有整合测试。你将学习到基础的把你的代码打包成一个distribution(发布版本)以及为这个distribution提供单元测试。这既是为了开发， 也是为了验证你的代码在最终的环境里是行得通的。   </p>

<p>正如我们在Learning Perl中承诺以及递交的那样， 我们将会以有趣的例子和坏坏的双关语来一路娱乐你。(我们们已经将Fred, Barney, Betty, 还有wilma遣送回家了。一组新的面孔将会扮演主要的角色。)   </p>

<h2 id="section">你应该已经知道的</h2>

<p>我们将假设你读过了Learning Perl, 或者至少假装你读过了。并且你使用Perl有足够的经验了， 达到了把那些基本的东西消化吸收的程度了。比如你将不会在本书中看到解释如何去获取一个数组的元素或者从subroutine中返回一个值。   </p>

<p>请确认你知道以下的事情：   </p>

<ul>
  <li>怎样在你的系统中运行一个Perl程序。</li>
  <li>三个基本的Pelr的变量类型：标量， 数组，还有哈希。</li>
  <li>控制结构， 诸如while, if, for 以及 foreach。</li>
  <li>Subroutines(子程序)。</li>
  <li>Perl操作符， 诸如grep, map, sort, 还有 print。</li>
  <li>文件操作， 诸如open, file reading, 还有 -X(文件测试)。</li>
</ul>

<p>你可能会在本书中获取到关于这些话题的更深的见解，但是我们将假设你知道这些基础知识了。  </p>

<h2 id="section-1">关于那些脚注</h2>
<p>像在Learning Perl中一样， 这本书把一些初次阅读时会感到生僻的内容降级到脚注里去。你应该在初次阅读的时候跳过那些内容，然后在重读的时候再拾起来。你将不会在脚注中发现在接下来的章节中的内容需要的知识。  </p>

<h2 id="section-2">关于练习</h2>

<p>实际动手操作的训练会让你更好的完成这件工作。最好的提供这种培训的方式就是在半个到一个小时的内容展示之后， 提供一系列的练习题。当然如果你是个快速阅读的人的话， 你结束一章的阅读可能并不需要半个小时。 放慢速度， 深呼吸， 然后做练习。  </p>

<p>每一个练习题都有一个“多少分钟能完成”的评级。我们是想用这个评级来表示完成这个联系所需要的最长的时间， 知识如果你花的时间比所示的时间长或者短很多的话， 请不要感觉糟糕。有的时候只是你在你的学习或者工作当中遇到了多少次同样的编程任务的问题而已。   </p>

<p>每个问题在附录中都有答案。请不要偷看哦， 要不要你就毁了这些习题的价值了。   </p>

<h2 id="perl">如果我是一个Perl的授课老师怎么办？</h2>

<p>如果你是一个决定使用本书来作为你的教材的授课老师， 你应该知道每一组问题， 都是足够的短到了让一个学生在45分钟到一个小时内完成， 而且还会有点时间留下来休息。有的章节的练习题会很快的得到解决， 有的可能得花更长的时间。那是因为一旦那些在中括号中的数字被写好了， 我们发现自己已经不知道该如何往上加了。  </p>

<p>那么就让我们开始吧。在你翻开此页之后课程就开始了。。。 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 前言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan/"/>
    <updated>2014-06-02T23:06:08+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan</id>
    <content type="html"><![CDATA[<p>Perl的面向对象的机制是经典的变戏法。它接收一些Perl中存在的非面向对象特征，诸如packages, references, hashes,arrays, subroutines 以及 modules， 然后（并没有什么锦囊妙计）不知道从什么地方变出来完整的功能性的objects， classes 以及 methods。   </p>

<p>那是很大的一个技巧。这意味着你可以在不用首先掌握很多新的语法或者知晓大量的新的技巧的情况下， 在你已有的Perl知识的基础上继续发展， 轻松地进入面向对象的Perl发展进程中。这也同样意味着你可以通过选择最适合你的任务的已经存在的结构来对面向对象Perl进行微调， 以符合你自己的需要。  </p>

<p>但是这里有个问题。 由于Perl选择packages， references, hashes,arrays, subroutines 以及 modules 作为它的面向对象机制的基石， 为了使用面向对象Perl， 你得已经理解了packages，references, hashes,arrays, subroutines 以及 modules。   </p>

<p>接下来就是所谓的困难了。这里学习的曲线并没有被消除， 而只是被向后推延了几步而已。    </p>

<p>那么接下来你该如何学习一切你应该知道的关于非面向对象的知识，然后你就可以学习一切你因该知道的关于面向对象的知识呢？   </p>

<p>这本书就是答案。在接下来的每页里， Randal会利用他20多年使用Perl的经历， 以及40多年看Gilligan与Ed先生的经验来解释共同支撑着Perl的面向对象特性的每一个组成部分。 更棒的是， 他接着展示了如何联合那些组成的部分来创造有用的classes（类）以及objects（对象）。   </p>

<p>所以当涉及到Perl的objects，references, 以及 modules的时候， 你仍然感觉像是Gilligan， 那么这本书就是Professor要求的。  </p>

<p>以上都是真实的消息哦！   </p>

<p>–Damian Conway, 2003年5月。                                                             </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brew Update Errors Fixed]]></title>
    <link href="http://isunix.github.io/blog/2014/06/01/brew-update-errors-fixed/"/>
    <updated>2014-06-01T16:12:00+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/01/brew-update-errors-fixed</id>
    <content type="html"><![CDATA[<p>I met several errors while updating my homebrew, one is:  </p>

<p><img src="http://isunix.github.io/images/sun/first.png" />    </p>

<p>the solution is:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd `brew --prefix`    
</span><span class="line">git remote add origin https://github.com/mxcl/homebrew.git   
</span><span class="line">git fetch origin    
</span><span class="line">git reset --hard origin/master 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>the other is:   </p>

<p><img src="http://isunix.github.io/images/sun/second.png" />    </p>

<p>To address this this error, we just have have to change the permissions on the folder to a certain user:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">chown -R sun .git  </span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the Error Using Rake New_post Under Zsh]]></title>
    <link href="http://isunix.github.io/blog/2014/05/31/on-the-error-using-rake-new-post-under-zsh/"/>
    <updated>2014-05-31T17:48:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/31/on-the-error-using-rake-new-post-under-zsh</id>
    <content type="html"><![CDATA[<p>When I issue the command “rake new_post[]” using the zsh, I got the error telling me that “no matches found”. I googled, it said if using “noglob rake” rather than simply “rake”, this problem will be solved. But in my case, it does not work. </p>

<p>My expedient solution here is, issuing the followng command:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake "new_post[on the error using rake new_post under zsh]"</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rather than in the normal way:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake new_post["on the error using rake new_post under zsh"]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It works in my case, but it is not a nice solution for sure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Story With Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/05/31/my-story-with-perl/"/>
    <updated>2014-05-31T17:22:45+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/31/my-story-with-perl</id>
    <content type="html"><![CDATA[<p>When I was In college, I am not interested in programming language at all. At that time, I devoted almost all of my time to English study and math thinking. I thought learning computer science was silly, because if you know how to do something(or compute something) in your own language, why do you bother to do it in computer’s language?   </p>

<p>With this thought in my mind, you can guess I did not study computer science very well, although I have to take many courses in CS. I did not fail any one of the courses I took but also not proficient in any of them.  </p>

<p>When I was about to graduate from college, I had to find a job. I was interested in foreign trade then and hoped I could use my English skill and further my interest in economics and business. I did get jobs in this area but when a job oppotunity concerning database with the job title ‘database production analyst’ got landed by me, I gave up my dream of becoming a business man and became a database production analyst, because the latter one offers a more huge salary and better working environment, and that was in year 2011 then, before July.   </p>

<p>I spent the first year of working career not knowing what to do. I was not interested in SQL programming at all, and my job then did not require too much programming skill on SQL. My team leader then is one who is very proficent in SQL Server and T-SQL programming, maybe because of him, I did not further my pursue in SQL programming.    </p>

<p>But I had to learn something then, I thought command line tools very cool, so I spent a lot of time reading other people’s code in the production environment. In order to learn how a web site is built and how to use PHP and javascript, I also joined a team in the company whose aim was to develop an internal management system, my role there was testing, but I did not think I have ever offered any help to the team and the project. Later on when the internal management system was almost finished, my name was also mentioned in the to be appreciated list. I feel quite ashamed.  </p>

<p>So based on the above， you can see I did not get a lot in my first year regarding programming language, but I did begin to make my own choice of what I wanted to learn.</p>

<p>As to my encounter with Perl, I knew the language of Perl in late 2011. I used to spend a lot of time on it when I was in the first company I joined, since that company uses a lot of Perl to do system administratiion. The problem is I have not used perl to write any useful scripts, although I have crafted some small snipptes.   </p>

<p>I always think Perl is not a beautiful language. I know something about Python also, and think Python is more readable than Perl. I have bought and read several books on Python, I have studied some of Python’s advanced usages. I have delved into Django, Flask and Tornado, the three very famous Python web framework. </p>

<p>Also, I have spent quite a while to learn Ruby and Rails. I used to think maybe I should find a job in using ruby because I have read a book on ruby written by its maker Mats then. I found ruby to be very easy and interesting then. I spent several weeks learning ruby and another several week on Rails to learn how to build a web site.  </p>

<p>And currently I am using PHP to write some internal tools for my team. I have to confess I have spent many hours on how to build the environment for PHP and Apache. I read books and watched videos on PHP. PHP is the second language I used besides bash that got deployed to production environment. As to PHP, I want to thank this language because it is easy to use and guided me to the programming world. I get to know a lot of programming concepts through using PHP. Most of the codes I wrote was in PHP.  </p>

<p>When I wanted to join the currnet company, I applied for the job position of becoming a Perl developer. I read the job description and I thought then that I can take this job. But after interviewing with my manager, he thought I was a rookie and I surely was a rookie. So I did not landed the job of becoming a Perl developer but became an analyst again, also reporting to the same manager who interviewed me on Perl developer.</p>

<p>For all these accountings, I have no idea why deep down in my heart I want to write something useful in Perl. Maybe because it is hard, maybe because I believe yes I can. </p>

<p>I want to use this opportunity to further my understanding of Perl. I choose the book “Intermediate Perl” here, and want to translate it into Chinese and expand some of the topics diccussed in that book and write something about them in this blog. I choose this book, because it is the first book on Perl that I bought. I did not buy learning Perl first because I thought I can grasp the basic of Perl just by reading the ebook and there is no need to buy the elementary one. The fact is I bought “learning Perl” several months later. I read “Intermediate Perl” several times, but I can not claim that I can understand it all, actually if I grasp the contents in that book, now it will not be necessary for me to write this post any more. </p>

<p>It is very nice to meet someone who is very proficient in Perl. But what is to be noted is, you can learn from someone, but do not count on someone to help teach you, they do not have the obligations to do that. </p>

<p>That is it, let us embark on a new journey!  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clone Octopress From Github to Another Machine and Publish Posts]]></title>
    <link href="http://isunix.github.io/blog/2014/05/24/clone-octopress-from-github-to-another-machine-and-publish-posts/"/>
    <updated>2014-05-24T14:00:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/24/clone-octopress-from-github-to-another-machine-and-publish-posts</id>
    <content type="html"><![CDATA[<p>When you want to clone a octopress blog from the github to a machine and then enabled to publish posts from the cloned repo, you can follow the following steps:   </p>

<ol>
  <li>git clone -b source https://github.com/isunix/isunix.github.com octopress    </li>
  <li>cd octopress    </li>
  <li>git clone https://github.com/isunix/isunix.github.com _deploy        </li>
  <li>sudo gem install bundler   </li>
  <li>bundle install    </li>
  <li>rake new_post[“The Title of Your Article”]    </li>
  <li>bundle exec rake generate</li>
  <li>bundle exec rake preview    </li>
  <li>bundle exec rake deploy    </li>
  <li>git add . </li>
  <li>git commit -m ‘your comment’  </li>
  <li>git push origin source</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Blog Here]]></title>
    <link href="http://isunix.github.io/blog/2014/05/10/my-first-blog-here/"/>
    <updated>2014-05-10T11:51:22+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/10/my-first-blog-here</id>
    <content type="html"><![CDATA[<p>This is my foreword published on this site using the new name “isunix”. </p>

<p>Previously I was using the name “shpeacelover” which you can google about it.   </p>

<p>However I have not written much useful things under that name. </p>

<p>I hope since now on, I can be more focused on programming and technical things and write more delicately.   </p>

<p>Wish you all have a good time while visiting my dream land!</p>

]]></content>
  </entry>
  
</feed>
