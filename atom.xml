<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Steven's Blog]]></title>
  <link href="http://isunix.github.io/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-01T19:55:08+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remove the ^M Chareacters in a File]]></title>
    <link href="http://isunix.github.io/blog/2014/07/01/remove-the-m-chareacters-in-a-file/"/>
    <updated>2014-07-01T13:45:23+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/01/remove-the-m-chareacters-in-a-file</id>
    <content type="html"><![CDATA[<p>In a file that have multiple “^M” characters in it , we can use vim to remove them.  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="p">:</span><span class="nv">%s</span><span class="sr">/^M/</span><span class="o">/</span><span class="n">g</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>the ^M character is made by typing ctrl + v first then hit enter.   </p>

<p>Also I write a perl script to convert the from dos to unix and also delete chars in code followng the “//”.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">open</span><span class="p">(</span><span class="nv">$IN</span><span class="p">,</span> <span class="s">&quot;$ARGV[0]&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;in: $@&quot;</span><span class="p">;</span>
</span><span class="line"><span class="nb">open</span><span class="p">(</span><span class="nv">$OUT</span><span class="p">,</span> <span class="s">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s">&quot;$ARGV[0].new&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;out: $@&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="sr">&lt;$IN&gt;</span><span class="p">){</span>
</span><span class="line">    <span class="k">my</span> <span class="nv">$line</span> <span class="o">=</span> <span class="nv">$_</span><span class="p">;</span>
</span><span class="line">    <span class="nv">$line</span> <span class="o">=~</span> <span class="sr">s/(\/\/.*)//g</span><span class="p">;</span>
</span><span class="line">    <span class="k">print</span> <span class="nv">$OUT</span> <span class="nv">$line</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nv">$command</span> <span class="o">=</span> <span class="s">&quot;mv $ARGV[0].new $ARGV[0] &amp;&amp; chmod 777 $ARGV[0] &amp;&amp; dos2unix $ARGV[0]&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="nb">system</span><span class="p">(</span><span class="nv">$command</span><span class="p">);</span>
</span><span class="line"><span class="k">print</span> <span class="s">&quot;successfully deleted and converted!\n&quot;</span><span class="p">;</span>
</span><span class="line"><span class="nb">close</span><span class="p">(</span><span class="nv">$IN</span><span class="p">);</span>
</span><span class="line"><span class="nb">close</span><span class="p">(</span><span class="nv">$OUT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The code just explains itself.  </p>

<p>Bingo!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[名言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/30/ming-yan/"/>
    <updated>2014-06-30T21:58:31+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/30/ming-yan</id>
    <content type="html"><![CDATA[<p>You see things, and you say why, but I dream things that never were, and I say why not.  </p>

<p>–Bernard Shaw  </p>

<p>To copy other is necessary，but to copy oneself is pathetic.   </p>

<p>–Pablo Picasso   </p>

<p>It’s nice to be there fighting, trying to go to the limit, bring your body to the limit of his chances,” Nadal said. “Something I really enjoy, and I always said is good to enjoy suffering, no?  So when you are fit, with passion for the game, when you are ready to compete, you are able to suffer and enjoy suffering.  So today I had this feeling, and is a really good one.  I suffered during the match, but I enjoyed all the troubles that I had during the match.  I tried to be there, to find solutions all the time.  I played a lot with my heart.  I played a lot with my mind, and is something that is nice to be around and not just play tennis.   </p>

<p>–Nadal</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginning Python Study Notes]]></title>
    <link href="http://isunix.github.io/blog/2014/06/27/beginning-python-study-notes/"/>
    <updated>2014-06-27T16:15:19+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/27/beginning-python-study-notes</id>
    <content type="html"><![CDATA[<ol>
  <li>input会假设用户的输入是合法的python表达式，而raw_input则不做这样的要求的。  </li>
  <li>在python中列表可以修改， 而元组则不能；会使用改变列表的常用method。   </li>
  <li>一般使用元组作为字典的建， 这种情况下，因为键不可修改，所以就不能够使用列表了。  </li>
  <li>列表的各个元素通过逗号分隔， 写在方括号中。   </li>
  <li>如果分片所得部包括序列结尾的元素， 那么，只需置空最后一个索引即可， 如numbers[-3:], 同样的方法也可以用于序列的开始的元素的。numbers[:3], 如果需要复制整个的序列，可以将两个索引都置空的: numbers[:]   </li>
  <li>pop方法是唯一一既能修改列表又返回元素值的列表方法(除了None)。</li>
  <li>（42，）这是只有一个元素的元组。  </li>
  <li>strip方法返回去除两侧(不包括内部)空格的字符串；</li>
  <li>字典中的值并没有特殊的顺序，但是都存储在一个特定的键里， 键可以是数字， 字符串， 甚至是元组。  </li>
  <li>range函数包含下限， 但是不包含上限。   </li>
  <li>break会跳出循环， 而continue会结束当前的迭代然后跳到下一轮循环的开始的。  </li>
  <li>想要什么事情都不做， 使用pass就可以了。</li>
  <li>执行一个字符串的语句是exec， 如， exec “print ”hello world“   </li>
  <li>eval会计算python表达式， 并且返回结果值。  </li>
  <li>并非所有的python函数都是有返回值的。</li>
  <li>get used to “try except else clause”.</li>
  <li>try finally, finally 可以在可能的异常后面进行清理。   </li>
  <li>sys这个模块能够让你访问与python解释器联系紧密的变量还有函数。</li>
  <li>os模块为你提供了多个访问操作系统服务的功能。  </li>
  <li>关注fileinput这个模块。   </li>
  <li>关注time模块。</li>
  <li>关注re模块。</li>
  <li>re.compile将正则表达式(以字符串书写的)转换为模式对象，可以实现更有效率的匹配。  </li>
  <li>关注getopt还有optparse这两个模块。  </li>
  <li>dir(obj)会返回按字母顺序排序的属性名称列表。  </li>
  <li>help(obj)会提供交互式帮助或者关于特定对象的交互帮助信息。   </li>
  <li>python的open函数的第三个参数控制着文件的缓冲， 如果参数是0， I/O就是无缓冲的， 如果是1， I/O就是有缓冲的, 这就意味着python使用内存来代替硬盘， 让程序更快， 是有使用flush或者close的时候才会更新硬盘上的数据。大于1的数据代表缓冲区的大小，-1代表使用默认的缓冲区的大小。  </li>
  <li>关注urllib还有urllib2模块。   </li>
  <li>关注HTMLParser模块。  </li>
  <li>关注模块BeautifulSoup4</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Algorithms]]></title>
    <link href="http://isunix.github.io/blog/2014/06/24/python-algorithms/"/>
    <updated>2014-06-24T15:23:46+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/24/python-algorithms</id>
    <content type="html"><![CDATA[<p>1.To test the time we used while execting something, we can issue the following command: </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">timeit</span> <span class="o">-</span><span class="n">s</span><span class="s">&quot;import mymodule as m&quot;</span> <span class="s">&quot;m.myfunction()&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or separately: </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">timeit</span>
</span><span class="line"><span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s">&quot;x = 2 + 2&quot;</span><span class="p">)</span>
</span><span class="line">	
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sort in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/06/22/sort-in-perl/"/>
    <updated>2014-06-22T12:31:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/22/sort-in-perl</id>
    <content type="html"><![CDATA[<p>In Perl, function sort() sort the item of an array according to its corresponding acssci code. for example, if we have an array @array = (1, 3, 10, 2, 21) and use sort against this array, we will get the following result: 1 10 2 21 3. However if we want to sort these numbers according to its value, we can use the following method:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">sort</span><span class="p">{</span><span class="nv">$a</span> <span class="sr">&lt;=&gt;</span> <span class="nv">$b</span><span class="p">}</span> <span class="nv">@array</span><span class="p">;</span>   <span class="c1">#ascending</span>
</span><span class="line">
</span><span class="line"><span class="nb">sort</span><span class="p">{</span><span class="nv">$b</span> <span class="sr">&lt;=&gt;</span> <span class="nv">$a</span><span class="p">}</span> <span class="nv">@array</span><span class="p">;</span>   <span class="c1">#descending</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Shell Scripting Cookbook 2nd Notes]]></title>
    <link href="http://isunix.github.io/blog/2014/06/19/linux-shell-scripting-cookbook-2nd-notes/"/>
    <updated>2014-06-19T09:39:37+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/19/linux-shell-scripting-cookbook-2nd-notes</id>
    <content type="html"><![CDATA[<ol>
  <li>get the length of a variable:   </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">length</span><span class="o">=</span><span class="k">${#</span><span class="nv">var</span><span class="k">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>arguments:   </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$1</span> is the first argument
</span><span class="line"><span class="nv">$2</span> is the second argument
</span><span class="line"><span class="nv">$n</span> is the nth argument
</span><span class="line"><span class="s2">&quot;$@&quot;</span>expands as <span class="s2">&quot;$1&quot;</span> <span class="s2">&quot;$2&quot;</span> <span class="s2">&quot;$3&quot;</span> and so on
</span><span class="line"><span class="s2">&quot;$*&quot;</span> expands as <span class="s2">&quot;$1c$2c$3&quot;</span>, where c is the first character of IFS
</span><span class="line"><span class="s2">&quot;$@&quot;</span> is used more often than <span class="s2">&quot;$*&quot;</span>since the former provides all arguments as a single string
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Practical Vim Notes]]></title>
    <link href="http://isunix.github.io/blog/2014/06/16/practical-vim-notes/"/>
    <updated>2014-06-16T00:24:14+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/16/practical-vim-notes</id>
    <content type="html"><![CDATA[<p>接触VIM的日子已经颇长了， 自己现在的VIM的配置已经是非常的强大了，可惜是clone别人的。 只是在一些配置上稍稍做了些改动, 然后添加了一些自己喜欢的package。使用VIM的技艺还是得经常磨练的， 要不然很快就会手生还有遗忘的。 这片文章记录自己再学习«Practical VIM»这本书的时候做的一些笔记， 这些都是自己估计会在coding的时候经常遇到的， 记录下来可以经常查阅。</p>

<h2 id="read-the-forgotten-manual">Read the Forgotten Manual</h2>

<ol>
  <li>
    <p>The Normal mode cw command deletes to the end of the current word and switches to Insert mode.  </p>
  </li>
  <li>
    <p>如果有这么一段：        </p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://pragprog.com/dnvim/&quot;</span><span class="nt">&gt;</span>Practical Vim<span class="nt">&lt;/a&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在normal模式下， 按下vit会选择Practical Vim。</p>

<h2 id="chapter-1--the-vim-way">Chapter 1–The Vim Way</h2>

<ol>
  <li>
    <p>The dot command lets us repeat the last change.   </p>
  </li>
  <li>
    <p>Press A in normal mode will put the cursor at the end of a file and go into insert mode.</p>
  </li>
  <li>
    <p>The s command compounds two steps into one: it deletes the character under the cursor and then enters Insert mode.</p>
  </li>
  <li>
    <p>The f{char} command tells Vim to look ahead for the next occurrence of the specified character and then move the cursor directly to it if a match is found.</p>
  </li>
  <li>
    <p>By pressing the , key, it will repeat the last f{char} search in the reverse direction</p>
  </li>
  <li>
    <p>The * command will executes a search for the word under the cursor at that moment.    </p>
  </li>
</ol>

<h2 id="chapter-2--normal-mode">Chapter 2–Normal Mode</h2>

<ol>
  <li>
    <p>Pressing db deletes from the cursor’s starting position to the beginning of the word.</p>
  </li>
  <li>
    <p>Pressing b will go to the beginning of a word backwordly, while w will do it forwardly.</p>
  </li>
  <li>
    <p>The daw command is easily remembered by the mnemonic delete a word.  </p>
  </li>
  <li>
    <p>The <c-a> and <c-x> commands perform addition and subtraction on numbers.  </c-x></c-a></p>
  </li>
  <li>
    <p>yyp will copy the current line and paste it to the next line.</p>
  </li>
  <li>
    <p>c3w will change 3 words after the cursor. </p>
  </li>
  <li>
    <p>The d{motion} command can operate on a single character ( dl), a complete word ( daw), or an entire paragraph ( dap). Its reach is defined by the motion. The same goes for c{motion}, y{motion}, and a handful of others. Collectively, these commands are called operators. You can find the complete list by looking up :h operator</p>
  </li>
  <li>
    <p>&gt; will shilt right, = will do auto-indent;</p>
  </li>
  <li>
    <p>&#92;&#92;\ will comment the current line.  (I tested&#92;\ will be enough.)</p>
  </li>
  <li>
    <p>If we wanted to autoindent the entire file using the = command, we could run gg=G (that is, gg to jump to the top of the file and then =G to autoindent everything from the cursor position to the end of the file). </p>
  </li>
</ol>

<h2 id="chapter-3--insert-mode">Chapter 3–Insert Mode</h2>

<ol>
  <li>
    <p>In insert mode, <c-h> Delete back one character (backspace), <c-w> Delete back one word, <c-u> Delete back to start of line.   </c-u></c-w></c-h></p>
  </li>
  <li>
    <p>In normal node, yt{char} will copy till the char(not including).   </p>
  </li>
  <li>
    <p>From Normal mode, we can engage Replace mode with the R command.   </p>
  </li>
</ol>

<h2 id="chapter-4--visual-mode">Chapter 4–Visual Mode</h2>

<ol>
  <li>
    <c-v> Enable block-wise Visual mode, gv Reselect the last visual selection, o Go to other end of highlighted text.

</c-v>
  </li>
  <li>
    <p>gU{motion} will make {motion} text uppercase. (In visual mode).</p>
  </li>
  <li>
    <p>In normal mode, vit, which can be read as: visually select inside the tag. </p>
  </li>
  <li>e in normal mode will forward to the end of word (inclusively).   </li>
</ol>

<p>For more about how to use visual mode to append and substitute text, please refer to the book.</p>

<h2 id="chapter-5--command-line-mode">Chapter 5–Command-Line Mode</h2>

<p>基本上跳过了这一章， 只学会：</p>

<ol>
  <li>
    <p>:%s///g;来进行替换。</p>
  </li>
  <li>
    <p>Note the difference between :!ls and :ls—the former calls the ls command in the shell, whereas :ls calls Vim’s built-in command, which shows the contents of the buffer list.</p>
  </li>
  <li>
    <p>On Vim’s command line, the % symbol is shorthand for the current file name. So :!ruby % will run the current file.</p>
  </li>
</ol>

<h2 id="chapter-6--manage-multiple-files">Chapter 6–Manage Multiple Files</h2>

<ol>
  <li>
    <p>In vim, we’re editing an in-memory representation of a file, which is called a buffer in Vim’s terminology. Files are stored on the disk, whereas buffers exist in memory. When we open a file in Vim, its contents are read into a buffer, which takes the same name as the file. Initially, the contents of the buffer will be identical to those of the file, but the two will diverge as we make changes to the buffer. If we decide that we want to keep our changes, we can write the contents of the buffer back into the file.   </p>
  </li>
  <li>
    <p>We can divide this window horizontally with the <c-w>s command, which creates two windows of equal height. Or we can use the <c-w>v command to split the window vertically, producing two windows of equal width.</c-w></c-w></p>
  </li>
  <li>
    <c-w>c Close the active window, <c-w>o Keep only the active window, closing all others.  

</c-w></c-w>
  </li>
  <li>
    <c-w>= Equalize width and height of all windows, <c-w>_ Maximize height of the active window.   

</c-w></c-w>
  </li>
  <li>
    <p>Alternatively, if the current tab page contains more than one window, we can use the <c-w>T command, which moves the current window into a new tab page (see :h CTRL-W_T ).   </c-w></p>
  </li>
  <li>
    <p>:tabc[lose] Close the current tab page and all of its windows, :tabo[nly] Keep the active tab page, closing all others. </p>
  </li>
  <li>:tabn[ext], also gt Switch to the next tab page, :tabp[revious], also gT Switch to the previous tab page.</li>
</ol>

<h2 id="chapter-7--open-files-and-save-them-to-disk">Chapter 7–Open Files and Save Them to Disk</h2>

<p>Just skipped over this chapter.</p>

<h2 id="chapter-8--navigate-inside-files-with-motions">Chapter 8–Navigate Inside Files with Motions</h2>

<ol>
  <li>
    <p>ge Backward to end of previous word.</p>
  </li>
  <li>
    <p>Taken together, the ea commands can be read as “Append at the end of the current word” . The gea command can be read as “append at the end of the previous word”.</p>
  </li>
  <li>
    <p>Vim keeps track of the most recent f{char} search, and we can repeat it using the ; command.</p>
  </li>
  <li>
    <p>The , command repeats the last f{char} search but in the opposite direction.</p>
  </li>
  <li>
    <p>t{char} Forward to the character before the next occurrence of {char}, T{char} Backward to the character after the previous occurrence of {char}.</p>
  </li>
  <li>
    <p>dt. will delete till . </p>
  </li>
  <li>
    <p>We can read the ci” command as “change inside the double quotes.” The cit command can be read as “change inside the tag.” We could just as easily use the yit command to yank the text from inside the tag, or dit to delete it.</p>
  </li>
  <li>
    <p>Keystrokes Buffer Contents      </p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">iw         Current word
</span><span class="line">aw         Current word plus one space
</span><span class="line">iW         Current WORD
</span><span class="line">aW         Current WORD plus one space
</span><span class="line">is         Current sentence
</span><span class="line">as         Current sentence plus one space
</span><span class="line">ip         Current paragraph
</span><span class="line">ap         Current paragraph plus one blank line
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>
    <p>As a general rule, we could say that the d{motion} command tends to work well with aw, as, and ap, whereas the c{motion} command works better with iw and similar.  </p>
  </li>
  <li>
    <p>Learn more about surround.vim;</p>
  </li>
</ol>

<h2 id="chapter-9--navigate-between-files-with-jumps">Chapter 9–Navigate Between Files with Jumps</h2>

<ol>
  <li>gf command means go to file (:h gf ).</li>
</ol>

<h2 id="chapter-10--copy-and-paste">Chapter 10–Copy and Paste</h2>

<ol>
  <li>
    <p>The p command pastes the contents of the unnamed register after the cursor position.</p>
  </li>
  <li>
    <p>Taken together, the xp commands can be considered as “Transpose the next two characters.”</p>
  </li>
  <li>
    <p>The ddp sequence could be considered to stand for “Transpose the order of this line and its successor.”</p>
  </li>
  <li>
    <p>Rather than using a single clipboard for all cut, copy, and paste operations, Vim provides multiple registers. When we use the delete, yank, and put commands, we can specify which register we want to interact with.</p>
  </li>
  <li>
    <p>We can specify which register we want to use by prefixing the command with “{register}. If we don’t specify a register, then Vim will use the unnamedregister.</p>
  </li>
  <li>
    <p>For example, if we wanted to yank the current word into register a, we could run “ayiw. Or if we wanted to cut the current line into register b, we could run “bdd. Then we could paste the word from register a by typing “ap, or we could paste the line from register b by typing “bp.</p>
  </li>
</ol>

<h2 id="chapter-11--macros">Chapter 11–Macros</h2>

<ol>
  <li>
    <p>Macros allow us to record a sequence of changes and then play them back.</p>
  </li>
  <li>
    <p>The q key functions both as the “record” button and the “stop” button. To begin recording our keystrokes, we type q{register}, giving the address of the register where we want to save the macro. We can tell that we’ve done it right if the word “recording” appears in the status line. Every command that we execute will be captured, right up until we press q again to stop recording.</p>
  </li>
  <li>
    <p>The @{register} command executes the contents of the specified register (see :h @ ). We can also use @@, which repeats the macro that was invoked most recently. </p>
  </li>
</ol>

<p>(I have to say I did not finish this chapter!)</p>

<h2 id="chapter-12--matching-patterns-and-literals">Chapter 12–Matching Patterns and Literals</h2>

<ol>
  <li>
    <p>We can override Vim’s default case sensitivity using the \c and \C items. Lowercase \c causes the search pattern to ignore case, while the uppercase \C item forces case sensitivity. If either of these items is used in a search pattern, the value of ‘ignorecase’ is overridden for that search.</p>
  </li>
  <li>
    <p>For using regex in vim, The \v switch at the start causes all subsequent characters to take on a special meaning.</p>
  </li>
</ol>

<p>Miscelleneous</p>

<ol>
  <li>
    <p>Tag navigation and tag autocompletion won’t work unless Vim knows where to look for an up-to-date index file.</p>
  </li>
  <li>
    <p>Command Type of Completion         </p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="nt">&lt;C</span><span class="na">-n</span><span class="nt">&gt;</span> Generic keywords
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-n</span><span class="nt">&gt;</span> Current buffer keywords
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-i</span><span class="nt">&gt;</span> Included file keywords
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-</span><span class="err">]</span><span class="nt">&gt;</span> tags file keywords
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-k</span><span class="nt">&gt;</span> Dictionary lookup
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-l</span><span class="nt">&gt;</span> Whole line completion
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-f</span><span class="nt">&gt;</span> Filename completion
</span><span class="line">
</span><span class="line"><span class="nt">&lt;C</span><span class="na">-x</span><span class="nt">&gt;&lt;C</span><span class="na">-o</span><span class="nt">&gt;</span> Omni-completion
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dancer::Introduction Notes]]></title>
    <link href="http://isunix.github.io/blog/2014/06/16/dancer-introduction-notes/"/>
    <updated>2014-06-16T00:05:17+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/16/dancer-introduction-notes</id>
    <content type="html"><![CDATA[<p>1.A route pattern can contain one or more tokens, and tokens can be optional.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="s">&#39;/hello/:name?&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="s">&quot;Hello there &quot;</span> <span class="o">.</span> <span class="p">(</span><span class="n">param</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s">&quot;whoever you are!&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2.A route can contain a wildcard (represented by a ‘*’). Each wildcard match will be returned in an arrayref, accessible via the `splat’ keyword:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="s">&#39;/download/*.*&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="k">my</span> <span class="p">(</span><span class="nv">$file</span><span class="p">,</span> <span class="nv">$ext</span><span class="p">)</span> <span class="o">=</span> <span class="n">splat</span><span class="p">;</span>
</span><span class="line">    <span class="c1"># do something with $file.$ext here</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>3.A route can be defined with a Perl regular expression. In order to tell Dancer to consider the route as a real regexp, the route must be defined explicitly with qr{}, like the following:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="sx">qr{/hello/([\w]+)}</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="k">my</span> <span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="n">splat</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="s">&quot;Hello $name&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.Routes may include some matching conditions (on the useragent and the hostname at the moment):     </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="s">&#39;/foo&#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">agent</span> <span class="o">=&gt;</span> <span class="s">&#39;Songbird (\d\.\d)[\d\/]*?&#39;</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">  <span class="s">&#39;foo method for songbird&#39;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">get</span> <span class="s">&#39;/foo&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">  <span class="s">&#39;all browsers except songbird&#39;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.An action can choose not to serve the current request and ask Dancer to process the request with the next matching route. This is done with the pass keyword, like in the following example:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="s">&#39;/say/:word&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">pass</span> <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">word</span><span class="p">}</span> <span class="o">=~</span><span class="sr"> /^\d+$/</span><span class="p">);</span>
</span><span class="line">    <span class="s">&quot;I say a word: &quot;</span><span class="o">.</span><span class="n">params</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">word</span><span class="p">};</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">get</span> <span class="s">&#39;/say/:number&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="s">&quot;I say a number: &quot;</span><span class="o">.</span><span class="n">params</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">number</span><span class="p">};</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6.Before hooks, after hooks, before_template_render hooks. </p>

<p>7.You can use the load method to include additional routes into your application.</p>

<p>8.A Dancer application can access the information from its config file easily with the config keyword:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">get</span> <span class="s">&#39;/appname&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="s">&quot;This is &quot;</span> <span class="o">.</span> <span class="n">config</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">appname</span><span class="p">};</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>9.In order to enable the logging system for your application, you first have to start the logger engine in your config.yml:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">logger:</span> <span class="s">&#39;file&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>10.Dancer configures the Template::Toolkit engine to use &lt;% %&gt; brackets instead of its default [% %] brackets, although you can change this in your config file. Of course you have to import the “Template” module.  </p>

<p>11.A layout is a special view, located in the ‘layouts’ directory (inside the views directory) which must have a token named `content’. That token marks the place where to render the action view. This lets you define a global layout for your actions. Any tokens that you defined when you called the ‘template’ keyword are available in the layouts, as well as the standard session, request, and params tokens. This allows you to insert per-page content into the HTML boilerplate, such as page titles, current-page tags for navigation, etc. (refer to the standard document for more details).</p>

<p>12.Through  “set serializer =&gt; ‘JSON’;”  we can do data serializer;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Insert Pictures in Octopress]]></title>
    <link href="http://isunix.github.io/blog/2014/06/15/how-to-insert-pictures-in-octopress/"/>
    <updated>2014-06-15T23:14:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/15/how-to-insert-pictures-in-octopress</id>
    <content type="html"><![CDATA[<p>Of course you can google about it, but I just keep it down so that every time I do it, I do not need to google again. It is pretty easy. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">{\% img [class names] /path/to/image [width] [height] [title text [alt text]] \%}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Of course you need to remove the “\” in the above line. I just it there so it will be interpreted as inserting a pic here. Sorry about this.</p>

<p>Just add your pics in the above format. Note here I add a subdir in the source/images/ dir.  </p>

<p>That is it. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第四章 引用入门]]></title>
    <link href="http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men/"/>
    <updated>2014-06-11T18:45:27+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men</id>
    <content type="html"><![CDATA[<p>引用是Perl的复杂的数据结构，面向对象编程还有花哨的子程序的基石。它们是在Perl4还有Perl5这段时间被添加进去的。    </p>

<p>一个Perl的标量变量存有一个单一的值。一个数组存有一个或者多个标量的有序列表。一个哈希存有一组标量作为值， 然后以另外一组值作为键。尽管一个标量可以是一个任意的字符串，那样就允许复杂的数据被嵌入到数组或者哈希里面去，但是上面的三种数据类型没有一种是很合适复杂的数据间的相互关系的。这就是引用的活了。让我们以一个例子开头看下引用的重要性。  </p>

<h2 id="section">在许多数组上面执行同样的任务</h2>

<p>在Minnow开始一个短途旅途的(例如，一个3小时的观光), 我们应该检查每一个乘客还有全体乘务人员来确保他们都拥有必备的旅行用品。比如说， 为了还上航行的安全，Minnow穿上的每个人都得有个救生圈，一些遮光剂，一个水壶还有一个雨衣。我们可以写一些代码来检查Skipper的储备。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@skipper</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;skipper is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>grep在标量上下文中返回表达式 $item eq $_ 返回 true 的次数，当这件东西在清单里的时候就是1，不在的话就是0. 如果值是0的话，就是假,这个时候我们就把信息给打印出来。   </p>

<p>当然如果我们想要检查Gilligan还有Professor的话，我们可能会写如下的代码:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@gilligan</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;gilligan is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@professor</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;professor is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可能开始注意到这里有很多的冗余的代码，并且想到我们应该把它重构到一个可以重用的通用的子程序中(你是正确的):   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@_</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">			<span class="k">print</span> <span class="s">&quot;$who is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;gilligan&#39;</span><span class="p">,</span> <span class="nv">@gilligan</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl一开始通过它的@_数组给了子程序5个条款：名字gilligan还有属于Gilligan的4个东西。在shift操作之后，@_就只有4个东西了。因此grep通过和清单比对来检查每个所必备的东西。   </p>

<p>到目前为止，一切都很好。我们可以同过一点多余的代码来检查Skipper还有Professor的：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;skipper&#39;</span><span class="p">,</span> <span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;professor&#39;</span><span class="p">,</span> <span class="nv">@professor</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于其他的乘客，我们在需要的地方重复下就行了。尽管这个代码符合一开始的要求，我们有两个问题得处理: </p>

<p>*为了创建@_, Perl把数组的整个内容都拷下下来扫描。对于一个元素的话这没什么问题，但是如果数组很大的话，把数据拷贝然后仅仅就是为了传给子程序的话就显得有点浪费了。   </p>

<p>*假如我们想要修改原先的数组来迫使供应清单包括一些必备的东西，因为我们在子程序中有一个副本(传值),对@_做的任何的修改都不会自动地反映到对应的供应清单数组中去。   </p>

<p>为了解决一个或者两个问题，我们需要的是引用传递而非值传递。这就是doctor(或者Professor)所要求的。  </p>

<h2 id="section-1">对一个数组做引用</h2>

<p>在反斜线()的很多的其他的意思当中，它还是”对某项东西进行引用”的操作符。当我们把它用在一个数组名的前面的时候，比如， \@skipper， 他的结果就是对那个数组的引用。对数组的引用就像是指针: 它指向数组，但是它不是数组本身。  </p>

<p>任何变量适宜地方都是适用于引用。它可以作用于一个数组或者哈希的元素，或者一个普通的标量变量， 像下面这样:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$reference_to_skipper</span> <span class="o">=</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>引用可以被拷贝:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$second_reference_to_skipper</span> <span class="o">=</span> <span class="nv">$reference_to_skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>甚至于：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$third_reference_to_skipper</span> <span class="o">=</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们可以相互交换这3个引用。我们甚至可以说它们是相同的，因为事实上，它们就是相同的东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="nv">$reference_to_skipper</span> <span class="o">=</span> <span class="o">=</span> <span class="nv">$second_reference_to_skipper</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;They are identical references.\n&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个等式比较两个引用的数值形式。这里引用的数值形式是@skipper内部数据结构的唯一的内存地址, 它在变量的生命周期里是不会改变的。如果我们使用eq或者print来查看它的字符串形式，我们会得到调试出来的字符串:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">ARRAY</span><span class="p">(</span><span class="mh">0x1a2b3c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>对于这个数组它也是唯一的，因为它包含了数组的唯一地址的16进制表示。调试出来的字符串同样也表示了这是个数组引用。当然要是我们在我们的代码中看到类似的输出，那就基本上表示了有bug。使用我们代码的用户是对16进制的存储地址块没有兴趣的。  </p>

<p>因为我们可以拷贝一个引用，向一个子程序传递一个参数事实上就是拷贝，我们可以使用下面的代码来向子程序中的数组传递一个引用:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&quot;The Skipper&quot;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="o">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在子程序中的$items是对数组@skipper的一个引用。但是我么怎么能够从一个引用得到我们原先的数组呢? 那当然是我们对引用进行解引用了。</p>

<h2 id="section-2">对数组引用进行解引用</h2>

<p>如果你看一下@skipper的话，你会发现他包含了两部分：@符号以及数组的名字。类似的， 语法$syntax[1]包含了中间部分的数组名以及在外围部分的一些语法来得到数组的第二个元素(指标值1是第二个元素因为指标值从0开始).    </p>

<p>下面有个小的技巧: 我们可以向数组中放置任何一个包含在大括号中的引用，来代替数组名，这样就得到了一个获得原先数组的方法。也就是说，任何我们用skipper来命令数组的地方，我们都可以使用大括号中包含引用的形式.：{$items}。例如， 下面的这两行都表示整个的数组。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">@</span> <span class="nv">skipper</span>
</span><span class="line">
</span><span class="line"><span class="nv">@</span><span class="p">{</span> <span class="nv">$items</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而下面的这两行都表示了数组的第二个元素:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">$skipper</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line">
</span><span class="line"><span class="nv">$</span><span class="p">{</span><span class="nv">$items</span><span class="p">}[</span><span class="mi">1</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>通过使用引用过的形式，我们把代码还有获取数组的方法从实际的数组分离开了。让我们看一下这是怎样改变了这个子程序的其余的部分的。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$items</span><span class="p">})</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">		<span class="k">print</span> <span class="s">&quot;$who is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们所做的就是把@_(供应清单的副本)替换成@{$items},一个对原先供应清单的引用的解引用. 现在我们就可以像之前那样，对子程序调用几次了:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;The Skipper&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;Professor&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@professor</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="n">check_required_items</span><span class="p">(</span><span class="s">&#39;Gilligan&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@gilligan</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在每一种情况下，$items都指向一个不同的数组，所以每次我们调用的时候，同样的代码都指向不同的数组。只是引用的最重要的用法之一: 把代码从它所作用的数据结构上面分离开来，那样我们就可以更方便地重用代码了。  </p>

<p>通过引用传递数组解决了我们之前提到的两个问题中的第一个问题. 现在，我们得到了一个指向供应清单的单一的引用引用， 而不是把整个的供应清单都拷贝到@_数组中去.   </p>

<p>我们可以把子程序开头的两个shift给去掉吗? 当然， 但是那样会牺牲掉清晰性的.   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$_</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">		<span class="k">print</span> <span class="s">&quot;$_[0] is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在@_中仍然有两个元素, 第一个元素是乘客或者乘务人员的名字， 我们将在错误信息中使用到。第二个元素是对正确的供应清单的引用，我们在grep表达式中会使用到.   </p>

<h2 id="section-3">把括号去掉</h2>

<p>绝大多数时候，我们想要解引用的那个引用都是简单的标量变量, 如 @{$items} 或者 ${$items}[1]. 在那些情况下去掉大括号，而毫不含糊地就形成了 @$items或者 $$items[1].  </p>

<p>然而， 要是大括号中的值不是一个简单的标量变量的时候, 我们就不可以把括号个去掉了. 例如, 对于来自上个自程序中的重写@{$_[1]}, 我们就不可以把括号给去掉了, 那是对数组的单一元素的访问，不是一个标量。  </p>

<p>这个规则也表示了我们将很容易看到”缺失”的括号得放到什么地方去. 当我们看到 $$items[1]这个听讨厌的语法的时候，我们可以知道大括号肯定属于简单的表量变量$items的周围。因此，$items肯定是数组的一个引用.  </p>

<p>因此， 上面那个子程序的一个看起来更加舒服的版本就是:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@$items</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">		<span class="k">print</span> <span class="s">&quot;$who is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="p">}</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>唯一的区别就是我们把@$items周围的括号给去掉了.  </p>

<h2 id="section-4">修改数组</h2>

<p>你已经看到了怎样通过一个数组的引用来解决过度的复制的问题. 现在让我们看下怎样修改原先的数组.  </p>

<p>对于每一个缺失的供应品，我们把它push到一个数组里面去， 强迫乘客考虑这个条款:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">sub </span><span class="nf">check_required_items</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$who</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@required</span> <span class="o">=</span> <span class="sx">qw(preserver sunscreen water_bottle jacket)</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@missing</span> <span class="o">=</span> <span class="p">(</span> <span class="p">);</span>
</span><span class="line">	<span class="k">for</span> <span class="k">my</span> <span class="nv">$item</span> <span class="p">(</span><span class="nv">@required</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">unless</span> <span class="p">(</span><span class="nb">grep</span> <span class="nv">$item</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">@$items</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># not found in list?</span>
</span><span class="line">		<span class="k">print</span> <span class="s">&quot;$who is missing $item.\n&quot;</span><span class="p">;</span>
</span><span class="line">		<span class="nb">push</span> <span class="nv">@missing</span><span class="p">,</span> <span class="nv">$item</span><span class="p">;</span>
</span><span class="line">	    <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">	<span class="k">if</span> <span class="p">(</span><span class="nv">@missing</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="k">print</span> <span class="s">&quot;Adding @missing to @$items for $who.\n&quot;</span><span class="p">;</span>
</span><span class="line">	    <span class="nb">push</span> <span class="nv">@$items</span><span class="p">,</span> <span class="nv">@missing</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意下添加的@missing数组。如果我们在扫描的过程中发现了任何物品缺失了， 我们可以把它push到@missing中去。如果在扫描完了之后这个数组中有东西的话，我们就把它添加到原先的供应清单中去。  </p>

<p>关键点就是这个子程序中的最后一行。我们对$items数组引用进行解引用，访问原先的数组，然后把@missing中元素添加进去。要是没有引用传值的话，我们将只能修改数据的一个本地的拷贝，那样将对原先的数组没有任何的影响。  </p>

<p>同样的, @items(以及它的更加常见的形式@{$items})可以在双引号引起来的字符串中运作。我们不可以在@和接下来的任何的字符之间包含空格，尽管我们可以在大括号中包含任意数量的空格， 就好像那是正常的Perl代码一样。  </p>

<h2 id="section-5">嵌套的数据结构</h2>

<p>在下面的例子中，数组@_包含了两个元素, 其中之一仍然是数组. 如果我们对一个数组进行引用，而这个数组又包含了一个一个对数组的引用, 那将会怎么样呢？ 我们得到的将是一个复杂的数据结构, 这将是非常有用的。  </p>

<p>例如, 我们可以先构建一个更大的数据结构，它包含了整个的供应清单, 通过来对数据进行递归，我们将得到Skipper, Gilligan还有Professor的信息:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@skipper</span> <span class="o">=</span> <span class="sx">qw(blue_shirt hat jacket preserver sunscreen)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@skipper_with_name</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Skipper&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@skipper</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@professor</span> <span class="o">=</span> <span class="sx">qw(sunscreen water_bottle slide_rule batteries radio)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@professor_with_name</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Professor&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@professor</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@gilligan</span> <span class="o">=</span> <span class="sx">qw(red_shirt hat lucky_socks water_bottle)</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@gilligan_with_name</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Gilligan&#39;</span><span class="p">,</span> <span class="o">\</span><span class="nv">@gilligan</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在@skipper_with_name就有两个元素了, 第二个元素是数组的引用，同我们之前传递给子程序的是相似的。现在我们把这些都组合起来:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@all_with_names</span> <span class="o">=</span> <span class="p">(</span>
</span><span class="line"><span class="o">\</span><span class="nv">@skipper_with_name</span><span class="p">,</span>
</span><span class="line"><span class="o">\</span><span class="nv">@professor_with_name</span><span class="p">,</span>
</span><span class="line"><span class="o">\</span><span class="nv">@gilligan_with_name</span><span class="p">,</span>
</span><span class="line"><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意我们只有3个元素，其中的每一个都是一个对一个数组的引用，这个数组有两个元素: 名字还有对应的初始供应列表。图4-1是它的一个图片:  </p>

<p><img src="http://isunix.github.io/images/sun/perl_4.1.png" />   </p>

<p>因此，$all_with_names[2]将会是对于Gilligan的数据的数组引用。如果你把它解引用的话@{$all_with_names[2]}，你将得到一个两个元素的数组，”Gilligan”还有另一个数组引用。 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第三章 使用模块]]></title>
    <link href="http://isunix.github.io/blog/2014/06/08/intermediate-perl-di-san-zhang-shi-yong-mo-kuai/"/>
    <updated>2014-06-08T01:16:53+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/08/intermediate-perl-di-san-zhang-shi-yong-mo-kuai</id>
    <content type="html"><![CDATA[<p>模块是我们的程序的基础部分。他们提供可重用的子程序，变量，甚至面向对象的类。在我们建造自己的模块的过程中， 我们会向你展现一些你可能会感兴趣的。我们同样会看一些别人已经写好的模块的用法。   </p>

<h2 id="section">标准发布版本</h2>

<p>Perl本身已经自带了很多的流行的模块。事实上， 最新进的50+MB的发布版本中的绝大部分都是来自于模块。在1996年10月， Perl 5.003_07版本中有98个模块。今天， 在2006年年初， Perl5.8.8有359个模块。事实上这是Perl的一个优势之一:它已经自带了很多的你在写有用的还有复杂的程序的时候所需要的东西， 那样就省了你的很多的工作了。   </p>

<p>在整本书中， 我们都会试着识别出哪些模块是Perl自带的(在大部分情况下， 识别出它们是自哪一版开始进入Perl的)。我们将称呼这些为”核心模块” 或者强调它们是在”标准发布版本”中。如果你安装了Perl, 你应该就有了这些模块。由于当我们在写作本书的时候， 我们使用的是Perl 5.8.7, 我们将假定这就是当前的Perl的版本。    </p>

<p>当你在开发自己的代码的时候， 你可能会考虑自己是否想要只使用核心模块，那样你就可以确信任何其他只要是和你的Perl版本是一样的人， 都将会有那些模块。我们将会避开这个争论， 主要是因为我们太爱CPAN了， 简直离不开它了。   </p>

<h2 id="section-1">使用模块</h2>
<p>几乎每一个Perl模块都跟有文档，即使我们可能不知道所有的幕后的魔术是怎么运作的，当我们知道如何使用接口的时候我们真的没必要担心那些。毕竟那就是接口存在的原因: 隐藏细节。   </p>

<p>在我们的本地机器上， 我们可以使用perldoc命令来阅读模块的文档。我们把感兴趣的模块的名称给它，它就会帮我们输出模块的文档。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">NAME</span>
</span><span class="line">	<span class="n">fileparse</span> <span class="err">−</span> <span class="nb">split</span> <span class="n">a</span> <span class="n">pathname</span> <span class="n">into</span> <span class="n">pieces</span>
</span><span class="line">
</span><span class="line">	<span class="n">basename</span> <span class="err">−</span> <span class="n">extract</span> <span class="n">just</span> <span class="n">the</span> <span class="n">filename</span> <span class="n">from</span> <span class="n">a</span> <span class="n">path</span>
</span><span class="line">
</span><span class="line">	<span class="n">dirname</span> <span class="err">−</span> <span class="n">extract</span> <span class="n">just</span> <span class="n">the</span> <span class="n">directory</span> <span class="n">from</span> <span class="n">a</span> <span class="n">path</span>
</span><span class="line">	
</span><span class="line"><span class="n">SYNOPSIS</span>
</span><span class="line">	<span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="p">(</span><span class="nv">$name</span><span class="p">,</span><span class="nv">$path</span><span class="p">,</span><span class="nv">$suffix</span><span class="p">)</span> <span class="o">=</span> <span class="n">fileparse</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">,</span><span class="nv">@suffixlist</span><span class="p">)</span>
</span><span class="line">	<span class="n">fileparse_set_fstype</span><span class="p">(</span><span class="nv">$os_string</span><span class="p">);</span>
</span><span class="line">	<span class="nv">$basename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">,</span><span class="nv">@suffixlist</span><span class="p">);</span>
</span><span class="line">	<span class="nv">$dirname</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="nv">$fullname</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们把文档的顶部的那段包含了进来是为了向你展示最重要的部分(至少是在你刚开始的时候是最重要的)。模块的文档一般都会遵循过去的unix主页的格式， 也就是以NAME还有SYNOPSIS部分开始。   </p>

<p>大纲部分给出了模块使用的例子。如果我们能够停止一会儿理解， 然后跟着例子来， 我们就可以使用某个模块了。也就是说，可能你还不是很熟悉大纲中的某些Perl的技巧和语法，但是你可以仅仅是跟着例子来然后让一切运行完好。   </p>

<p>现在由于Perl是过程式，函数式，面向对象以及其它的语言类型的综合体， Perl的模块也有着不同接口。我们将会以稍微有点不同的方式来使用这些模块，但是只要我们能够去查阅文档，就应该不会有问题的。   </p>

<h2 id="section-2">功能性接口</h2>
<p>为了加载一个模块，我们使用Perl内建的use。我们在这里不会进入所有具体的细节，但是在第10章还有第15章我们会的。现在我们只是想使用模块。让我们以File::Basename这个核心发布版本中的模块来开始。为了把它加载到我们的脚本中去， 我们来：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当我们这么做的时候， File::Basename向我们的脚本中引进三个子例程，fileparse, basename 以及 dirname， 从此刻起， 我们可以这么来:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$basename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span> <span class="nv">$some_full_path</span> <span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$dirname</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span> <span class="nv">$some_full_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这就好像是我们自己写了basename还有dirname这两个子例程， 或者它们像是(接近是)内建的Perl函数一样。 这些子程序会把路径名中的文件名还有目录名找出来。例如， 如果 $some_full_path 是 D:\Projects\IsIandRescue\plan7.rtf(假定程序是在windows机器上运行的), 那么$basename将会是plan7.rtf, $dirname将会是D:\Projects\IsIandRescue。    </p>

<p>File::Basename这个模块自己会知道它是在何种机器上运行的, 因此它的函数能够明白怎么正确地针对我们可能遇到的分隔符来解析字符串。   </p>

<p>然而，假定我们已经有了一个叫dirname的子程序， 现在我们就会用File::Basename中的定义把它覆盖掉了. 如果我们已经开启了warnings，我们将会看到一个消息声明。否则的话，Perl就完全地不关心了。   </p>

<h2 id="section-3">选择引入什么</h2>

<p>幸运的是， 我们可以告诉use操作通过在模块名的后面明确一组子程序的名字，也叫做引入列表， 来限制它的行为:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">(</span><span class="s">&#39;fileparse&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">basename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在这个模块仅仅给我们提供了两个子程序， 不会干扰我们自己的dirname子程序了。当然，那样输入起来很别扭, 所以更经常的我们看到的是用引用字操作符写出来的形:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span> <span class="sx">qw(fileparse basename)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>事实上，即使只有一个条款，为了连贯还有维护我们也倾向于用qw()列表来写出来；经常地我们会返回去说”在这了再给我加一条”, 这个时候如果已经是个qw()列表的话会更容易的。   </p>

<p>我们已经保护了本地的dirname子程序，但是如果我们依然想要File::Basename提供的功能呢？没问题，我们只要用它的完整的包的指定形式写出来就可以了：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$dirname</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">dirname</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>use后面的一组名字不会改变到底有哪些子程序在模块的包中定义好了(在我们的情况下是File::Basename)。 我们总是可以使用完整的包的名字的形式而不用管引用列表， 就如同下面一样:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$basename</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">basename</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在极端的情况下(但是极其的有用)，我们可以指定为引用列表制定一个空的列表， 如下： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Basename</span><span class="p">();</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$base</span> <span class="o">=</span> <span class="nn">File::Basename::</span><span class="n">basename</span><span class="p">(</span><span class="nv">$some_path</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>一个空的列表和一个缺失的列表是有所不同的。 一个空的列表意味着”不要给我任何的东西”, 而一个缺失的列表意味着给我默认的”。如果模块的作者做的很好的话，默认的情况就是我们所需要的。  </p>

<h2 id="section-4">面向对象接口</h2>

<p>通过看下File::Spec模块， 我们来比较下File::Basename引入的子程序和其之间的区别。File::Spec模块是设计来支持通常作用在文件指定上的操作的。(一个文件指定通常是一个文件或者一个路径名，但它可能是一个不存在的文件-在这种情况下，它就不是一个真正的文件名，对不对？) </p>

<p>同File::Basename模块不同的是，File::Spec有着一个主要的面向对象接口。如同我们之前的那样， 我们也用use来加载模块:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">File::</span><span class="n">Spec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然而，由于这个模块有着面向对象的接口，它不支持任何的子程序。作为替代，这个接口告诉我们使用它的类方法来获取它的模块的功能。catfile方法把一组字符串用合适的目录分割符来连接起来:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$filespec</span> <span class="o">=</span> <span class="nn">File::</span><span class="n">Spec</span><span class="o">-&gt;</span><span class="n">catfile</span><span class="p">(</span> <span class="nv">$homedir</span><span class="p">{</span><span class="n">gilligan</span><span class="p">},</span> <span class="s">&#39;web_docs&#39;</span><span class="p">,</span> <span class="s">&#39;photos&#39;</span><span class="p">,</span>           	<span class="s">&#39;USS_Minnow.gif&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这样就会调用File::Spec类中的catfile类方法， 它会构造一个适合于本地的操作系统的路径然后返回一个单一的字符串。 在语法上这同File::Spec所提供的将近两打的其他的操作是相似的。  </p>

<p>File::Spec模块以一种可移植的方式为处理文件路径提供了好几个其他的方式。 你可以在perlport文档中阅读更多的关于可移植性的问题。   </p>

<h2 id="mathbigint">一个更典型的面向对象模块:Math::BigInt</h2>

<p>由于File::Spec模块没有对象，为了不被它看起来非面向对象的特征所失望，让我们看一下另外的一个核心的模块，Math::BigInt, 他可以在Perl的一般能力范围之外处理整数。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">Math::</span><span class="n">BigInt</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nn">Math::</span><span class="n">BigInt</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">#以2开始；</span>
</span><span class="line"><span class="nv">$value</span><span class="o">-&gt;</span><span class="n">bpow</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>   			   <span class="c1">#2**100-</span>
</span><span class="line"><span class="k">print</span> <span class="nv">$value</span><span class="o">-&gt;</span><span class="n">bstr</span><span class="p">(),</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span> 	   <span class="c1">#打印出来</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>同之前的一样，这个模块什么都没有引入。它的完整的接口使用类方法，诸如new, 接在类名后面来生成实例，然后接在这些实例之后调用实例方法，像bpow还有bstr。   </p>

<h2 id="perlcpan">详尽的Perl存档网络(CPAN)</h2>

<p>(未翻!)   </p>

<h2 id="cpan">从CPAN来安装模块</h2>

<p>从CPAN来安装一个简单的模块可以是很直接的：我们下载模块发布版本的存档，解压出来，切换到它的目录中去。 我们在这儿使用wget，但其实你使用哪个工具是无关紧要的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">wget</span> <span class="n">http:</span><span class="sr">//</span><span class="n">www</span><span class="o">.</span><span class="n">cpan</span><span class="o">.</span><span class="n">org</span><span class="sr">/.../</span><span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">tar</span> <span class="err">−</span><span class="n">xzf</span> <span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">cd</span> <span class="n">HTTP</span><span class="err">−</span><span class="n">Cookies</span><span class="err">−</span><span class="n">Safari</span><span class="err">−</span><span class="mf">1.10</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>从那儿起我们可以走两条路中的一种。如果我们找到一个叫Makefile.PL的文件，我们可以运行下面的命令来build, test还有最终的安装这个源码:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Makefile</span><span class="o">.</span><span class="n">PL</span> <span class="nv">%</span> <span class="nv">make</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">make</span> <span class="n">test</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">make</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果你没有权限在系统范围的目录中安装模块，我们可以通过使用PREFIX参数来告诉Perl在别的路径下安装：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Makefile</span><span class="o">.</span><span class="n">PL</span> <span class="n">INSTALL_BASE</span><span class="o">=</span><span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了让Perl在那个目录中寻找模块，我们可以设置PERL5LIB环境变量。Perl会把那些目录添加到它的模块搜获列表中去。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">export</span> <span class="n">PERL5LIB</span><span class="o">=</span><span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们也可以使用lib指令来添加到模块搜索路径中去，尽管这看起来不是很友好，因为我们得改变代码，但也因为可能它不是我们在其他的我们想要代码跑起来的机器上的路径:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="c1">#!/usr/bin/perl</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="sx">qw(/Users/home/Ginger)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>先后退一小会儿，如果我们找到的是Build.PL这个文件而不是Makefile.Pl这个文件，过程将会是一样的。 这些发布版本使用Module::Build来build还有install代码。由于Module::Build不是核心的Perl模块，我们得在我们能够安装使用它的发布版本之前安装它:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span><span class="o">.</span><span class="n">PL</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span> <span class="n">test</span>
</span><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了用Module::Build安装到我们的私有的目录，我们添加 –install_base 参数。我们以和前面的同样的方式告诉Perl如何来找到模块:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">%</span> <span class="nv">perl</span> <span class="n">Build</span><span class="o">.</span><span class="n">PL</span> <span class="err">−−</span><span class="n">install_base</span> <span class="sr">/Users/</span><span class="n">home</span><span class="o">/</span><span class="n">Ginger</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>有的时候我们会在一个发布版本中看到Makefile.PL还有Build.PL这两个文件。那个时候我们该怎么做呢？我们可以使用任意一个。选择你最喜欢的来玩！  </p>

<h2 id="section-5">在合适的时间来设定路径</h2>

<p>Perl通过在特殊的Perl数组@INC中定义的路径来查找模块。use声明在编译时执行，所以它会在编译时查看模块搜索路径@INC。除非我们把@INC考虑在内，否则那会以一种很难理解的方式让我们的程序崩溃掉。   </p>

<p>例如，假设我们有自己的目录/home/giliigan/lib, 我们把自己的模块Navigation::SeatOfPants放在/home/gilligan/lib/Navigation/SeatOfPants.pm里。当我们加载自己的模块的时候，Perl就找不到了。 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>Perl会向我们抱怨它在@INC中找不到模块， 并且会展现给我们看在那个数组里的所有的路径:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">Can</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">locate</span> <span class="n">Navigation</span><span class="o">/</span><span class="n">SeatofPants</span><span class="o">.</span><span class="n">pm</span> <span class="n">in</span> <span class="nv">@INC</span> <span class="p">(</span><span class="nv">@INC</span> <span class="n">contains:</span> <span class="o">...</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可能会想我们应该仅仅在调用use之前把我们的模块的路径添加到@INC中去。然而，即使添加如下的东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">unshift</span> <span class="nv">@INC</span><span class="p">,</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span> <span class="c1"># 崩溃</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>也不会起作用的。为什么呢？因为unshift在运行时才起作用，这是use在编译之后的很长时间才发生的。这两个声明在词法上很接近， 但是在时间上并不接近。仅仅因为我们把它们写在了一块并不表示它们是以那样的顺序来执行的。我们想在use执行前改变@INC。一种处理这个的方式是在unshift周围添加一个BEGIN块:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">unshift</span> <span class="nv">@INC</span><span class="p">,</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在这个BEGIN块就会在编译时编译还有运行了, 会接下来的use设置合适的路径。   </p>

<p>然而，这很烦人而且需要的解释可能超出了你觉得舒服的范围了，尤其是对于那些后来的可能需要维护修改你的代码的人。让我们以一种我们之前用过的一种简单的声明来代替那一团东西:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里， lib声明会接收一个或者多个参数然后把它们添加到@INC数组的开头，就如同之前的unshift所做的。这是行得通是因为它是在编译时执行的，而不是在运行时。因此它对紧接着的use是适时的。 </p>

<p>一个use lib声明通常总是有一个地址依赖的路径名，一般情况下我们鼓励大家把它放到文件的开头的部分。这样当我们得移动文件到一个新的系统或者lib的路径有变化的时候，我们在找的时候还有更新的时候会方便点的。(当然，如果我们能够在标准的@INC地址中安装我们的模块的话，我们就可以避免使用use lib了， 但那并不总是实际的.)    </p>

<p>要把use lib想成是“使用这个路径来找到我的库(还有模块)” 而不是使用这个目录。很经常的，我们会看到如下的代码:     </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="s">&#39;/Users/gilligan/lib/Navigation/SeatOfPants.pm&#39;</span><span class="p">;</span> <span class="c1"># 错误</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然后这个程序要会想为什么没有把定义给加载进来. 要注意use lib事实上是在编译时运行的，所以下面的也是不会起作用的:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$LIB_DIR</span> <span class="o">=</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="o">...</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="nv">$LIB_DIR</span><span class="p">;</span> <span class="c1"># 崩溃</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当然，Perl在编译时就会建立起$LIB_DIR的声明（所以用use strict的时候我们是不会得到错误警告的，尽管真正的use lib是会抱怨的)， 但是真正的/home/gilligan/lib的值是直到运行时才会赋值的。呀，又太迟了。  </p>

<p>此时此刻，我们得在BEGIN块里放进一些东西，或者依靠另一个编译时操作:用use constant来设置一个常数:    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">use</span> <span class="n">constant</span> <span class="n">LIB_DIR</span> <span class="o">=&gt;</span> <span class="s">&#39;/Users/gilligan/lib&#39;</span><span class="p">;</span>
</span><span class="line"><span class="o">...</span>
</span><span class="line"><span class="k">use</span> <span class="n">lib</span> <span class="n">LIB_DIR</span><span class="p">;</span>
</span><span class="line"><span class="k">use</span> <span class="nn">Navigation::</span><span class="n">SeatOfPants</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>啊哈，又解决了。就是这个样子了，除非我们需要模块依赖一个计算的结果。(啥时该休止啊，快来人让这个疯狂的行为停止掉吧!)这应该会解决99%我们的需要了。  </p>

<h2 id="section-6">解决模块的依赖性</h2>

<p>我们刚刚看到如果我们想要安装一个需要使用Module::Build的模块，我们得先安装Module::Build。那只是令我们头疼的依赖性问题中的很小的一个例子了。 我们可能得安装好几个其他的模块，它们当中的每一个又都反过来得依赖更多的模块。   </p>

<p>幸运的是， 我们有工具来帮助我们。CPAM.pm模块自从Perl5.004就是核心发布版本的一个部分了。它给了我们一个交互的安装shell.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">$</span> <span class="nv">perl</span> <span class="o">-</span><span class="n">MCPAN</span> <span class="o">-</span><span class="n">e</span> <span class="n">shell</span>
</span><span class="line"><span class="n">cpan</span> <span class="n">shell</span> <span class="o">--</span><span class="n">CPAN</span> <span class="n">exploration</span> <span class="o">....</span>
</span><span class="line"><span class="n">Readline</span> <span class="n">support</span>
</span><span class="line">
</span><span class="line"><span class="n">cpan</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>为了安装一个模块还有它的依赖，我们使用命令install然后跟着模块的名字.现在CPAN.pm处理所有的下载，解压，building, 测试嗨哟安装模块的过程， 而且它会递归地处理那些依赖:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span><span class="o">&gt;</span> <span class="n">install</span> <span class="nn">CGI::</span><span class="n">Prototype</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>只是那也太多了，所以Brian创建了一个脚本cpan，它也是跟着Perl发行版本的。我们只要把我们想要安装的模块列出来，它就会帮我们处理接下来的情况了:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span> <span class="nn">CGI::</span><span class="n">Prototype</span> <span class="nn">HTTP::Cookies::</span><span class="n">Safari</span> <span class="nn">Test::</span><span class="n">Pod</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另一个很酷的工具是CPANPLUS，是CPAN.pm的完全的重写，但是在我么写作本书的时候它还不是核心发布版本中的一部分.   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nv">$</span> <span class="nv">perl</span> <span class="o">-</span><span class="n">MCPANPLUS</span> <span class="o">-</span><span class="n">e</span> <span class="n">shell</span>
</span><span class="line"><span class="n">CPAN</span> <span class="n">Terminal</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了安装一个模块，我们使用i命令.  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">CPAN</span> <span class="n">Terminal</span><span class="o">&gt;</span> <span class="n">i</span> <span class="nn">CGI::</span><span class="n">Prototype</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>CPANPLUS模块带了一个很方便的脚本，叫cpanp。我们我们给它i开关还有一组模块，它就会像之前那样安装它们了    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">cpan</span> <span class="n">i</span> <span class="nn">CGI::</span><span class="n">Prototype</span> <span class="nn">HTTP::Cookies::</span><span class="n">Safari</span> <span class="nn">Test::</span><span class="n">Pod</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-7">练习</h2>
<p>(未翻)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Php-cgi Not Found Error]]></title>
    <link href="http://isunix.github.io/blog/2014/06/07/php-cgi-not-found-error/"/>
    <updated>2014-06-07T14:56:33+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/07/php-cgi-not-found-error</id>
    <content type="html"><![CDATA[<p>Today while I was running a php script from the PHPStrom by a browser, I got the following error telling me that “php-cgi not found.”. I have no other way but to install a new version of php, my original version is 5.4.24, I then installed a 5.5 version.  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">curl -s http://php-osx.liip.ch/install.sh | bash -s 5.5
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and in my phpstorm, I use the path, “usr/local/php5/bin” as the interpreter’s path. It works now.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Up PHP and Apache on Mac OS]]></title>
    <link href="http://isunix.github.io/blog/2014/06/07/set-up-php-and-apache-on-mac-os/"/>
    <updated>2014-06-07T14:25:00+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/07/set-up-php-and-apache-on-mac-os</id>
    <content type="html"><![CDATA[<p>I have set up Apache and PHP on my computer many times, every time I googled or Baidued about it, it is high time to keep a note about those steps.    </p>

<ol>
  <li>sudo mate /etc/apache2/httpd.conf</li>
  <li>uncomment “#LoadModule php5_module libexec/apache2/libphp5.so”</li>
  <li>save the file and quit. </li>
  <li>sudo cp /etc/php.ini.default /etc/php.ini</li>
  <li>sudo apachectl start </li>
  <li>ln -s /Library/WebServer/Document $HOME/www</li>
  <li>rename the file “index.html.en” or just delete the file if you do not want to be botthered.  </li>
</ol>

<p>That’s the steps all it takes to set up your apache and PHP on a MAC OS machine.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第二章 中级基础]]></title>
    <link href="http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu/"/>
    <updated>2014-06-06T17:07:24+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu</id>
    <content type="html"><![CDATA[<p>在我们开始这本书的实质内容之前， 我们想介绍些在本书中使用的中级水平的Perl习语。通常就是这些东西把初级的还有中级水平的Perl程序员区别开的。 在这个过程中， 我们还会把你介绍给将在本书中的例子中使用的一组角色。   </p>

<h2 id="section">列表操作符</h2>

<p>你已经知道了一些Perl中的列表操作符， 但是你可能没有把它们想成是同列表相联系的。最常见的列表操作符可能是print。 我们给它一个或者更多的参数， 它会为我们把这些参数组织到一起。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">print</span> <span class="s">&#39;Two castaways are &#39;</span><span class="p">,</span> <span class="s">&#39;Gilligan&#39;</span><span class="p">,</span> <span class="s">&#39; and &#39;</span><span class="p">,</span> <span class="s">&#39;Skipper&#39;</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有其他一些你已经在Learning Perl一书中理解到了的列表操作符。sort操作符把输入的列表排序。在这些被流放的人他们所表演的主题曲中，他们没有按照字母顺序出场， 但是sort可以帮我们解决这个问题。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@castaways</span> <span class="o">=</span> <span class="nb">sort</span> <span class="sx">qw(Gilligan Skipper Ginger Professor Mary-Ann)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而reverse操作符可以返回一个反序的列表：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@castaways</span> <span class="o">=</span> <span class="nb">reverse</span> <span class="sx">qw(Gilligan Skipper Ginger Professor Mary-Ann)</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl中还有很多其他的同列表用在一起的操作符， 一旦你习惯了它们，你将会发现自己字敲得更少了， 表达自己的意图更加地清晰了。   </p>

<h2 id="grep">用grep来进行列表过滤</h2>

<p>grep操作符接收一个列表还有一个“测试条件”。 然后它把别表中的值一个接着一个地拿出来，放到$_这个变量里。 接来下grep会在标量上下文中估值这个测试条件。如果这个表达式估值成一个true的值， grep就会把$_传递给输出列表。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@lunch_choices</span> <span class="o">=</span> <span class="nb">grep</span> <span class="o">&amp;</span><span class="n">is_edible</span><span class="p">(</span><span class="nv">$_</span><span class="p">),</span> <span class="nv">@gilligans_profession</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在列表上下文中， grep操作符会返回所有选出来的条款。而在标量环境中， grep会返回选出来的条款的数量。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@results</span> <span class="o">=</span> <span class="nb">grep</span> <span class="n">EXPR</span><span class="p">,</span> <span class="nv">@input_list</span><span class="p">;</span>
</span><span class="line"><span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nb">grep</span> <span class="n">EXPR</span><span class="p">,</span> <span class="nv">@input_list</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里EXPR表示的是任意的适用于$_的标量表达式(明确地或者隐含着的)。例如， 为了找到所有大于10的数， 在我们的grep表达式中， 我们检查看$_是否大于10.   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@input_numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@bigger_than_10</span> <span class="o">=</span> <span class="nb">grep</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>结果返回的是16， 32， 64. 这里显形地对$_进行了使用。 接下来是一个隐形的使用$_的例子， 它来自于模式匹配操作符。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@end_in_4</span> <span class="o">=</span>  <span class="nb">grep</span> <span class="sr">/4$/</span><span class="p">,</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们将会只得到4和64。   </p>

<p>当grep在运行的时候， 它会暂时地把$_中存在的值先遮住， 也就是说grep会借用这个变量， 但是在结束后会把原来的值给放回去。变量$_不是数据条款的一个简单复制， 它是数据条款的一个别名， 同foreach循环中的控制变量很相似。   </p>

<p>如果测试条件很复杂， 我们可以把它藏在一个子程序中：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@odd_digit_sum</span> <span class="o">=</span> <span class="nb">grep</span> <span class="n">digit_sum_is_odd</span><span class="p">(</span><span class="nv">$_</span><span class="p">),</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">sub </span><span class="nf">digit_sum_is_odd</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$input</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@digits</span> <span class="o">=</span> <span class="nb">split</span> <span class="sr">//</span><span class="p">,</span> <span class="nv">$input</span><span class="p">;</span> <span class="c1">#假设没有非数字字符;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>
</span><span class="line">	<span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@digits</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="nv">$sun</span> <span class="nv">%</span> <span class="nv">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们会得到一个含有1， 16， 32的列表。这些数字按位求和在子程序的最后一行会得到余数1， 这被认为是是1。  </p>

<p>这种语法是有两种形式的， 我们只是展示给你看了”表达式”的形式， 接下来的是”块”(block)形式。 与其定义一个我们只会在单个测试中使用的显式的子程序，我们不如使用块形式， 把子程序直接放到grep操作符的后面去:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@results</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span>
</span><span class="line">	<span class="n">block</span><span class="p">;</span>
</span><span class="line">	<span class="n">of</span><span class="p">;</span>
</span><span class="line">	<span class="n">code</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nv">@input_list</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span>
</span><span class="line">	<span class="n">block</span><span class="p">;</span>
</span><span class="line">	<span class="n">of</span><span class="p">;</span>
</span><span class="line">	<span class="n">code</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nv">@input_list</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就如同”表达式”的形式一样， grep会临时地把输入的列表中的每个元素都放到$_里。接下来它会对正个的代码块进行估值。在代码快中最后一个被估值的表达式是测试表达式。(同所有的测试表达式一样， 它是在标量上下文中被估值的)由于这是一个完整的代码块， 我们可以引进被限制在代码块中的变量。 让我们使用块状形式来重写上一个例子。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@odd_digit_sum</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$input</span> <span class="o">=</span> <span class="nv">$_</span> <span class="p">;</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@digit</span> <span class="o">=</span> <span class="nb">split</span> <span class="sr">//</span><span class="p">,</span> <span class="nv">$input</span><span class="p">;</span>     <span class="c1">##假设没有非数值的字符</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>
</span><span class="line">	<span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@digits</span><span class="p">;</span>
</span><span class="line">	<span class="nv">$sum</span> <span class="nv">%</span> <span class="nv">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意这里的两个变化：输入值是通过$_而不是参数列表传进来的， 以及我们去掉了关键字return。事实上如果我们保留’return‘的话是错误的， 因为我们已经不在一个子程序中了：只是在一个程序块中。当然， 我们可以把那个子程序优化， 因为我们不需要这些中间变量：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@odd_digit_sum</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>
</span><span class="line">	<span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nb">split</span> <span class="sr">//</span><span class="p">;</span>
</span><span class="line">	<span class="nv">$sum</span> <span class="nv">%</span> <span class="nv">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nv">@input_mumbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果对你还有你的合作者理解以及维护代码有帮助的话， 你可以随意地加大代码的清晰性。这才是有重要性的主要的事情。  </p>

<h2 id="map">用map来对列表进行变换</h2>

<p>map操作符同grep操作符有着非常相似的语法， 它们也共享很多的相同的操作步骤。 例如， 它临时地把列表中的每个元素一个一个地取出来放到$_中去， 它的语法也同时允许”表达式”以及”块”状形式。  </p>

<p>然而原先的测试条件变成了映射表达式。map操作符会在列表上下文中对这个表达式进行估值(而不是像grep的在标量上下文)。每次对表达式进行估值，都会给出很多结果中的部分。总得结果就是每个单个结果的列表连接。在标量上下文中，map返回在列表上下文中返回的元素的个数。但是除了在列表上下文中，请尽量不要在别的语境中使用map操作符。  </p>

<p>让我们以一个简单的例子来开始：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@input_numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
</span><span class="line"><span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nb">map</span> <span class="nv">$_</span> <span class="o">+</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>对这7个元素中的每一个， map都会把它替换到$_中去， 我们会得到一个简单的输出结果：比输入数字大100的数字。 所以@result的值是101， 102， 104， 108， 116， 132还有164。 </p>

<p>但是我们没有被限制在针对每个输入值只能有一个输出值。让我们看下当每一个输入值生成两个输出值是什么情形：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span><span class="nv">$_</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nv">$_</span><span class="p">}</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在对于每个输入的 条款都有两个条款了： 1，3，2，6，4，12，8，24，16，48，32，96，64，和 192。如果我们需要一个哈希来展现哪个数是一个很小的2的阶乘的3倍的话， 我们可以使用哈希来存储那些数值对。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="nv">@result</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>或者不使用产生自map的中间数组的话：   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="nb">map</span><span class="p">{</span><span class="nv">$_</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nv">$_</span><span class="p">}</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>你可以看到， map是很灵活的。对于每个输入元素， 我们可以产生任意数目的输出元素。而且对于每个元素， 你没必要产生相同数目的输出元素。让我们看下当把每个位上的数字分开来是什么情况：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span><span class="nb">split</span> <span class="sr">//</span><span class="p">,</span> <span class="nv">$_</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>代码快的行内元素把每一个数字按位分割开来。对于1， 2， 4，还有 8， 我们得到了简单的单个的结果。对于16， 32还有64， 每个数字我们都会得到两个结果。当map连接这个最终的列表时， 我们得到了1，2，4，8，1，6，3，2，6 还有 4。   </p>

<p>如果某个特别的调用产生了一个空的列表的话， map会把那个空的列表连接到整个大的列表中去，对这个列表没有任何的贡献。我们可以使用这个特性来选择还有丢弃一些元素。例如， 假如我们只想要那些数字按位分开后是以4结尾的位：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">@digits</span> <span class="o">=</span> <span class="nb">split</span> <span class="sr">//</span><span class="p">,</span> <span class="nv">$_</span><span class="p">;</span>
</span><span class="line">	<span class="k">if</span> <span class="p">(</span><span class="nv">$digits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="nv">@digits</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">		<span class="p">();</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span> <span class="nv">@input_numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果最后一位是4， 我们通过对@digits进行估值(在列表上下文中)， 来返回分割后的位。如果最后一位不是4， 我们返回一个空的列表， 这样就把那个特别的元素产生的结果有效地清除了。所以我们可以总是使用map来代替grep， 但反之则不行。   </p>

<p>当然， 我们使用map还有grep做的任何的事情， 我们同样可以使用显式的foreach循环来做。但是， 我们照样可以用汇编来编程或者把二进制位切换到仪表板上。这里的要点是合理地使grep还有map可以帮忙减少程序的复杂性， 从而允许我们集中精力关注在高层次的问题而不是繁枝末节上。  </p>

<h2 id="eval">使用eval来捕获错误</h2>

<p>如果某些地方出错的话， 许多普通的代码都是有过早地终止一个程序的可能的。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$average</span> <span class="o">=</span> <span class="nv">$total</span> <span class="o">/</span> <span class="nv">$count</span><span class="p">;</span>     <span class="c1">#除以0？</span>
</span><span class="line"><span class="k">print</span> <span class="s">&quot;okay\n&quot;</span> <span class="k">unless</span> <span class="sr">/$match/</span><span class="p">;</span>    <span class="c1">#非法的模式？   </span>
</span><span class="line">
</span><span class="line"><span class="nb">open</span> <span class="n">MINNOW</span><span class="p">,</span> <span class="s">&#39;&gt;ship.txt&#39;</span>
</span><span class="line"><span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;Can&#39;t create &#39;ship.txt&#39;: $!&quot;</span><span class="p">;</span>   <span class="c1">#用户定义的die？</span>
</span><span class="line">
</span><span class="line"><span class="o">&amp;</span><span class="n">implement</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">foreach</span> <span class="nv">@issue_scheme</span><span class="p">;</span>    <span class="c1">#在子程序中死掉了？</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是仅仅因为我们的代码中的一部分出了问题， 不代表我们希望所有的东西都崩溃掉。Perl使用eval操作符来作为它的错误捕获机制。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">eval</span> <span class="p">{</span><span class="nv">$average</span> <span class="o">=</span> <span class="nv">$total</span> <span class="o">/</span> <span class="nv">$count</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当在运行eval块中的代码的时候， 错误出现了， 这个代码快就会结束执行。但是即使块中的代码停止了执行， Perl会继续运行eval后面的代码。最常见的是在eval后面立马检查$@的值，这个值要么是零(意味着没有错误)或者是Perl从出错的代码中得到的崩溃信息，也许是像”除以0”或者一个更长的错误信息。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">eval</span> <span class="p">{</span> <span class="nv">$average</span> <span class="o">=</span> <span class="nv">$total</span> <span class="o">/</span> <span class="nv">$count</span> <span class="p">};</span>
</span><span class="line"><span class="k">print</span> <span class="s">&quot;Counting after error: $@&quot;</span> <span class="k">if</span> <span class="vg">$@</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="nb">eval</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">rescue_scheme_42</span> <span class="p">};</span>
</span><span class="line"><span class="k">print</span> <span class="s">&quot;Continuing after error: $@&quot;</span> <span class="k">if</span> <span class="vg">$@</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>eval代码块后的分号是必须的， 因为eval是一个函数(而不是一个控制结构， 像if或者while那样)。但是这个块是真正的代码块并且可能包含词法变量(“my” 变量)还有其他的任意的声明。作为一个函数， eval像一个子程序那样是有着一个返回值的(最后一个被估值的表达式， 或者return关键字提前返回的值)。当然如果块中的代码失败了，没有值会返回。这在表两上下文中会给出undef，在列表上下文中会给出一个空的列表。因此， 另外一种计算均值的安全的方法是：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">my</span> <span class="nv">$average</span> <span class="o">=</span> <span class="nb">eval</span> <span class="p">{</span> <span class="nv">$total</span> <span class="o">/</span> <span class="nv">$count</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在$average要么是商要么是undef， 这取决于这个操作完成地成功与否。  </p>

<p>Perl甚至支持嵌套的eval代码块。只要eval在运行着， eval代码块在不或错误方面的的影响力就会延续下去， 所以eval能捕捉到嵌套的子程序调用的错误。尽管如此， eval没办法捕捉到那些最严重的错误， 就是那些Perl会停止运行的错误。 这些包括未捕获的信号， 内存溢出以及一些其他的灾难。 eval也不会捕捉语法的错误。因为Perl会把eval代码块同其余的代码一起编译， 它是在编译时而不是在运行时捕捉错误的。它也不会捕捉warnigns(警告)(尽管Perl提供了一种截取错误信息的方法，请参看$SIG{<strong>WARN</strong>}).  </p>

<h2 id="eval-1">用eval来操作动态代码</h2>

<p>还有第二种形式的eval， 它的参数是一个字符串表达式而不是一个块。它在运行时的时候编译运行来自字符串的代码。 尽管这个允许并且被支持的， 如果有不值得信任的数据进入到字符串中去的话， 会是很危险的。 除了几个很显著的例外之外， 我们建议你避免在字符串上使用eval。我们将会迟点使用它， 你可能在别人的代码中见到它， 所以我们还是在这里展示给你看它是怎么工作的把：  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="nb">eval</span> <span class="s">&#39;$sum = 2 + 2&#39;</span><span class="p">;</span>
</span><span class="line"><span class="k">print</span> <span class="s">&quot;The sum is $sum\n&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Perl会在这段代码的周围的词法上下文中去执行这些代码， 意味着这事实上如同我们就把代码直接输入在那里一样。eval的结果是最后被估值的表达式，所以其实我们并不需要eval中的整个的声明。 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="c1">#!/usr/bin/env perl     </span>
</span><span class="line">
</span><span class="line"><span class="k">foreach</span> <span class="k">my</span> <span class="nv">$operator</span> <span class="p">(</span><span class="sx">qw(+ - * /)</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nb">eval</span> <span class="s">&quot;2 $operator 2&quot;</span><span class="p">;</span>
</span><span class="line">	<span class="k">print</span> <span class="s">&quot;2 $operator 2 is $result\n&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里我们遍历了操作符 + - * /并且在我们的eval块中一个个地使用了它们。在我们传给eval的字符串中， 我们把$operator的值插入到字符串中去。 eval执行字符串所代表的代码， 然后返回最后被估值的表达式， 在前面我们把这个表达式赋值给了$result。   </p>

<p>如果eval不能正常地编译运行我们交给它的Perl代码的话， 它就会像在块形式中那样设置$@的值。在下面的例子中， 我们想要捕获除零错误， 但是我们啥值也没有除以(另一种类型的错误)。   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="k">print</span> <span class="s">&#39;The quotient is &#39;</span><span class="p">,</span> <span class="nb">eval</span> <span class="s">&#39;5 /&#39;</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
</span><span class="line"><span class="nb">warn</span> <span class="vg">$@</span> <span class="k">if</span> <span class="vg">$@</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里eval会捕获语法错误， 把错误信息放到$@中， 在调用eval之后我们就会立即检查这个变量的。  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="perl"><span class="line"><span class="n">The</span> <span class="n">quotient</span> <span class="n">is</span>
</span><span class="line"><span class="n">syntax</span> <span class="n">error</span> <span class="n">at</span> <span class="p">(</span><span class="nb">eval</span> <span class="mi">1</span><span class="p">)</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="n">at</span> <span class="n">EOF</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>后面在第10，17，还有18章中，我们会使用这个方式来选择性地加载模块。如果我们不能加载某个模块， Perl正常情况下会停止这个程序。 所以当这种情况发生的时候， 我们将会捕获到这个错误， 并且自行恢复。  </p>

<p>为了避免你没有注意到我们前面的警告，我们再说一遍: 在使用这种形式的eval的时候要非常的小心。如果能找到另外一种完成你要做的事情的方法的时候，先尝试那个方法。我们会在接来下的第10章中使用它来从外部的文件加载代码， 但是那个时候我们还会展现给你一种更好的做那件事的方法。   </p>

<h2 id="section-1">练习</h2>

<ol>
  <li>练习1[15 分钟] <br />
写一个程序来接收来自命令行的一组文件名，使用grep来选择大小按比特位来算的话小于1000的文件名。使用map来变换这个列表中的字符串， 在每个文件名前放上4个空格， 在后面放上一个换行符。打印最终的结果列表。   </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Find the Password for Pidgin]]></title>
    <link href="http://isunix.github.io/blog/2014/06/05/how-to-find-the-password-for-pidgin/"/>
    <updated>2014-06-05T20:49:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/05/how-to-find-the-password-for-pidgin</id>
    <content type="html"><![CDATA[<p>Use the following command line to find the password for your account on pidgin:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">cat <span class="nv">$HOME</span>/.purple/accounts.xml | grep pass
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>and it works. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第一章 序言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-%5B%3F%5D-zhang-xu-yan/"/>
    <updated>2014-06-02T23:53:36+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-[?]-zhang-xu-yan</id>
    <content type="html"><![CDATA[<p>欢迎来到理解Perl的下一个阶段。 你来到这里可能是因为你想学写超过100行的Perl程序，又或者是因为你的老板让你学的。  </p>

<p>看， 我们的Learning Perl一书是很了不起的， 因为它介绍了如何在短的到中等长度的程序中使用Perl（用Perl所做的绝大多数编程都是如比）。但是为了避免“美洲驼书”（Learning Perl）变得太大让人恐惧， 我们刻意地小心地省略掉了很多地内容。   </p>

<p>在接下来的内容里， 你可以得到“故事的剩下的部分”， 它是同我们的好朋友“Learning Perl”中同样的风格的。它涵盖了你写100到1000行长的程序所需要的知识。   </p>

<p>例如， 你将学习到怎样和许多程序员在同一个项目上工作。这是很棒的， 因为除非你每天工作35个小时， 你在大的项目上是需要帮助的。你同样得确保当你在你的代码上进展到最终的应用的时候， 你的代码和别人的代码是能够一致的。    </p>

<p>这本书同样向你展示了如何处理更大的更加复杂的数据结构， 比如像我们或许会称作的“哈希的哈希” 或者“array of arrays of hashes of arrays”. 一旦你知道了点references(引用)， 你就开始进入到了任意复杂的数据结构的领域了。   </p>

<p>接着就是面向对象编程这个时髦的观念了， 它允许同一个项目里， 在有着微小或者重大变动的情况下， 可以部分重用你的代码（如果运气好的话，别人的代码）。    </p>

<p>团队合作的一个很重要的一方面是有着发布周期以及单元测试还有整合测试。你将学习到基础的把你的代码打包成一个distribution(发布版本)以及为这个distribution提供单元测试。这既是为了开发， 也是为了验证你的代码在最终的环境里是行得通的。   </p>

<p>正如我们在Learning Perl中承诺以及递交的那样， 我们将会以有趣的例子和坏坏的双关语来一路娱乐你。(我们们已经将Fred, Barney, Betty, 还有wilma遣送回家了。一组新的面孔将会扮演主要的角色。)   </p>

<h2 id="section">你应该已经知道的</h2>

<p>我们将假设你读过了Learning Perl, 或者至少假装你读过了。并且你使用Perl有足够的经验了， 达到了把那些基本的东西消化吸收的程度了。比如你将不会在本书中看到解释如何去获取一个数组的元素或者从subroutine中返回一个值。   </p>

<p>请确认你知道以下的事情：   </p>

<ul>
  <li>怎样在你的系统中运行一个Perl程序。</li>
  <li>三个基本的Pelr的变量类型：标量， 数组，还有哈希。</li>
  <li>控制结构， 诸如while, if, for 以及 foreach。</li>
  <li>Subroutines(子程序)。</li>
  <li>Perl操作符， 诸如grep, map, sort, 还有 print。</li>
  <li>文件操作， 诸如open, file reading, 还有 -X(文件测试)。</li>
</ul>

<p>你可能会在本书中获取到关于这些话题的更深的见解，但是我们将假设你知道这些基础知识了。  </p>

<h2 id="section-1">关于那些脚注</h2>
<p>像在Learning Perl中一样， 这本书把一些初次阅读时会感到生僻的内容降级到脚注里去。你应该在初次阅读的时候跳过那些内容，然后在重读的时候再拾起来。你将不会在脚注中发现在接下来的章节中的内容需要的知识。  </p>

<h2 id="section-2">关于练习</h2>

<p>实际动手操作的训练会让你更好的完成这件工作。最好的提供这种培训的方式就是在半个到一个小时的内容展示之后， 提供一系列的练习题。当然如果你是个快速阅读的人的话， 你结束一章的阅读可能并不需要半个小时。 放慢速度， 深呼吸， 然后做练习。  </p>

<p>每一个练习题都有一个“多少分钟能完成”的评级。我们是想用这个评级来表示完成这个联系所需要的最长的时间， 知识如果你花的时间比所示的时间长或者短很多的话， 请不要感觉糟糕。有的时候只是你在你的学习或者工作当中遇到了多少次同样的编程任务的问题而已。   </p>

<p>每个问题在附录中都有答案。请不要偷看哦， 要不要你就毁了这些习题的价值了。   </p>

<h2 id="perl">如果我是一个Perl的授课老师怎么办？</h2>

<p>如果你是一个决定使用本书来作为你的教材的授课老师， 你应该知道每一组问题， 都是足够的短到了让一个学生在45分钟到一个小时内完成， 而且还会有点时间留下来休息。有的章节的练习题会很快的得到解决， 有的可能得花更长的时间。那是因为一旦那些在中括号中的数字被写好了， 我们发现自己已经不知道该如何往上加了。  </p>

<p>那么就让我们开始吧。在你翻开此页之后课程就开始了。。。 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 前言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan/"/>
    <updated>2014-06-02T23:06:08+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan</id>
    <content type="html"><![CDATA[<p>Perl的面向对象的机制是经典的变戏法。它接收一些Perl中存在的非面向对象特征，诸如packages, references, hashes,arrays, subroutines 以及 modules， 然后（并没有什么锦囊妙计）不知道从什么地方变出来完整的功能性的objects， classes 以及 methods。   </p>

<p>那是很大的一个技巧。这意味着你可以在不用首先掌握很多新的语法或者知晓大量的新的技巧的情况下， 在你已有的Perl知识的基础上继续发展， 轻松地进入面向对象的Perl发展进程中。这也同样意味着你可以通过选择最适合你的任务的已经存在的结构来对面向对象Perl进行微调， 以符合你自己的需要。  </p>

<p>但是这里有个问题。 由于Perl选择packages， references, hashes,arrays, subroutines 以及 modules 作为它的面向对象机制的基石， 为了使用面向对象Perl， 你得已经理解了packages，references, hashes,arrays, subroutines 以及 modules。   </p>

<p>接下来就是所谓的困难了。这里学习的曲线并没有被消除， 而只是被向后推延了几步而已。    </p>

<p>那么接下来你该如何学习一切你应该知道的关于非面向对象的知识，然后你就可以学习一切你因该知道的关于面向对象的知识呢？   </p>

<p>这本书就是答案。在接下来的每页里， Randal会利用他20多年使用Perl的经历， 以及40多年看Gilligan与Ed先生的经验来解释共同支撑着Perl的面向对象特性的每一个组成部分。 更棒的是， 他接着展示了如何联合那些组成的部分来创造有用的classes（类）以及objects（对象）。   </p>

<p>所以当涉及到Perl的objects，references, 以及 modules的时候， 你仍然感觉像是Gilligan， 那么这本书就是Professor要求的。  </p>

<p>以上都是真实的消息哦！   </p>

<p>–Damian Conway, 2003年5月。                                                             </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brew Update Errors Fixed]]></title>
    <link href="http://isunix.github.io/blog/2014/06/01/brew-update-errors-fixed/"/>
    <updated>2014-06-01T16:12:00+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/01/brew-update-errors-fixed</id>
    <content type="html"><![CDATA[<p>I met several errors while updating my homebrew, one is:  </p>

<p><img src="http://isunix.github.io/images/sun/first.png" />    </p>

<p>the solution is:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd `brew --prefix`    
</span><span class="line">git remote add origin https://github.com/mxcl/homebrew.git   
</span><span class="line">git fetch origin    
</span><span class="line">git reset --hard origin/master 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>the other is:   </p>

<p><img src="http://isunix.github.io/images/sun/second.png" />    </p>

<p>To address this this error, we just have have to change the permissions on the folder to a certain user:  </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">chown -R sun .git  </span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the Error Using Rake New_post Under Zsh]]></title>
    <link href="http://isunix.github.io/blog/2014/05/31/on-the-error-using-rake-new-post-under-zsh/"/>
    <updated>2014-05-31T17:48:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/31/on-the-error-using-rake-new-post-under-zsh</id>
    <content type="html"><![CDATA[<p>When I issue the command “rake new_post[]” using the zsh, I got the error telling me that “no matches found”. I googled, it said if using “noglob rake” rather than simply “rake”, this problem will be solved. But in my case, it does not work. </p>

<p>My expedient solution here is, issuing the followng command:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake "new_post[on the error using rake new_post under zsh]"</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rather than in the normal way:   </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake new_post["on the error using rake new_post under zsh"]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It works in my case, but it is not a nice solution for sure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Story With Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/05/31/my-story-with-perl/"/>
    <updated>2014-05-31T17:22:45+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/31/my-story-with-perl</id>
    <content type="html"><![CDATA[<p>When I was In college, I am not interested in programming language at all. At that time, I devoted almost all of my time to English study and math thinking. I thought learning computer science was silly, because if you know how to do something(or compute something) in your own language, why do you bother to do it in computer’s language?   </p>

<p>With this thought in my mind, you can guess I did not study computer science very well, although I have to take many courses in CS. I did not fail any one of the courses I took but also not proficient in any of them.  </p>

<p>When I was about to graduate from college, I had to find a job. I was interested in foreign trade then and hoped I could use my English skill and further my interest in economics and business. I did get jobs in this area but when a job oppotunity concerning database with the job title ‘database production analyst’ got landed by me, I gave up my dream of becoming a business man and became a database production analyst, because the latter one offers a more huge salary and better working environment, and that was in year 2011 then, before July.   </p>

<p>I spent the first year of working career not knowing what to do. I was not interested in SQL programming at all, and my job then did not require too much programming skill on SQL. My team leader then is one who is very proficent in SQL Server and T-SQL programming, maybe because of him, I did not further my pursue in SQL programming.    </p>

<p>But I had to learn something then, I thought command line tools very cool, so I spent a lot of time reading other people’s code in the production environment. In order to learn how a web site is built and how to use PHP and javascript, I also joined a team in the company whose aim was to develop an internal management system, my role there was testing, but I did not think I have ever offered any help to the team and the project. Later on when the internal management system was almost finished, my name was also mentioned in the to be appreciated list. I feel quite ashamed.  </p>

<p>So based on the above， you can see I did not get a lot in my first year regarding programming language, but I did begin to make my own choice of what I wanted to learn.</p>

<p>As to my encounter with Perl, I knew the language of Perl in late 2011. I used to spend a lot of time on it when I was in the first company I joined, since that company uses a lot of Perl to do system administratiion. The problem is I have not used perl to write any useful scripts, although I have crafted some small snipptes.   </p>

<p>I always think Perl is not a beautiful language. I know something about Python also, and think Python is more readable than Perl. I have bought and read several books on Python, I have studied some of Python’s advanced usages. I have delved into Django, Flask and Tornado, the three very famous Python web framework. </p>

<p>Also, I have spent quite a while to learn Ruby and Rails. I used to think maybe I should find a job in using ruby because I have read a book on ruby written by its maker Mats then. I found ruby to be very easy and interesting then. I spent several weeks learning ruby and another several week on Rails to learn how to build a web site.  </p>

<p>And currently I am using PHP to write some internal tools for my team. I have to confess I have spent many hours on how to build the environment for PHP and Apache. I read books and watched videos on PHP. PHP is the second language I used besides bash that got deployed to production environment. As to PHP, I want to thank this language because it is easy to use and guided me to the programming world. I get to know a lot of programming concepts through using PHP. Most of the codes I wrote was in PHP.  </p>

<p>When I wanted to join the currnet company, I applied for the job position of becoming a Perl developer. I read the job description and I thought then that I can take this job. But after interviewing with my manager, he thought I was a rookie and I surely was a rookie. So I did not landed the job of becoming a Perl developer but became an analyst again, also reporting to the same manager who interviewed me on Perl developer.</p>

<p>For all these accountings, I have no idea why deep down in my heart I want to write something useful in Perl. Maybe because it is hard, maybe because I believe yes I can. </p>

<p>I want to use this opportunity to further my understanding of Perl. I choose the book “Intermediate Perl” here, and want to translate it into Chinese and expand some of the topics diccussed in that book and write something about them in this blog. I choose this book, because it is the first book on Perl that I bought. I did not buy learning Perl first because I thought I can grasp the basic of Perl just by reading the ebook and there is no need to buy the elementary one. The fact is I bought “learning Perl” several months later. I read “Intermediate Perl” several times, but I can not claim that I can understand it all, actually if I grasp the contents in that book, now it will not be necessary for me to write this post any more. </p>

<p>It is very nice to meet someone who is very proficient in Perl. But what is to be noted is, you can learn from someone, but do not count on someone to help teach you, they do not have the obligations to do that. </p>

<p>That is it, let us embark on a new journey!  </p>
]]></content>
  </entry>
  
</feed>
