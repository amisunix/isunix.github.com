<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-18T14:44:54+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Interesting Use of State in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/interesting-use-of-state-in-perl/"/>
    <updated>2014-07-17T18:48:44+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/interesting-use-of-state-in-perl</id>
    <content type="html"><![CDATA[<p>还是来自«learning perl»中的例子。</p>

<ol>
  <li>写一个名为greet的子例程，当给定一个人名作为参数的时候，打出欢迎他的信息，并告诉他前一个来宾的名字。  </li>
</ol>

<p>```perl</p>

<p>use 5.010;
greet(‘Fred’);
greet(‘Barney’);</p>

<p>sub greet{
    state $last_person;</p>

<pre><code>my $name = shift;

print "Hi, $name!";

if (defined $last_person) {
    print "$last_person is also here!\n";
}

else {
    print "you are the first one here!\n";
}

$last_person = $name; } 
</code></pre>

<p>```<br />
2.修改程序1， 告诉所有新来的人之前已经迎来了哪些人.   </p>

<p>```perl 
use Data::Dumper;
use 5.010;</p>

<p>greet(‘Fred’);
greet(‘Barney’);
greet(‘Wilma’);
greet(‘Betty’);</p>

<p>sub greet{
    state @before;</p>

<pre><code>my $name = shift;
print "Hi, $name!";

if (@before){
    print " I have seen @before\n";
}
else {
    print " you are the first one here!\n";
}

push @before, $name; }
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About the Use of State in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/about-the-use-of-state-in-perl/"/>
    <updated>2014-07-17T16:02:20+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/about-the-use-of-state-in-perl</id>
    <content type="html"><![CDATA[<p>算了还是引用一下«learning perl»中文翻译版本中的话吧:   </p>

<p>```
在Perl中可以使用my操作符来创建私有变量， 但是每次调用这个子程序的时候，这个私有变量都会被重新定义。而使用state操作符来声明的变量，我们便可以在子程序的多次调用期间保留变量之前的值， 并将变量的作用域限于子程序内部</p>

<p>```</p>

<p>让我们来看下使用my还有使用state所产生的不同的效果吧。  </p>

<p>首先是my:  </p>

<p>```perl</p>

<p>use 5.010;</p>

<p>running_sum( 5, 6 );
running_sum( 1..3 );
running_sum( 4 );</p>

<p>sub running_sum {
    my $sum = 0;
    my @numbers;</p>

<pre><code>foreach my $number ( @_ ) {
  push @numbers, $number;
  $sum += $number;
}

say "the sum of (@numbers) is $sum"; }  
</code></pre>

<p>```  </p>

<p>这段code产生的结果是:  </p>

<p>```perl</p>

<p>the sum of (5 6) is 11
the sum of (1 2 3) is 6
the sum of (4) is 4</p>

<p>```   </p>

<p>下面是state:  </p>

<p>```perl</p>

<p>use 5.010;
running_sum( 5, 6 );
running_sum( 1..3 );
running_sum( 4 );</p>

<p>sub running_sum {
    state $sum = 0;
    state @numbers;
    foreach my $number ( @_ ) {
        push @numbers, $number;
        $sum += $number;
    }</p>

<p>say “The sum of (@numbers) is $sum”;
}</p>

<p>```<br />
它的结果是:   </p>

<p>```perl  </p>

<p>The sum of (5 6) is 11
The sum of (5 6 1 2 3) is 17
The sum of (5 6 1 2 3 4) is 21</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl中单行或者多行输出结果]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/perlzhong-dan-xing-huo-zhe-duo-xing-shu-chu-jie-guo/"/>
    <updated>2014-07-17T15:14:23+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/perlzhong-dan-xing-huo-zhe-duo-xing-shu-chu-jie-guo</id>
    <content type="html"><![CDATA[<p>我们在标准输入中得到多行的值， 现在我们想要以单行还有多行的结果来把它们给显示出来， 要是想单行显示的话，可以如下:</p>

<p>```perl</p>

<p>chomp(@lines = <stdin>);
@sorted = sort @lines;
print "@sorted\n"</stdin></p>

<p>```</p>

<p>多行的话可以:  </p>

<p>```perl </p>

<p>print sort <stdin>;</stdin></p>

<p>```  </p>

<p>这里的关键的地方就是chomp这个函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Chapters at Once]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/generate-chapters-at-once/"/>
    <updated>2014-07-17T10:47:48+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/generate-chapters-at-once</id>
    <content type="html"><![CDATA[<p>I use this script to generate chapters at once. The number of chapters you want to generate in passed through the command line as the first argument.  </p>

<p>```perl </p>

<p>use strict;
use warnings;
use utf8;
use Data::Dumper;</p>

<p>my $chap_num = $ARGV[0];</p>

<p>for(my $i = 1; $i &lt;= $chap_num; $i++){
    mkdir “chap_$i”;
}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sort in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/06/22/sort-in-perl/"/>
    <updated>2014-06-22T12:31:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/22/sort-in-perl</id>
    <content type="html"><![CDATA[<p>In Perl, function sort() sort the item of an array according to its corresponding acssci code. for example, if we have an array @array = (1, 3, 10, 2, 21) and use sort against this array, we will get the following result: 1 10 2 21 3. However if we want to sort these numbers according to its value, we can use the following method:   </p>

<p>```perl</p>

<p>sort{$a &lt;=&gt; $b} @array;   #ascending</p>

<p>sort{$b &lt;=&gt; $a} @array;   #descending</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
