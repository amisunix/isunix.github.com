<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-09-12T18:25:05+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[About Not Using MIME::Lite]]></title>
    <link href="http://isunix.github.io/blog/2014/09/12/about-not-using-mime-lite/"/>
    <updated>2014-09-12T14:40:15+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/12/about-not-using-mime-lite</id>
    <content type="html"><![CDATA[<p>when you use “perldoc MIME::Lite”, you will see the folliwng info:  </p>

<p><code>
MIME::Lite is not recommended by its current maintainer.  There are a number of alternatives, like Email::MIME or MIME::Entity and Email::Sender, which you should probably use instead.  MIME::Lite continues to accrue weird bug reports, and it is not receiving a large amount of refactoring due to the availability of better alternatives. Please consider using something else.
</code></p>

<p>Thus I decided not use MIME::Lite any more. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Constructor and Destructor in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/09/11/constructor-and-destructor-in-perl/"/>
    <updated>2014-09-11T13:46:23+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/11/constructor-and-destructor-in-perl</id>
    <content type="html"><![CDATA[<p>For Perl constructor, we can seperate the process of object creation from the process of initialization.  </p>

<p><code>pl
package CD::Music;
use strict;
sub new {
	my $self = {};
	bless $self, shift;
	$self-&gt;_incr_count();
	$self-&gt;_init(@_);
	return $self;
}
{
	my @_init_mems =
	qw( _name _artist _publisher _ISBN _tracks _room _shelf _rating );
	sub _init {
		my ($self,@args) = @_;
		my %inits;
		@inits{@_init_mems} = @args;
		%$self = %inits;
	}
}
</code>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Calling in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/09/10/method-calling-in-perl/"/>
    <updated>2014-09-10T22:02:49+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/10/method-calling-in-perl</id>
    <content type="html"><![CDATA[<p>Please refer to the folliwng to see the detailed info on method calling in perl:  </p>

<p><code>html
http://www.cnblogs.com/sun1030/p/3965246.html
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Named Arguments]]></title>
    <link href="http://isunix.github.io/blog/2014/09/10/named-arguments/"/>
    <updated>2014-09-10T15:58:10+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/10/named-arguments</id>
    <content type="html"><![CDATA[<p>For named argument, it many uses the trick of changing a list into a hash. Take a look at the following code.  </p>

<p>```pl
listdir(cols=&gt;4, page=&gt;1, hidden=&gt;1, sep_dirs=&gt;1);    </p>

<p>sub listdir {
	%arg = @_;# Convert argument list to hash</p>

<pre><code>$arg{match} = "*" unless exists $arg{match}; 
$arg{cols} = 1unless exists $arg{cols}; # etc. # Use arguments to control behaviour...
@files = get_files( $arg{match} );
push @files, get_hidden_files() if $arg{hidden}; # etc. } ```   
</code></pre>

<p>Apart from documenting the call better, this approach has another important advantage. Since the entries of a hash can be initialized in any convenient order, we no longer need to re- member the order of the nine potential arguments, as long as we remember their names. In addition, because hashes are flattened inside lists, if we have several calls that require the same subset of arguments, we can store that subset in a separate hash and reuse it:    </p>

<p>```pl
%std_listing = (cols=&gt;2, page=&gt;1, sort_by=&gt;”date”);   </p>

<p>listdir(file=&gt;”*.txt”, %std_listing);     </p>

<p>listdir(file=&gt;”*.log”, %std_listing);      </p>

<p>listdir(file=&gt;”*.dat”, %std_listing);
```    </p>

<p>We can even override specific elements of the standard set of arguments, by placing an explicit version after the standard set. Then the explicit version will reinitialize (i.e., overwrite) the corresponding entry in the hash:      </p>

<p><code>pl
listdir(file=&gt;"*.exe", %std_listing, sort_by=&gt;"size");
</code>    </p>

<p>This idea of a standard argument set, overridden by explicitly specified arguments, can also be used within the subroutine to simplify the handling of default values. For example:   </p>

<p><code>pl
sub listdir {
	%defaults = (match=&gt;"*", cols=&gt;1, sort_by=&gt;"name"); %arg = (%defaults, @_);
	# Use arguments to control behaviour...	
	# etc.
}
</code> <br />
In this version, the default values are stored in the %defaults hash, and are then flat- tened into the list used to initialize the %arg hash. The default values appear first in the ini- tializer list. Any entry of the same name passed in via @_ will therefore overwrite the corresponding entry in %arg, replacing the default value with the user-specified one. As a final optimization, the default hash could be moved outside listdir, so that it need only be ini- tialized once, before the program runs, rather than each time listdir is called:    </p>

<p><code>pl
%defaults = (match=&gt;"*", cols=&gt;1, sort_by=&gt;"name");
sub listdir {
	%arg = (%defaults, @_);
	# etc.
}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Polymorphism in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/09/10/polymorphism-in-perl/"/>
    <updated>2014-09-10T14:37:37+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/10/polymorphism-in-perl</id>
    <content type="html"><![CDATA[<p>This is mainly a note from the book “object oriented perl programming” by Damian Conway.</p>

<p>When a method is called on a particular object, the actual method that’s involved may depend on the class to which the object belongs. For instance, if we call an object’s ignite() method, its response will be different depending on whether it belongs to the Paper, Rocket, Passion, or FlameWar class.    </p>

<p>1.inheritance polymorphism:</p>

<p>the objects whose methods are called belong to a hierarchy of classes that are related by inheritance. The presence of the required method in the base class of the hierarchy ensures that objects of any derived class can always respond, if only generically, to a given method call. The ability to re- define individual methods in derived classes allows objects of those classes to respond more spe- cifically to a particular method call if they so wish.    </p>

<p>2.interface polymorphism:  </p>

<p>The alternative approach to polymorphism is to allow any object with a suitable method to respond to a call to that method. This is known as interface polymorphism, because the only requirement is that a particular object’s interface provides a method of the appropriate name. Consequently, languages that allow interface polymorphism must also provide a run-time mechanism for handling cases where an object is unable to provide a requested method. Typ- ically, this involves providing a means of specifying a fallback subroutine that is called when- ever an object cannot respond to a particular method invocation. Alternatively, such languages may have some form of exception system. In that case, the language will trigger a well-defined exception if the object cannot respond more appropriately.Inheritance polymorphism is a special case of interface polymorphism because a common base class guarantees that objects share a specific inherited method. Any language that supports interface polymorphism automatically supports inheritance polymorphism as well.</p>

<p>3.abstract class:   </p>

<p>A class hierarchy will contain some classes—typically near the top of the hierarchy—that were never intended to be used to build objects directly. In other words, these classes exist only to represent a shared category or provide a single source from which descendent classes can inherit shared methods. Such classes are called abstract base classes. There is one additional role that an abstract base class can fulfill. Any base class, abstract or not, can be used to ensure that every class derived from it has a specific polymorphic method. That’s a handy feature because we are then guaranteed that any derived class will be able to respond polymorphically to a specified set of method calls.    </p>

<p>Abstract base classes are clearly useful, but in large object-oriented systems two problems can arise. The first is that they may accidentally be used as real classes when someone mistakenly creates an object of their type.   </p>

<p>Although an abstract base class ensures that a derived class has a certain set of methods, it does not require that the derived class redefine any of those methods meaningfully. This can be a problem if many such polymorphic methods are inher- ited, and we accidentally forget to redefine one of them. The result is that a particular class uses the generic behavior for a polymorphic function, instead of its own appropriate class-specific behavior.  </p>

<p>Many object-oriented programming languages solve these two problems by introducing the concept of an abstract method (which is also known as a pure virtual function, or a deferred feature). An abstract method is a method in an abstract base class that has no valid implementation and exists only to indicate a necessary part of each derived class’s interface. It is a kind of placeholder in the interface, indicating the need for a certain functionality, but not actually providing it.     </p>

<p>Suppose, for example, the register() method of the Truck class had been declared as an abstract method (i.e., defined but not implemented). Now, because that ancestral regis- ter() method doesn’t provide a working implementation, whenever a Truck object is creat- ed, and its register() method is called, an error will be flagged. This immediately solves the general problem of incorrect use of objects belonging to an abstract base class.  </p>

<p>Better still, it also solves the problem of forgetting to redefine a method in a derived class. For example, if the person coding the FireTruck class neglects to implement a suitable reg- istration method for that class, then the register() method inherited from Truck will be called instead. Rather than performing some inadequate default registration process, the in- herited abstract method will immediately signal an error, indicating that the implementation is incorrect.</p>

<p>4.Objects can live beyond the program that creates them.   </p>

<p>5.Object-oriented programming languages provide an important separa- tion between how data is used externally—the methods that can be called on an object—and how that data is represented and manipulated internally—the way its attribute values are stored, and its methods are coded. So long as the interface remains stable, the implementation can be changed as necessary—optimized, extended, parallelized, distributed, and so forth.   </p>

<p>6.In object-oriented terms, persistence is the ability of objects to retain their attribute values, their association with a class, and their individual identity, between separate executions of a program. In other words, persistent objects are those that, next time you start running the program, are still there.   </p>

<p>Persistence requires more than just dumping an object’s attribute values into a file or a database when the program terminates, and then creating a new object, and reloading the saved data next time the program executes. The essence of persistence is that when the program next executes, a persistent object will have been identifiably reconstructed, either with the same name, the same location in memory, or another way of accessing it that is consistent between executions.    </p>

<p>Moreover, the reconstruction ought to be as fully automated as possible. Ideally, the pro- grammer should only have to somehow mark an object as persistent, and thereafter it will au- tomagically reappear every time the program executes. In practice, very few languages can achieve that level of transparency.    </p>

<p>More often, to create a persistent object it is necessary to create a special-purpose class, perhaps by deriving it from the object’s original class. This, in turn, requires the programmer to create some custom code to translate internal representations of the object—the bit patterns representing it in the program—to external representations—the bit patterns in a file or database.   </p>

<p>This translation process is called encoding or serialization and is difficult to implement in the general case. It’s particularly hard if some attributes of a persistent object store pointers or references to other data. In such cases, it may also be necessary to also encode the data being referred to, as well as the abstract relationship between the persistent objects involved. In an inherently persistent language, this requirement must be met for an arbitrary number of at- tributes storing arbitrary interrelationships between arbitrary objects of arbitrary classes. Not surprisingly, few languages fully support both object orientation and automatic persistence.     </p>

<p>Another important issue is the granularity of the persistence conferred upon objects. Some languages, such as HyperTalk, offer fine-grained persistence, in which every change in the attributes of an object is immediately recorded externally. Most, however, offer only coarse- grained persistence, where the attributes of an object are recorded only at the very end of a pro- gram’s execution.   </p>

<p>Coarse-grained persistence is almost always a more efficient alternative since it minimizes the amount of disk access a program performs. Fine-grained persistence, on the other hand, is clearly the safer alternative since it ensures that an object’s state can always be reconstructed in a subsequent execution of the program, even if a previous execution terminated prematurely.    </p>

<p>Of course, in practice, not even the finest of fine-grained persistence offers any real guar- antee of data integrity. Even if an object is updated every time it is modified, the program might still crash in the middle of the update process itself, or, in crashing at some other point, it might somehow trash the file system on which the object was recorded. However, these prob- lems also apply to coarse-grained persistence, which is far more likely to lose data due to an inopportune termination since, in general, nothing at all will have been recorded prior to the crash.   </p>

<p>6.In the literature on object-oriented programming, standard concepts pass by many strange aliases. It some- times seems that every object-oriented language designer deliberately invents a completely new set of names for the same fundamental ideas.</p>

<p>(I strong agree with Dimian Conway, many concepts are so clear to clear to understand, yet people invent new new aliases to mask the concept thus makes other people hard to digest the essence under those concepts–by Steven)   </p>
]]></content>
  </entry>
  
</feed>
