<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-06-06T20:51:41+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第二章 中级基础]]></title>
    <link href="http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu/"/>
    <updated>2014-06-06T17:07:24+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/06/intermediate-perl-di-er-zhang-zhong-ji-ji-chu</id>
    <content type="html"><![CDATA[<p>在我们开始这本书的实质内容之前， 我们想介绍些在本书中使用的中级水平的Perl习语。通常就是这些东西把初级的还有中级水平的Perl程序员区别开的。 在这个过程中， 我们还会把你介绍给将在本书中的例子中使用的一组角色。   </p>

<h2 id="section">列表操作符</h2>

<p>你已经知道了一些Perl中的列表操作符， 但是你可能没有把它们想成是同列表相联系的。最常见的列表操作符可能是print。 我们给它一个或者更多的参数， 它会为我们把这些参数组织到一起。  </p>

<p><code>
print 'Two castaways are ', 'Gilligan', ' and ', 'Skipper', "\n";
</code>   </p>

<p>还有其他一些你已经在Learning Perl一书中理解到了的列表操作符。sort操作符把输入的列表排序。在这些被流放的人他们所表演的主题曲中，他们没有按照字母顺序出场， 但是sort可以帮我们解决这个问题。  </p>

<p><code>
my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann);
</code>  </p>

<p>而reverse操作符可以返回一个反序的列表：  </p>

<p><code>
my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann);
</code>  </p>

<p>Perl中还有很多其他的同列表用在一起的操作符， 一旦你习惯了它们，你将会发现自己字敲得更少了， 表达自己的意图更加地清晰了。   </p>

<h2 id="grep">用grep来进行列表过滤</h2>

<p>grep操作符接收一个列表还有一个“测试条件”。 然后它把别表中的值一个接着一个地拿出来，放到$_这个变量里。 接来下grep会在标量上下文中估值这个测试条件。如果这个表达式估值成一个true的值， grep就会把$_传递给输出列表。   </p>

<p><code>
my @lunch_choices = grep &amp;is_edible($_), @gilligans_profession.
</code>
在列表上下文中， grep操作符会返回所有选出来的条款。而在标量环境中， grep会返回选出来的条款的数量。   </p>

<p><code>
my @results = grep EXPR, @input_list;
my $count = grep EXPR, @input_list;
</code> <br />
这里EXPR表示的是任意的适用于$_的标量表达式(明确地或者隐含着的)。例如， 为了找到所有大于10的数， 在我们的grep表达式中， 我们检查看$_是否大于10.   </p>

<p><code>
my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @bigger_than_10 = grep $_ &gt; 10, @input_numbers;
</code> <br />
结果返回的是16， 32， 64. 这里显形地对$_进行了使用。 接下来是一个隐形的使用$_的例子， 它来自于模式匹配操作符。  </p>

<p><code>
my @end_in_4 =  grep /4$/, @input_numbers;
</code>  <br />
现在我们将会只得到4和64。   </p>

<p>当grep在运行的时候， 它会暂时地把$_中存在的值先遮住， 也就是说grep会借用这个变量， 但是在结束后会把原来的值给放回去。变量$_不是数据条款的一个简单复制， 它是数据条款的一个别名， 同foreach循环中的控制变量很相似。   </p>

<p>如果测试条件很复杂， 我们可以把它藏在一个子程序中：   </p>

<p>```
my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers;</p>

<p>sub digit_sum_is_odd {
	my $input = shift;
	my @digits = split //, $input; #假设没有非数字字符;
	my $sum;
	$sum += $_ for @digits;
	return $sun % 2;
}
```
现在我们会得到一个含有1， 16， 32的列表。这些数字按位求和在子程序的最后一行会得到余数1， 这被认为是是1。  </p>

<p>这种语法是有两种形式的， 我们只是展示给你看了”表达式”的形式， 接下来的是”块”(block)形式。 与其定义一个我们只会在单个测试中使用的显式的子程序，我们不如使用块形式， 把子程序直接放到grep操作符的后面去:   </p>

<p>```
my @results = grep {
	block;
	of;
	code;
} @input_list;</p>

<p>my $count = grep {
	block;
	of;
	code;
} @input_list;</p>

<p>```  </p>

<p>就如同”表达式”的形式一样， grep会临时地把输入的列表中的每个元素都放到$_里。接下来它会对正个的代码块进行估值。在代码快中最后一个被估值的表达式是测试表达式。(同所有的测试表达式一样， 它是在标量上下文中被估值的)由于这是一个完整的代码块， 我们可以引进被限制在代码块中的变量。 让我们使用块状形式来重写上一个例子。   </p>

<p>```
my @odd_digit_sum = grep {
	my $input = $_ ;
	my @digit = split //, $input;     ##假设没有非数值的字符
	my $sum;
	$sum += $_ for @digits;
	$sum % 2;
} @input_numbers;</p>

<p>```   </p>

<p>注意这里的两个变化：输入值是通过$_而不是参数列表传进来的， 以及我们去掉了关键字return。事实上如果我们保留’return‘的话是错误的， 因为我们已经不在一个子程序中了：只是在一个程序块中。当然， 我们可以把那个子程序优化， 因为我们不需要这些中间变量：   </p>

<p>```
my @odd_digit_sum = grep {
	my $sum;
	$sum += $_ for split //;
	$sum % 2;
} @input_mumbers;</p>

<p>```</p>

<p>如果对你还有你的合作者理解以及维护代码有帮助的话， 你可以随意地加大代码的清晰性。这才是有重要性的主要的事情。  </p>

<h2 id="map">用map来对列表进行变换</h2>

<p>map操作符同grep操作符有着非常相似的语法， 它们也共享很多的相同的操作步骤。 例如， 它临时地把列表中的每个元素一个一个地取出来放到$_中去， 它的语法也同时允许”表达式”以及”块”状形式。  </p>

<p>然而原先的测试条件变成了映射表达式。map操作符会在列表上下文中对这个表达式进行估值(而不是像grep的在标量上下文)。每次对表达式进行估值，都会给出很多结果中的部分。总得结果就是每个单个结果的列表连接。在标量上下文中，map返回在列表上下文中返回的元素的个数。但是除了在列表上下文中，请尽量不要在别的语境中使用map操作符。  </p>

<p>让我们以一个简单的例子来开始：  </p>

<p><code>
my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @result = map $_ + 100, @input_numbers;
</code><br />
对这7个元素中的每一个， map都会把它替换到$_中去， 我们会得到一个简单的输出结果：比输入数字大100的数字。 所以@result的值是101， 102， 104， 108， 116， 132还有164。 </p>

<p>但是我们没有被限制在针对每个输入值只能有一个输出值。让我们看下当每一个输入值生成两个输出值是什么情形：  </p>

<p><code>
my @result = map {$_, 3 * $_} @input_numbers;
</code>  <br />
现在对于每个输入的 条款都有两个条款了： 1，3，2，6，4，12，8，24，16，48，32，96，64，和 192。如果我们需要一个哈希来展现哪个数是一个很小的2的阶乘的3倍的话， 我们可以使用哈希来存储那些数值对。  </p>

<p><code>
my %hash = @result;
</code> <br />
或者不使用产生自map的中间数组的话：   </p>

<p><code>
my %hash = map{$_, 3 * $_} @input_numbers;
</code> <br />
你可以看到， map是很灵活的。对于每个输入元素， 我们可以产生任意数目的输出元素。而且对于每个元素， 你没必要产生相同数目的输出元素。让我们看下当把每个位上的数字分开来是什么情况：  </p>

<p><code>
my @result = map {split //, $_};
</code>
代码快的行内元素把每一个数字按位分割开来。对于1， 2， 4，还有 8， 我们得到了简单的单个的结果。对于16， 32还有64， 每个数字我们都会得到两个结果。当map连接这个最终的列表时， 我们得到了1，2，4，8，1，6，3，2，6 还有 4。   </p>

<p>如果某个特别的调用产生了一个空的列表的话， map会把那个空的列表连接到整个大的列表中去，对这个列表没有任何的贡献。我们可以使用这个特性来选择还有丢弃一些元素。例如， 假如我们只想要那些数字按位分开后是以4结尾的位：  </p>

<p><code>
my @result = map {
	my @digits = split //, $_;
	if ($digits[-1] == 4) {
		@digits;
	} else {
		();
	}
} @input_numbers;
</code> <br />
如果最后一位是4， 我们通过对@digits进行估值(在列表上下文中)， 来返回分割后的位。如果最后一位不是4， 我们返回一个空的列表， 这样就把那个特别的元素产生的结果有效地清除了。所以我们可以总是使用map来代替grep， 但反之则不行。   </p>

<p>当然， 我们使用map还有grep做的任何的事情， 我们同样可以使用显式的foreach循环来做。但是， 我们照样可以用汇编来编程或者把二进制位切换到仪表板上。这里的要点是合理地使grep还有map可以帮忙减少程序的复杂性， 从而允许我们集中精力关注在高层次的问题而不是繁枝末节上。  </p>

<h2 id="eval">使用eval来捕获错误</h2>

<p>如果某些地方出错的话， 许多普通的代码都是有过早地终止一个程序的可能的。  </p>

<p>```
my $average = $total / $count;     #除以0？
print “okay\n” unless /$match/;    #非法的模式？   </p>

<p>open MINNOW, ‘&gt;ship.txt’
or die “Can’t create ‘ship.txt’: $!”;   #用户定义的die？</p>

<p>&amp;implement($_) foreach @issue_scheme;    #在子程序中死掉了？</p>

<p>```</p>

<p>但是仅仅因为我们的代码中的一部分出了问题， 不代表我们希望所有的东西都崩溃掉。Perl使用eval操作符来作为它的错误捕获机制。   </p>

<p><code>
eval {$average = $total / $count};
</code><br />
当在运行eval块中的代码的时候， 错误出现了， 这个代码快就会结束执行。但是即使块中的代码停止了执行， Perl会继续运行eval后面的代码。最常见的是在eval后面立马检查$@的值，这个值要么是零(意味着没有错误)或者是Perl从出错的代码中得到的崩溃信息，也许是像”除以0”或者一个更长的错误信息。  </p>

<p>```
eval { $average = $total / $count };
print “Counting after error: $@” if $@;    </p>

<p>eval { &amp;rescue_scheme_42 };
print “Continuing after error: $@” if $@;</p>

<p>```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第一章 序言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-%5B%3F%5D-zhang-xu-yan/"/>
    <updated>2014-06-02T23:53:36+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-di-[?]-zhang-xu-yan</id>
    <content type="html"><![CDATA[<p>欢迎来到理解Perl的下一个阶段。 你来到这里可能是因为你想学写超过100行的Perl程序，又或者是因为你的老板让你学的。  </p>

<p>看， 我们的Learning Perl一书是很了不起的， 因为它介绍了如何在短的到中等长度的程序中使用Perl（用Perl所做的绝大多数编程都是如比）。但是为了避免“美洲驼书”（Learning Perl）变得太大让人恐惧， 我们刻意地小心地省略掉了很多地内容。   </p>

<p>在接下来的内容里， 你可以得到“故事的剩下的部分”， 它是同我们的好朋友“Learning Perl”中同样的风格的。它涵盖了你写100到1000行长的程序所需要的知识。   </p>

<p>例如， 你将学习到怎样和许多程序员在同一个项目上工作。这是很棒的， 因为除非你每天工作35个小时， 你在大的项目上是需要帮助的。你同样得确保当你在你的代码上进展到最终的应用的时候， 你的代码和别人的代码是能够一致的。    </p>

<p>这本书同样向你展示了如何处理更大的更加复杂的数据结构， 比如像我们或许会称作的“哈希的哈希” 或者“array of arrays of hashes of arrays”. 一旦你知道了点references(引用)， 你就开始进入到了任意复杂的数据结构的领域了。   </p>

<p>接着就是面向对象编程这个时髦的观念了， 它允许同一个项目里， 在有着微小或者重大变动的情况下， 可以部分重用你的代码（如果运气好的话，别人的代码）。    </p>

<p>团队合作的一个很重要的一方面是有着发布周期以及单元测试还有整合测试。你将学习到基础的把你的代码打包成一个distribution(发布版本)以及为这个distribution提供单元测试。这既是为了开发， 也是为了验证你的代码在最终的环境里是行得通的。   </p>

<p>正如我们在Learning Perl中承诺以及递交的那样， 我们将会以有趣的例子和坏坏的双关语来一路娱乐你。(我们们已经将Fred, Barney, Betty, 还有wilma遣送回家了。一组新的面孔将会扮演主要的角色。)   </p>

<h2 id="section">你应该已经知道的</h2>

<p>我们将假设你读过了Learning Perl, 或者至少假装你读过了。并且你使用Perl有足够的经验了， 达到了把那些基本的东西消化吸收的程度了。比如你将不会在本书中看到解释如何去获取一个数组的元素或者从subroutine中返回一个值。   </p>

<p>请确认你知道以下的事情：   </p>

<ul>
  <li>怎样在你的系统中运行一个Perl程序。</li>
  <li>三个基本的Pelr的变量类型：标量， 数组，还有哈希。</li>
  <li>控制结构， 诸如while, if, for 以及 foreach。</li>
  <li>Subroutines(子程序)。</li>
  <li>Perl操作符， 诸如grep, map, sort, 还有 print。</li>
  <li>文件操作， 诸如open, file reading, 还有 -X(文件测试)。</li>
</ul>

<p>你可能会在本书中获取到关于这些话题的更深的见解，但是我们将假设你知道这些基础知识了。  </p>

<h2 id="section-1">关于那些脚注</h2>
<p>像在Learning Perl中一样， 这本书把一些初次阅读时会感到生僻的内容降级到脚注里去。你应该在初次阅读的时候跳过那些内容，然后在重读的时候再拾起来。你将不会在脚注中发现在接下来的章节中的内容需要的知识。  </p>

<h2 id="section-2">关于练习</h2>

<p>实际动手操作的训练会让你更好的完成这件工作。最好的提供这种培训的方式就是在半个到一个小时的内容展示之后， 提供一系列的练习题。当然如果你是个快速阅读的人的话， 你结束一章的阅读可能并不需要半个小时。 放慢速度， 深呼吸， 然后做练习。  </p>

<p>每一个练习题都有一个“多少分钟能完成”的评级。我们是想用这个评级来表示完成这个联系所需要的最长的时间， 知识如果你花的时间比所示的时间长或者短很多的话， 请不要感觉糟糕。有的时候只是你在你的学习或者工作当中遇到了多少次同样的编程任务的问题而已。   </p>

<p>每个问题在附录中都有答案。请不要偷看哦， 要不要你就毁了这些习题的价值了。   </p>

<h2 id="perl">如果我是一个Perl的授课老师怎么办？</h2>

<p>如果你是一个决定使用本书来作为你的教材的授课老师， 你应该知道每一组问题， 都是足够的短到了让一个学生在45分钟到一个小时内完成， 而且还会有点时间留下来休息。有的章节的练习题会很快的得到解决， 有的可能得花更长的时间。那是因为一旦那些在中括号中的数字被写好了， 我们发现自己已经不知道该如何往上加了。  </p>

<p>那么就让我们开始吧。在你翻开此页之后课程就开始了。。。 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 前言]]></title>
    <link href="http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan/"/>
    <updated>2014-06-02T23:06:08+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/02/intermediate-perl-qian-yan</id>
    <content type="html"><![CDATA[<p>Perl的面向对象的机制是经典的变戏法。它接收一些Perl中存在的非面向对象特征，诸如packages, references, hashes,arrays, subroutines 以及 modules， 然后（并没有什么锦囊妙计）不知道从什么地方变出来完整的功能性的objects， classes 以及 methods。   </p>

<p>那是很大的一个技巧。这意味着你可以在不用首先掌握很多新的语法或者知晓大量的新的技巧的情况下， 在你已有的Perl知识的基础上继续发展， 轻松地进入面向对象的Perl发展进程中。这也同样意味着你可以通过选择最适合你的任务的已经存在的结构来对面向对象Perl进行微调， 以符合你自己的需要。  </p>

<p>但是这里有个问题。 由于Perl选择packages， references, hashes,arrays, subroutines 以及 modules 作为它的面向对象机制的基石， 为了使用面向对象Perl， 你得已经理解了packages，references, hashes,arrays, subroutines 以及 modules。   </p>

<p>接下来就是所谓的困难了。这里学习的曲线并没有被消除， 而只是被向后推延了几步而已。    </p>

<p>那么接下来你该如何学习一切你应该知道的关于非面向对象的知识，然后你就可以学习一切你因该知道的关于面向对象的知识呢？   </p>

<p>这本书就是答案。在接下来的每页里， Randal会利用他20多年使用Perl的经历， 以及40多年看Gilligan与Ed先生的经验来解释共同支撑着Perl的面向对象特性的每一个组成部分。 更棒的是， 他接着展示了如何联合那些组成的部分来创造有用的classes（类）以及objects（对象）。   </p>

<p>所以当涉及到Perl的objects，references, 以及 modules的时候， 你仍然感觉像是Gilligan， 那么这本书就是Professor要求的。  </p>

<p>以上都是真实的消息哦！   </p>

<p>–Damian Conway, 2003年5月。                                                             </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Story With Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/05/31/my-story-with-perl/"/>
    <updated>2014-05-31T17:22:45+08:00</updated>
    <id>http://isunix.github.io/blog/2014/05/31/my-story-with-perl</id>
    <content type="html"><![CDATA[<p>When I was In college, I am not interested in programming language at all. At that time, I devoted almost all of my time to English study and math thinking. I thought learning computer science was silly, because if you know how to do something(or compute something) in your own language, why do you bother to do it in computer’s language?   </p>

<p>With this thought in my mind, you can guess I did not study computer science very well, although I have to take many courses in CS. I did not fail any one of the courses I took but also not proficient in any of them.  </p>

<p>When I was about to graduate from college, I had to find a job. I was interested in foreign trade then and hoped I could use my English skill and further my interest in economics and business. I did get jobs in this area but when a job oppotunity concerning database with the job title ‘database production analyst’ got landed by me, I gave up my dream of becoming a business man and became a database production analyst, because the latter one offers a more huge salary and better working environment, and that was in year 2011 then, before July.   </p>

<p>I spent the first year of working career not knowing what to do. I was not interested in SQL programming at all, and my job then did not require too much programming skill on SQL. My team leader then is one who is very proficent in SQL Server and T-SQL programming, maybe because of him, I did not further my pursue in SQL programming.    </p>

<p>But I had to learn something then, I thought command line tools very cool, so I spent a lot of time reading other people’s code in the production environment. In order to learn how a web site is built and how to use PHP and javascript, I also joined a team in the company whose aim was to develop an internal management system, my role there was testing, but I did not think I have ever offered any help to the team and the project. Later on when the internal management system was almost finished, my name was also mentioned in the to be appreciated list. I feel quite ashamed.  </p>

<p>So based on the above， you can see I did not get a lot in my first year regarding programming language, but I did begin to make my own choice of what I wanted to learn.</p>

<p>As to my encounter with Perl, I knew the language of Perl in late 2011. I used to spend a lot of time on it when I was in the first company I joined, since that company uses a lot of Perl to do system administratiion. The problem is I have not used perl to write any useful scripts, although I have crafted some small snipptes.   </p>

<p>I always think Perl is not a beautiful language. I know something about Python also, and think Python is more readable than Perl. I have bought and read several books on Python, I have studied some of Python’s advanced usages. I have delved into Django, Flask and Tornado, the three very famous Python web framework. </p>

<p>Also, I have spent quite a while to learn Ruby and Rails. I used to think maybe I should find a job in using ruby because I have read a book on ruby written by its maker Mats then. I found ruby to be very easy and interesting then. I spent several weeks learning ruby and another several week on Rails to learn how to build a web site.  </p>

<p>And currently I am using PHP to write some internal tools for my team. I have to confess I have spent many hours on how to build the environment for PHP and Apache. I read books and watched videos on PHP. PHP is the second language I used besides bash that got deployed to production environment. As to PHP, I want to thank this language because it is easy to use and guided me to the programming world. I get to know a lot of programming concepts through using PHP. Most of the codes I wrote was in PHP.  </p>

<p>When I wanted to join the currnet company, I applied for the job position of becoming a Perl developer. I read the job description and I thought then that I can take this job. But after interviewing with my manager, he thought I was a rookie and I surely was a rookie. So I did not landed the job of becoming a Perl developer but became an analyst again, also reporting to the same manager who interviewed me on Perl developer.</p>

<p>For all these accountings, I have no idea why deep down in my heart I want to write something useful in Perl. Maybe because it is hard, maybe because I believe yes I can. </p>

<p>I want to use this opportunity to further my understanding of Perl. I choose the book “Intermediate Perl” here, and want to translate it into Chinese and expand some of the topics diccussed in that book and write something about them in this blog. I choose this book, because it is the first book on Perl that I bought. I did not buy learning Perl first because I thought I can grasp the basic of Perl just by reading the ebook and there is no need to buy the elementary one. The fact is I bought “learning Perl” several months later. I read “Intermediate Perl” several times, but I can not claim that I can understand it all, actually if I grasp the contents in that book, now it will not be necessary for me to write this post any more. </p>

<p>It is very nice to meet someone who is very proficient in Perl. But what is to be noted is, you can learn from someone, but do not count on someone to help teach you, they do not have the obligations to do that. </p>

<p>That is it, let us embark on a new journey!  </p>
]]></content>
  </entry>
  
</feed>
