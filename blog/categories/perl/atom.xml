<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-22T13:07:52+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Perl Script to Comiple C/cpp Files Conveniently]]></title>
    <link href="http://isunix.github.io/blog/2014/07/21/perl-script-to-comiple-c-slash-cpp-files-conveniently/"/>
    <updated>2014-07-21T21:31:33+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/21/perl-script-to-comiple-c-slash-cpp-files-conveniently</id>
    <content type="html"><![CDATA[<p>我自己在编译c还有c++文件的时候， 总感觉每次都得敲像下面这种格式的一串字符， 感觉很麻烦的。   </p>

<p>```c
gcc -o hello hello.c</p>

<p>```</p>

<p>所以就有了现在的这个脚本。使用方法很简单，想上面这个hello.c的文件，我们只要发出下面的命令:    </p>

<p>```c</p>

<p>cpl hello.c   </p>

<p>```</p>

<p>就可以编译出来一个去掉以原来的文件名去掉ext的文件。  </p>

<p>很简单吧！哈哈！  </p>

<p>下面给出来代码， 还是继续把doc写进去的那种。</p>

<p>```perl</p>

<p>use 5.010;
use strict;
use warnings;
use utf8;
use Cwd;
use File::Basename;</p>

<p>my $currentDir = getcwd;
my $file = $ARGV[0];
my $fullpath = “$currentDir/$file”;
my @suffix_list = qw(.cpp .c);</p>

<p>my ($name, $dir, $ext) = fileparse($file, @suffix_list);
given($ext){</p>

<pre><code>when(".c"){
    my $compile_c = "gcc -o $name $file";
    system($compile_c);
}

when(".cpp"){
    my $compile_cpp = "g++ -o $name $file";
    system($compile_cpp);
}

default{
    say "$file is of an type not compilable!";
} }
</code></pre>

<p><strong>END</strong>
=pod</p>

<p>=head1 NAME</p>

<p>cpl</p>

<p>=head1 SYNOPSIS
    $ cpl filename</p>

<p>cpl –use gcc/g++ to compile a file with c/cpp extension. Usually we will do things like “gcc -o hello hello.c”, but with this scipt, we can just issue command like this, “gcp hello.c”;</p>

<p>Thanks,
Steven</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl Script to Delete Files Without Extension]]></title>
    <link href="http://isunix.github.io/blog/2014/07/21/perl-script-to-delete-files-without-extension/"/>
    <updated>2014-07-21T18:18:34+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/21/perl-script-to-delete-files-without-extension</id>
    <content type="html"><![CDATA[<p>I want to delete those files without the extension I need, so I just write this perl script. The directory can also be specified on the command line. I list all those extensions I need as a pattern.</p>

<p>```perl
use strict;
use warnings;
use utf8;
use Cwd;</p>

<p>my $targetDir = $ARGV[0] || getcwd;
chdir $targetDir;</p>

<p>my $pattern = qr/.(md|py|php|sh|bash|zsh|vimrc|eamcs|c|cpp|java|pl|js|css|html|rb|txt)$/i,
my @file_list;</p>

<p>opendir(my $dh, $targetDir) || die “can’t opendir $targetDir: $!”;
while (readdir $dh){
    next unless -f;
    next if $_ =~ $pattern;
    push @file_list, $_;
}
closedir $dh;</p>

<p>print “The following files are going to be deleted: @file_list\n”;
unlink @file_list;</p>

<p><strong>END</strong>
=pod</p>

<p>=head1 NAME</p>

<p>delete-files.pl -delete those files without the extension as specifed in the pattern</p>

<p>=head1 SYNOPSIS</p>

<pre><code>$ delete-files It reads the files in the directory where you execute this script, and delete those not having the extension as is specified "(md|py|php|sh|bash|zsh|vimrc|eamcs|c|cpp|java|pl|js|css|html|rb|txt)"
</code></pre>

<p>Please use this script carefully. If you have somefile without extension which you also
consider them important, they maybe deleted.</p>

<p>Thanks,
Steven</p>

<p>=cut</p>

<p>```</p>

<p>I also wrote document for this scirpt. haha!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Split Mids to Several Lines With Fixed Number Per Line Using Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/18/split-mids-to-several-lines-with-fixed-number-per-line-using-perl/"/>
    <updated>2014-07-18T21:38:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/18/split-mids-to-several-lines-with-fixed-number-per-line-using-perl</id>
    <content type="html"><![CDATA[<p>事情是这样的，在工作中有许多的mids，想要贴到一个文本框中去，但是在进行reinjection后，是成每行一个mid的格式。我们想要把它们变成是每行给定数目的mids这样的格式， 方便贴到文本框中去. 之前用php实现过， 现在贴出来perl的版本的。</p>

<p>```perl</p>

<h1 id="usageperl-scriptpl-filetxt">usage：perl script.pl file.txt</h1>
<p>use strict;
use warnings;
use utf8;</p>

<p>my $columns = $ARGV[1] || 8;
open(my $IN, “$ARGV[0]”) or die “in: $@”;
open(my $OUT, “&gt;”, “$ARGV[0].new”) or die “out: $@”;</p>

<p>while(chomp(my @lines = &lt;$IN&gt;)){</p>

<pre><code>    for(my $i=1; $i &lt;= @lines; $i++){
        my $t = $i - 1;
        print $OUT "$lines[$t]";
        if($i % $columns == 0){
            print $OUT "\n";
        }
    }
}
</code></pre>

<p>close($IN);
close($OUT);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Examples of Using Grep and Map in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/18/examples-of-using-grep-and-map-in-perl/"/>
    <updated>2014-07-18T20:55:08+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/18/examples-of-using-grep-and-map-in-perl</id>
    <content type="html"><![CDATA[<p>在«Learnign Perl»中，初步介绍了perl的一些高级用法， 我之前翻译了些intermediate perl, 但是最近这段时间实在是太忙了， 而且现在还有很多其他的事情得去处理，所以真的不知道得到什么时候才可以继续拾起翻译intermediate perl的任务来。好了，下面把学习perl中的一些关于map还有grep的例子记录在这里，也方便自己以后来查询。   </p>

<p>```perl
my @odd_numbers = grep { $_ % 2 } 1..1000;  </p>

<p>my @matching_lines = grep { /\bfred\b/i } &lt;$fh&gt;;</p>

<p>my @matching_lines = grep /\bfred\b/i, &lt;$fh&gt;;  </p>

<p>my @matching_lines = grep /\bfred\b/i, &lt;$fh&gt;;
my $line_count = @matching_lines;  </p>

<p>my $line_count = grep /\bfred\b/i, &lt;$fh&gt;;  </p>

<p>my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
my @formatted_data = map { &amp;big_money($_) } @data;  </p>

<p>print “The money numbers are:\n”,
map { sprintf(“%25s\n”, $_) } @formatted_data;  </p>

<p>my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
print “The money numbers are:\n”,
map { sprintf(“%25s\n”, &amp;big_money($_) ) } @data;  </p>

<p>print “Some powers of two are:\n”,
map “\t” . ( 2 ** $_ ) . “\n”, 0..15;  </p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using of Loops in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/18/using-of-loops-in-perl/"/>
    <updated>2014-07-18T19:59:02+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/18/using-of-loops-in-perl</id>
    <content type="html"><![CDATA[<p>«Learning Perl»中的一个例子。  </p>

<p><code>
Make a program that will repeatedly ask the user to guess a secret number
from 1 to 100 until the user guesses the secret number. Your program should pick
the number at random by using the magical formula int(1 + rand 100).§ When
the user guesses wrong, the program should respond, “Too high” or “Too low.” If
the user enters the word quit or exit, or if the user enters a blank line, the program
should quit. Of course, if the user guesses correctly, the program should quit then
as well!
</code>  </p>

<p>还是把code贴在这里吧！ </p>

<p>```perl</p>

<p>my $secret = int(1 + rand(100));</p>

<p>while(1){
    print “please enter a guess from 1 to 100: “;
    chomp(my $guess = <stdin>);
    if ($guess =~ /quit|exit|\A\s*\z/i){
        print "sorry you gave up, the number was $secret.\n";
        last;
    } elsif ($guess &lt; $secret){
        print "too small!\n";
    } elsif ($guess == $secret){
        print "that was it!\n";
        last;
    } else {
        print "too large!\n";
    }
}  </stdin></p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
