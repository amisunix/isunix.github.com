<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-24T19:57:04+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[About the Use of My and Our in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/about-the-of-my-and-our-and-local-in-perl/"/>
    <updated>2014-07-24T19:32:11+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/about-the-of-my-and-our-and-local-in-perl</id>
    <content type="html"><![CDATA[<p>关于perl中的my， our，local的用法自己一直都是一知半解的。以至于基本上在程序中把所有的变量的前面都加上my， 省事还不报错!   </p>

<p>I am still not familiar the concept, but I will list some examples here to add as a reminder.  </p>

<p><code>perl   
our $var = 1;
{
	our $var = 2;
	print "$var\n";
}
print "$var\n";    
</code>
It will give us the result:  </p>

<p><code>
2
2
</code><br />
If the code looks like this:   </p>

<p><code>perl   
my $var = 1;
{
	my $var = 2;
	print "$var\n";
}
print "$var\n";    
</code> <br />
It will give us the result:   </p>

<p><code> 
2
1  
</code>
If the code is:   </p>

<p><code>perl  
our $var = 1;
{
	my $var = 2;
	print "$var\n";
}
print "$var\n";    
</code>   <br />
It will give us the following result:  </p>

<p><code>
2
1
</code>
if the code is:  </p>

<p><code>perl 
my $var = 1;
{
	our $var = 2;
	print "$var\n";
}
print "$var\n";    
</code><br />
It will give us the result:   </p>

<p><code>
2
1
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minutes About Stdin]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/minutes-about-stdin/"/>
    <updated>2014-07-24T17:26:27+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/minutes-about-stdin</id>
    <content type="html"><![CDATA[<p>There are some minute details about perl that we need to take care. So here I take a note for later reminder. </p>

<ol>
  <li>
    <p>STDERR will print out the error messages to the screen or to a file if you want.   </p>
  </li>
  <li>
    <p>If we have a line of code like:  </p>
  </li>
</ol>

<p><code>perl  
  $GetALine = &lt;STDIN&gt;;
 </code></p>

<p>It will wait for the user to enter something and then append a line ending character to the string that the user enters. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About the Sort Function in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/about-the-sort-function-in-perl/"/>
    <updated>2014-07-24T16:51:22+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/about-the-sort-function-in-perl</id>
    <content type="html"><![CDATA[<p>This blog post is about the sort function in Perl. Mostly it is from the book “perl for dummies”, since I am reading it now.   </p>

<p>This is a good book, since it explains many concepts very clearly.  </p>

<p>The “sort” function sorts a list alphabeticlly. Perl also allows us to sort a list according to the rule we defined.  </p>

<p>if alphabetically, we can write the code as the following:  </p>

<p>```perl</p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort @strs);</p>

<p>```  <br />
It will give the following result:  </p>

<p><code>
attune bell cognition
</code></p>

<p>Here below I will show what we can do if we want to sort based on the way we want it to be:  </p>

<p>```perl </p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort{length($a) &lt;=&gt; length($b)} @strs);  </p>

<p>```<br />
The above code will sort the list according to the length of the string in the list.  </p>

<p>What if the our so-called rule is a subroutine?  </p>

<p>```perl
sub lensort { length($a) &lt;=&gt; length($b) };</p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort lensort @strs);</p>

<p>```  </p>

<p>This post is going to be continued. I will add more things as I come accross more useful and interesing examples regarding the sort function.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About the Defined Function in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/about-the-defined-function-in-perl/"/>
    <updated>2014-07-24T16:09:53+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/about-the-defined-function-in-perl</id>
    <content type="html"><![CDATA[<p>在”perl for dummies” 这本书中有段很精彩的关于defined 函数的说明。现在记录如下:    </p>

<p>在perl中构建语句的一个基本规则是: 使用变量前应该在赋值语句的右边定义它们，这样做可以防止perl给未定义的变量插入默认值.  </p>

<p>未定义的变量的存在是有意义的。照搬书中的例子，如果试图从空列表中提取数据， pop函数就会返回一个未定义的值。让pop函数返回未定义的值比返回假值要好，因为’false’可能就是列表中的某个元素。  </p>

<p>那么我们怎么去判断一个函数是否返回未定义的值呢？ 这里”defined” 就派上用场了。该函数会作用于一个变量或者表达式。如果这个被作用的对象已被定义，defined函数就会返回真， 否则就会返回假。 通常会跟着if或者unless来使用的。  </p>

<p>```perl
unless (defined($Yummy = pop(@Bonbons))){
	print “there are no more bonbos left.”;
}  </p>

<p>```<br />
如果@Bonbons这个列表是空的， defined函数就会返回假值，就会执行print语句，这个时候$Yummy变量将包含一个未定义的值。   </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Typical Perl Script to Search Info in a File]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/a-typical-perl-script-to-search-info-in-a-file/"/>
    <updated>2014-07-24T15:33:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/a-typical-perl-script-to-search-info-in-a-file</id>
    <content type="html"><![CDATA[<p>This one is where I excerpted from the book “perl for dummies”.  </p>

<p>```perl</p>

<p>$TheDB = ‘edata.txt’;</p>

<p>open(INDB, $TheDB) or die “The database $TheDB could “ . “not be found.\n”;</p>

<p>while(1) { </p>

<p>print “\nDo you want to search by employee ID (I), “ . “ or quit (Q): “;</p>

<p>$DoSearch = <stdin>;
  chomp($DoSearch);
  $DoSearch =~ tr/A-Z/a-z/;</stdin></p>

<p>if($DoSearch eq ‘q’) { last }</p>

<p>unless($DoSearch eq ‘i’) {
    print “You must enter either I or Q.\n”;
    next; 
  }</p>

<p>print “Search for ID number: “;
  $SearchFor = <stdin>;
  chomp($SearchFor);</stdin></p>

<p>seek(INDB, 0, 0);   ##search from the beginning of file.</p>

<p>$SuccessCount = 0;</p>

<p>while(<indb>) {
    $TheRec = $_;
    chomp($TheRec);
    ($LastName, $FirstName, $ID, $Tel) =
      split(/\t/, $TheRec);
    if($ID eq $SearchFor) {
      $SuccessCount = $SuccessCount + 1;
      print "$ID: $FirstName $LastName, ext. ". "$Tel\n";
    } 
  } </indb></p>

<p>if($SuccessCount == 0) { print “No records found.\n” }
  else { print “$SuccessCount records found.\n” }
} </p>

<p>print “Program finished.\n”;</p>

<p>```
We can learn the use of while, endless loop, file-handle, last, tr, seek, $_, eq, split, string concatenation if-else, chomp, ==, eq all these things in one perl script.  </p>

]]></content>
  </entry>
  
</feed>
