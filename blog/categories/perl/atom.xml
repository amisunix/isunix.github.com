<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-17T16:13:28+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[About the Use of State in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/about-the-use-of-state-in-perl/"/>
    <updated>2014-07-17T16:02:20+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/about-the-use-of-state-in-perl</id>
    <content type="html"><![CDATA[<p>算了还是引用一下«learning perl»中文翻译版本中的话吧:   </p>

<p>```
在Perl中可以使用my操作符来创建私有变量， 但是每次调用这个子程序的时候，这个私有变量都会被重新定义。而使用state操作符来声明的变量，我们便可以在子程序的多次调用期间保留变量之前的值， 并将变量的作用域限于子程序内部</p>

<p>```</p>

<p>让我们来看下使用my还有使用state所产生的不同的效果吧。  </p>

<p>首先是my:  </p>

<p>```perl</p>

<p>use 5.010;</p>

<p>running_sum( 5, 6 );
running_sum( 1..3 );
running_sum( 4 );</p>

<p>sub running_sum {
    my $sum = 0;
    my @numbers;</p>

<pre><code>foreach my $number ( @_ ) {
  push @numbers, $number;
  $sum += $number;
}

say "the sum of (@numbers) is $sum"; }  
</code></pre>

<p>```  </p>

<p>这段code产生的结果是:  </p>

<p>```perl</p>

<p>the sum of (5 6) is 11
the sum of (1 2 3) is 6
the sum of (4) is 4</p>

<p>```   </p>

<p>下面是state:  </p>

<p>```perl</p>

<p>use 5.010;
running_sum( 5, 6 );
running_sum( 1..3 );
running_sum( 4 );</p>

<p>sub running_sum {
    state $sum = 0;
    state @numbers;
    foreach my $number ( @_ ) {
        push @numbers, $number;
        $sum += $number;
    }</p>

<p>say “The sum of (@numbers) is $sum”;
}</p>

<p>```<br />
它的结果是:   </p>

<p>```perl  </p>

<p>The sum of (5 6) is 11
The sum of (5 6 1 2 3) is 17
The sum of (5 6 1 2 3 4) is 21</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl中单行或者多行输出结果]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/perlzhong-dan-xing-huo-zhe-duo-xing-shu-chu-jie-guo/"/>
    <updated>2014-07-17T15:14:23+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/perlzhong-dan-xing-huo-zhe-duo-xing-shu-chu-jie-guo</id>
    <content type="html"><![CDATA[<p>我们在标准输入中得到多行的值， 现在我们想要以单行还有多行的结果来把它们给显示出来， 要是想单行显示的话，可以如下:</p>

<p>```perl</p>

<p>chomp(@lines = <stdin>);
@sorted = sort @lines;
print "@sorted\n"</stdin></p>

<p>```</p>

<p>多行的话可以:  </p>

<p>```perl </p>

<p>print sort <stdin>;</stdin></p>

<p>```  </p>

<p>这里的关键的地方就是chomp这个函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Chapters at Once]]></title>
    <link href="http://isunix.github.io/blog/2014/07/17/generate-chapters-at-once/"/>
    <updated>2014-07-17T10:47:48+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/17/generate-chapters-at-once</id>
    <content type="html"><![CDATA[<p>I use this script to generate chapters at once. The number of chapters you want to generate in passed through the command line as the first argument.  </p>

<p>```perl </p>

<p>use strict;
use warnings;
use utf8;
use Data::Dumper;</p>

<p>my $chap_num = $ARGV[0];</p>

<p>for(my $i = 1; $i &lt;= $chap_num; $i++){
    mkdir “chap_$i”;
}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sort in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/06/22/sort-in-perl/"/>
    <updated>2014-06-22T12:31:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/22/sort-in-perl</id>
    <content type="html"><![CDATA[<p>In Perl, function sort() sort the item of an array according to its corresponding acssci code. for example, if we have an array @array = (1, 3, 10, 2, 21) and use sort against this array, we will get the following result: 1 10 2 21 3. However if we want to sort these numbers according to its value, we can use the following method:   </p>

<p>```perl</p>

<p>sort{$a &lt;=&gt; $b} @array;   #ascending</p>

<p>sort{$b &lt;=&gt; $a} @array;   #descending</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intermediate Perl 第四章 引用入门]]></title>
    <link href="http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men/"/>
    <updated>2014-06-11T18:45:27+08:00</updated>
    <id>http://isunix.github.io/blog/2014/06/11/zhong-ji-perl-yin-yong-ru-men</id>
    <content type="html"><![CDATA[<p>引用是Perl的复杂的数据结构，面向对象编程还有花哨的子程序的基石。它们是在Perl4还有Perl5这段时间被添加进去的。    </p>

<p>一个Perl的标量变量存有一个单一的值。一个数组存有一个或者多个标量的有序列表。一个哈希存有一组标量作为值， 然后以另外一组值作为键。尽管一个标量可以是一个任意的字符串，那样就允许复杂的数据被嵌入到数组或者哈希里面去，但是上面的三种数据类型没有一种是很合适复杂的数据间的相互关系的。这就是引用的活了。让我们以一个例子开头看下引用的重要性。  </p>

<h2 id="section">在许多数组上面执行同样的任务</h2>

<p>在Minnow开始一个短途旅途的(例如，一个3小时的观光), 我们应该检查每一个乘客还有全体乘务人员来确保他们都拥有必备的旅行用品。比如说， 为了还上航行的安全，Minnow穿上的每个人都得有个救生圈，一些遮光剂，一个水壶还有一个雨衣。我们可以写一些代码来检查Skipper的储备。   </p>

<p><code>perl
my @required = qw(preserver sunscreen water_bottle jacket);
my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
for my $item (@required) {
	unless (grep $item eq $_, @skipper) { # not found in list?
	print "skipper is missing $item.\n";
	}
}
</code>   </p>

<p>grep在标量上下文中返回表达式 $item eq $_ 返回 true 的次数，当这件东西在清单里的时候就是1，不在的话就是0. 如果值是0的话，就是假,这个时候我们就把信息给打印出来。   </p>

<p>当然如果我们想要检查Gilligan还有Professor的话，我们可能会写如下的代码:  </p>

<p>```perl
my @gilligan = qw(red_shirt hat lucky_socks water_bottle);
for my $item (@required) {
	unless (grep $item eq $_, @gilligan) { # not found in list?
	print “gilligan is missing $item.\n”;
	}
}</p>

<p>my @professor = qw(sunscreen water_bottle slide_rule batteries radio);
for my $item (@required) {
	unless (grep $item eq $_, @professor) { # not found in list?
	print “professor is missing $item.\n”;
	}
}
```   </p>

<p>你可能开始注意到这里有很多的冗余的代码，并且想到我们应该把它重构到一个可以重用的通用的子程序中(你是正确的):   </p>

<p>```perl
sub check_required_items {
	my $who = shift;
	my @required = qw(preserver sunscreen water_bottle jacket);
	for my $item (@required) {
		unless (grep $item eq $<em>, @</em>) { # not found in list?
			print “$who is missing $item.\n”;
		}
	}
}</p>

<p>my @gilligan = qw(red_shirt hat lucky_socks water_bottle);
check_required_items(‘gilligan’, @gilligan);
```    </p>

<p>Perl一开始通过它的@_数组给了子程序5个条款：名字gilligan还有属于Gilligan的4个东西。在shift操作之后，@_就只有4个东西了。因此grep通过和清单比对来检查每个所必备的东西。   </p>

<p>到目前为止，一切都很好。我们可以同过一点多余的代码来检查Skipper还有Professor的：  </p>

<p><code>perl
my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
my @professor = qw(sunscreen water_bottle slide_rule batteries radio);
check_required_items('skipper', @skipper);
check_required_items('professor', @professor);
</code>   </p>

<p>对于其他的乘客，我们在需要的地方重复下就行了。尽管这个代码符合一开始的要求，我们有两个问题得处理: </p>

<p>*为了创建@_, Perl把数组的整个内容都拷下下来扫描。对于一个元素的话这没什么问题，但是如果数组很大的话，把数据拷贝然后仅仅就是为了传给子程序的话就显得有点浪费了。   </p>

<p>*假如我们想要修改原先的数组来迫使供应清单包括一些必备的东西，因为我们在子程序中有一个副本(传值),对@_做的任何的修改都不会自动地反映到对应的供应清单数组中去。   </p>

<p>为了解决一个或者两个问题，我们需要的是引用传递而非值传递。这就是doctor(或者Professor)所要求的。  </p>

<h2 id="section-1">对一个数组做引用</h2>

<p>在反斜线()的很多的其他的意思当中，它还是”对某项东西进行引用”的操作符。当我们把它用在一个数组名的前面的时候，比如， \@skipper， 他的结果就是对那个数组的引用。对数组的引用就像是指针: 它指向数组，但是它不是数组本身。  </p>

<p>任何变量适宜地方都是适用于引用。它可以作用于一个数组或者哈希的元素，或者一个普通的标量变量， 像下面这样:  </p>

<p><code>perl
my $reference_to_skipper = \@skipper;
</code>  </p>

<p>引用可以被拷贝:  </p>

<p><code>perl
my $second_reference_to_skipper = $reference_to_skipper;
</code><br />
甚至于：  </p>

<p><code>perl
my $third_reference_to_skipper = \@skipper; 
</code> <br />
我们可以相互交换这3个引用。我们甚至可以说它们是相同的，因为事实上，它们就是相同的东西:  </p>

<p><code>perl
if ($reference_to_skipper = = $second_reference_to_skipper) {
	print "They are identical references.\n";
}
</code><br />
这个等式比较两个引用的数值形式。这里引用的数值形式是@skipper内部数据结构的唯一的内存地址, 它在变量的生命周期里是不会改变的。如果我们使用eq或者print来查看它的字符串形式，我们会得到调试出来的字符串:   </p>

<p><code>perl
ARRAY(0x1a2b3c)
</code><br />
对于这个数组它也是唯一的，因为它包含了数组的唯一地址的16进制表示。调试出来的字符串同样也表示了这是个数组引用。当然要是我们在我们的代码中看到类似的输出，那就基本上表示了有bug。使用我们代码的用户是对16进制的存储地址块没有兴趣的。  </p>

<p>因为我们可以拷贝一个引用，向一个子程序传递一个参数事实上就是拷贝，我们可以使用下面的代码来向子程序中的数组传递一个引用:   </p>

<p>```perl
my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
check_required_items(“The Skipper”, \@skipper);</p>

<p>sub check_required_items {
	my $who = shift;
	my $items = shift;
	my @required = qw(preserver sunscreen water_bottle jacket);
	…
}
```   </p>

<p>现在子程序中的$items是对数组@skipper的一个引用。但是我么怎么能够从一个引用得到我们原先的数组呢? 那当然是我们对引用进行解引用了。</p>

<h2 id="section-2">对数组引用进行解引用</h2>

<p>如果你看一下@skipper的话，你会发现他包含了两部分：@符号以及数组的名字。类似的， 语法$syntax[1]包含了中间部分的数组名以及在外围部分的一些语法来得到数组的第二个元素(指标值1是第二个元素因为指标值从0开始).    </p>

<p>下面有个小的技巧: 我们可以向数组中放置任何一个包含在大括号中的引用，来代替数组名，这样就得到了一个获得原先数组的方法。也就是说，任何我们用skipper来命令数组的地方，我们都可以使用大括号中包含引用的形式.：{$items}。例如， 下面的这两行都表示整个的数组。  </p>

<p>```perl
@ skipper     </p>

<p>@{ $items }  <br />
```   </p>

<p>而下面的这两行都表示了数组的第二个元素:   </p>

<p>```perl
$skipper [1]   </p>

<p>${$items}[1]<br />
``` <br />
通过使用引用过的形式，我们把代码还有获取数组的方法从实际的数组分离开了。让我们看一下这是怎样改变了这个子程序的其余的部分的。   </p>

<p><code>perl   
sub check_required_items {
	my $who = shift;
	my $items = shift;
	my @required = qw(preserver sunscreen water_bottle jacket);
	for my $item (@required) {
		unless (grep $item eq $_, @{$items}) { # not found in list?
		print "$who is missing $item.\n";
		}
	}
}
</code>    </p>

<p>我们所做的就是把@_(供应清单的副本)替换成@{$items},一个对原先供应清单的引用的解引用. 现在我们就可以像之前那样，对子程序调用几次了:   </p>

<p><code>perl
my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
check_required_items('The Skipper', \@skipper);
my @professor = qw(sunscreen water_bottle slide_rule batteries radio);
check_required_items('Professor', \@professor);
my @gilligan = qw(red_shirt hat lucky_socks water_bottle);
check_required_items('Gilligan', \@gilligan);
</code> <br />
在每一种情况下，$items都指向一个不同的数组，所以每次我们调用的时候，同样的代码都指向不同的数组。只是引用的最重要的用法之一: 把代码从它所作用的数据结构上面分离开来，那样我们就可以更方便地重用代码了。  </p>

<p>通过引用传递数组解决了我们之前提到的两个问题中的第一个问题. 现在，我们得到了一个指向供应清单的单一的引用引用， 而不是把整个的供应清单都拷贝到@_数组中去.   </p>

<p>我们可以把子程序开头的两个shift给去掉吗? 当然， 但是那样会牺牲掉清晰性的.   </p>

<p>```perl
sub check_required_items {
	my @required = qw(preserver sunscreen water_bottle jacket);</p>

<pre><code>for my $item (@required) {
	unless (grep $item eq $_, @{$_[1]}) { # not found in list?
	print "$_[0] is missing $item.\n";
	}
} } ```    在@_中仍然有两个元素, 第一个元素是乘客或者乘务人员的名字， 我们将在错误信息中使用到。第二个元素是对正确的供应清单的引用，我们在grep表达式中会使用到.   
</code></pre>

<h2 id="section-3">把括号去掉</h2>

<p>绝大多数时候，我们想要解引用的那个引用都是简单的标量变量, 如 @{$items} 或者 ${$items}[1]. 在那些情况下去掉大括号，而毫不含糊地就形成了 @$items或者 $$items[1].  </p>

<p>然而， 要是大括号中的值不是一个简单的标量变量的时候, 我们就不可以把括号个去掉了. 例如, 对于来自上个自程序中的重写@{$_[1]}, 我们就不可以把括号给去掉了, 那是对数组的单一元素的访问，不是一个标量。  </p>

<p>这个规则也表示了我们将很容易看到”缺失”的括号得放到什么地方去. 当我们看到 $$items[1]这个听讨厌的语法的时候，我们可以知道大括号肯定属于简单的表量变量$items的周围。因此，$items肯定是数组的一个引用.  </p>

<p>因此， 上面那个子程序的一个看起来更加舒服的版本就是:    </p>

<p><code>perl  
sub check_required_items {
	my $who = shift;
	my $items = shift;
	my @required = qw(preserver sunscreen water_bottle jacket);
	for my $item (@required) {
		unless (grep $item eq $_, @$items) { # not found in list?
		print "$who is missing $item.\n";
		}
	}
}
</code><br />
唯一的区别就是我们把@$items周围的括号给去掉了.  </p>

<h2 id="section-4">修改数组</h2>

<p>你已经看到了怎样通过一个数组的引用来解决过度的复制的问题. 现在让我们看下怎样修改原先的数组.  </p>

<p>对于每一个缺失的供应品，我们把它push到一个数组里面去， 强迫乘客考虑这个条款:  </p>

<p>```perl
sub check_required_items {
	my $who = shift;
	my $items = shift;
	my @required = qw(preserver sunscreen water_bottle jacket);
	my @missing = ( );
	for my $item (@required) {
		unless (grep $item eq $_, @$items) { # not found in list?
		print “$who is missing $item.\n”;
		push @missing, $item;
	    }
    }</p>

<pre><code>if (@missing) {
	print "Adding @missing to @$items for $who.\n";
    push @$items, @missing;
} } ```
</code></pre>

<p>注意下添加的@missing数组。如果我们在扫描的过程中发现了任何物品缺失了， 我们可以把它push到@missing中去。如果在扫描完了之后这个数组中有东西的话，我们就把它添加到原先的供应清单中去。  </p>

<p>关键点就是这个子程序中的最后一行。我们对$items数组引用进行解引用，访问原先的数组，然后把@missing中元素添加进去。要是没有引用传值的话，我们将只能修改数据的一个本地的拷贝，那样将对原先的数组没有任何的影响。  </p>

<p>同样的, @items(以及它的更加常见的形式@{$items})可以在双引号引起来的字符串中运作。我们不可以在@和接下来的任何的字符之间包含空格，尽管我们可以在大括号中包含任意数量的空格， 就好像那是正常的Perl代码一样。  </p>

<h2 id="section-5">嵌套的数据结构</h2>

<p>在下面的例子中，数组@_包含了两个元素, 其中之一仍然是数组. 如果我们对一个数组进行引用，而这个数组又包含了一个一个对数组的引用, 那将会怎么样呢？ 我们得到的将是一个复杂的数据结构, 这将是非常有用的。  </p>

<p>例如, 我们可以先构建一个更大的数据结构，它包含了整个的供应清单, 通过来对数据进行递归，我们将得到Skipper, Gilligan还有Professor的信息:  </p>

<p><code>perl
my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
my @skipper_with_name = ('Skipper', \@skipper);
my @professor = qw(sunscreen water_bottle slide_rule batteries radio);
my @professor_with_name = ('Professor', \@professor);
my @gilligan = qw(red_shirt hat lucky_socks water_bottle);
my @gilligan_with_name = ('Gilligan', \@gilligan);
</code>
现在@skipper_with_name就有两个元素了, 第二个元素是数组的引用，同我们之前传递给子程序的是相似的。现在我们把这些都组合起来:  </p>

<p><code>perl
my @all_with_names = (
\@skipper_with_name,
\@professor_with_name,
\@gilligan_with_name,
);
</code>  </p>

<p>注意我们只有3个元素，其中的每一个都是一个对一个数组的引用，这个数组有两个元素: 名字还有对应的初始供应列表。图4-1是它的一个图片:  </p>

<p><img src="/images/sun/perl_4.1.png">   </p>

<p>因此，$all_with_names[2]将会是对于Gilligan的数据的数组引用。如果你把它解引用的话@{$all_with_names[2]}，你将得到一个两个元素的数组，”Gilligan”还有另一个数组引用。 </p>

]]></content>
  </entry>
  
</feed>
