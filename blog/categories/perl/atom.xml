<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-07-24T17:10:00+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[About the Sort Function in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/about-the-sort-function-in-perl/"/>
    <updated>2014-07-24T16:51:22+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/about-the-sort-function-in-perl</id>
    <content type="html"><![CDATA[<p>This blog post is about the sort function in Perl. Mostly it is from the book “perl for dummies”, since I am reading it now.   </p>

<p>This is a good book, since it explains many concepts very clearly.  </p>

<p>The “sort” function sorts a list alphabeticlly. Perl also allows us to sort a list according to the rule we defined.  </p>

<p>if alphabetically, we can write the code as the following:  </p>

<p>```perl</p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort @strs);</p>

<p>```  <br />
It will give the following result:  </p>

<p><code>
attune bell cognition
</code></p>

<p>Here below I will show what we can do if we want to sort based on the way we want it to be:  </p>

<p>```perl </p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort{length($a) &lt;=&gt; length($b)} @strs);  </p>

<p>```<br />
The above code will sort the list according to the length of the string in the list.  </p>

<p>What if the our so-called rule is a subroutine?  </p>

<p>```perl
sub lensort { length($a) &lt;=&gt; length($b) };</p>

<p>@strs = (‘cognition’, ‘attune’, ‘bell’);
print join(‘ ‘, sort lensort @strs);</p>

<p>```  </p>

<p>This post is going to be continued. I will add more thing as I come accross more useful and interesing examples regarding the sort function.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About the Defined Function in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/about-the-defined-function-in-perl/"/>
    <updated>2014-07-24T16:09:53+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/about-the-defined-function-in-perl</id>
    <content type="html"><![CDATA[<p>在”perl for dummies” 这本书中有段很精彩的关于defined 函数的说明。现在记录如下:    </p>

<p>在perl中构建语句的一个基本规则是: 使用变量前应该在赋值语句的右边定义它们，这样做可以防止perl给未定义的变量插入默认值.  </p>

<p>未定义的变量的存在是有意义的。照搬书中的例子，如果试图从空列表中提取数据， pop函数就会返回一个未定义的值。让pop函数返回未定义的值比返回假值要好，因为’false’可能就是列表中的某个元素。  </p>

<p>那么我们怎么去判断一个函数是否返回未定义的值呢？ 这里”defined” 就派上用场了。该函数会作用于一个变量或者表达式。如果这个被作用的对象已被定义，defined函数就会返回真， 否则就会返回假。 通常会跟着if或者unless来使用的。  </p>

<p>```perl
unless (defined($Yummy = pop(@Bonbons))){
	print “there are no more bonbos left.”;
}  </p>

<p>```<br />
如果@Bonbons这个列表是空的， defined函数就会返回假值，就会执行print语句，这个时候$Yummy变量将包含一个未定义的值。   </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Typical Perl Script to Search Info in a File]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/a-typical-perl-script-to-search-info-in-a-file/"/>
    <updated>2014-07-24T15:33:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/a-typical-perl-script-to-search-info-in-a-file</id>
    <content type="html"><![CDATA[<p>This one is where I excerpted from the book “perl for dummies”.  </p>

<p>```perl</p>

<p>$TheDB = ‘edata.txt’;</p>

<p>open(INDB, $TheDB) or die “The database $TheDB could “ . “not be found.\n”;</p>

<p>while(1) { </p>

<p>print “\nDo you want to search by employee ID (I), “ . “ or quit (Q): “;</p>

<p>$DoSearch = <stdin>;
  chomp($DoSearch);
  $DoSearch =~ tr/A-Z/a-z/;</stdin></p>

<p>if($DoSearch eq ‘q’) { last }</p>

<p>unless($DoSearch eq ‘i’) {
    print “You must enter either I or Q.\n”;
    next; 
  }</p>

<p>print “Search for ID number: “;
  $SearchFor = <stdin>;
  chomp($SearchFor);</stdin></p>

<p>seek(INDB, 0, 0);   ##search from the beginning of file.</p>

<p>$SuccessCount = 0;</p>

<p>while(<indb>) {
    $TheRec = $_;
    chomp($TheRec);
    ($LastName, $FirstName, $ID, $Tel) =
      split(/\t/, $TheRec);
    if($ID eq $SearchFor) {
      $SuccessCount = $SuccessCount + 1;
      print "$ID: $FirstName $LastName, ext. ". "$Tel\n";
    } 
  } </indb></p>

<p>if($SuccessCount == 0) { print “No records found.\n” }
  else { print “$SuccessCount records found.\n” }
} </p>

<p>print “Program finished.\n”;</p>

<p>```
We can learn the use of while, endless loop, file-handle, last, tr, seek, $_, eq, split, string concatenation if-else, chomp, ==, eq all these things in one perl script.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Typical Perl Program]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/a-typical-perl-program/"/>
    <updated>2014-07-24T15:17:20+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/a-typical-perl-program</id>
    <content type="html"><![CDATA[<p>Of courese there are many perl programms that can be claimed as “typical”, yet you can not what is truely “typical”. The one below is where I met in the book “perl for dummies”. Ok, show you the code now.   </p>

<p>```perl  </p>

<p>$TheFile = “sample.txt”;</p>

<p>open(INFILE, $TheFile) or die “The file $TheFile could “ .  “not be found.\n”;</p>

<p>$CharCount = 0;
$WordCount = 0;
$LineCount = 0;</p>

<p>while(<infile>) {
  $TheLine = $_;
  chomp($TheLine);</infile></p>

<p>$LineCount = $LineCount + 1;
  $LineLen = length($TheLine);
  $CharCount = $CharCount + $LineLen;</p>

<p>if($TheLine eq “”) { next }; ##evaluate the next line;
  $WordCount = $WordCount + 1;
  $CharPos = 0;</p>

<p>until($CharPos == $LineLen) {
    if(substr($TheLine, $CharPos, 1) eq “ “)
      { $WordCount = $WordCount + 1 }
    $CharPos = $CharPos + 1;
  }
}</p>

<p>print “For the file $TheFile:\n”;
print “Number of characters $CharCount\n”;
print “Number of words    $WordCount\n”;
print “Number of lines    $LineCount\n”;</p>

<p>```    </p>

<p>I list this program here, because We can learn how to use chomp, length, $_, &lt;&gt;, until, next, eq, ==, next, substr, FILEHANDLE, string concatenation, how to tell if it is a word and so on, all these import concepts in perl programming in one script. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl One-liner to Remove Blank Lines]]></title>
    <link href="http://isunix.github.io/blog/2014/07/24/perl-one-liner-to-remove-blank-lines/"/>
    <updated>2014-07-24T15:05:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/07/24/perl-one-liner-to-remove-blank-lines</id>
    <content type="html"><![CDATA[<p>Here below is the one-liner I found to remove a blank line in a file.   </p>

<p>```perl  </p>

<p>perl -pi -e ‘s!^\s+?$!!’ file.txt  </p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
