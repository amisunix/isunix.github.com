<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-11-24T15:40:00+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache Setup to Redirect a Site]]></title>
    <link href="http://isunix.github.io/blog/2014/11/24/apache-setup-to-redict-a-site/"/>
    <updated>2014-11-24T14:31:59+08:00</updated>
    <id>http://isunix.github.io/blog/2014/11/24/apache-setup-to-redict-a-site</id>
    <content type="html"><![CDATA[<p>While I was developing a dancer application, I usually open a new port, like goople.com:4001. Actually there is a better way to do this. </p>

<p>On our CentOS server, in the httpd.conf file, we include the following piece to it:</p>

<p><code>html
Include etc/apache22/Includes/*.conf
</code>  </p>

<p>If it is not already there.  </p>

<p>Then in the dir,  /usr/local/etc/apache22/Includes, we will write our own configuration file. </p>

<p>Then we can make a file named sun.conf in the Includes dir and write to it something like this:  </p>

<p>```html
Alias /~stsun /home/stsun/public_html</p>

<p>&lt;Directory “/home/stsun/public_html”&gt;
	Options +Indexes FollowSymLinks
	AllowOverride All
	Order allow,deny
	Allow from all
&lt;/Directory&gt;
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Print Stderr in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/11/18/print-stderr-in-perl/"/>
    <updated>2014-11-18T16:52:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/11/18/print-stderr-in-perl</id>
    <content type="html"><![CDATA[<p>I better not write one by myself, there is a very good article on this:  </p>

<p><code>html
http://perlmaven.com/stdout-stderr-and-redirection
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Perl on Centos Locally]]></title>
    <link href="http://isunix.github.io/blog/2014/11/06/install-perl-on-centos-locally/"/>
    <updated>2014-11-06T16:55:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/11/06/install-perl-on-centos-locally</id>
    <content type="html"><![CDATA[<p>Following the following steps to install perl in the local directory on your machine.</p>

<p><code>pl
tar -xzf perl-5.10.1.tar.gz
cd perl-5.10.1
./Configure -des -Dprefix=$HOME/local
make
make test
make install
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Perl Chap03]]></title>
    <link href="http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap03/"/>
    <updated>2014-10-28T16:58:25+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap03</id>
    <content type="html"><![CDATA[<p>This is a note about chap03 in “Object oriented perl”.  </p>

<p>1.In object oriented perl, there are three rules,</p>

<p><code>pl
1. rule1: To create a class, build a package.   
2. rule2: To create a method, write a subroutine.
3. rule3: To create an object, bless a referent.
</code>    </p>

<p>2.Some cases while calling a method through an arrow:  </p>

<p><code>pl
$hsh_ref-&gt;{"key"};# Access the hash referred to by $hashref
$arr_ref-&gt;[$index];# Access the array referred to by $arrayref
$sub_ref-&gt;(@args);# Access the sub referred to by $subref
$obj_ref-&gt;method(@args);# Access the object referred to by $objref
</code>  </p>

<p>3.When a method like <code>Bug::print_me</code> is called, the argument list that it receives begins with the object reference through which it was called, followed by any arguments that were explicitly given to the method. That means that calling </p>

<p><code>pl
Bug::print_me("logfile")
</code> </p>

<p>is not the same as calling </p>

<p><code>pl
$nextbug-&gt;print_me("logfile")
</code></p>

<p>In the first case, print_me is treated as a regular subroutine so the argument list passed to <code>Bug::print_me</code> is equivalent to:</p>

<p><code>pl
( "logfile" )
</code>
In the second case, <code>print_me</code> is treated as a method so the argument list is equivalent to:   </p>

<p><code>pl
( $objref, "logfile" )
</code> </p>

<p>Having a reference to the object passed as the first parameter is vital, because it means that the method then has access to the object on which it’s supposed to operate. Hence you’ll find that most methods in Perl start with something equivalent to this:   </p>

<p><code>pl
package Bug;
sub print_me{
	my ($self) = shift;
}
</code>  </p>

<p>or better still:  </p>

<p><code>pl
package Bug;
sub print_me{
	my ($self, @args) = @_;
}
</code><br />
This second version is better because it provides a lexically scoped copy of the argument list <code>(@args)</code>.   </p>

<p>4.Unlike other object-oriented languages, Perl doesn’t require that an object be a special kind of recordlike data structure. In fact, you can use any existing type of Perl variable—a scalar, an array, a hash—as an object in Perl.   </p>

<p>5.The <code>bless</code> function takes two arguments: a reference to the variable to be marked and a string containing the name of the class. It then sets an internal flag on the variable, indicating that it now belongs to the class.  </p>

<p>6.We didn’t bless the reference; we blessed the referent. The scalar didn’t change—only the nameless hash it refers to has been marked.   </p>

<p>7.You can check that the blessing succeeded by applying the built-in ref function to <code>$nextbug</code>. Normally, when <code>ref</code> is applied to a reference, it returns the type of that reference.  </p>

<p><code>pl
my $nextbug = {
    _id =&gt; "00001",
    _type =&gt; "fatal",
    _descr =&gt; "application does not compile"
};
bless $nextbug, "Bug";
print ref($nextbug);
</code></p>

<p>THe above code gives out the result, <code>Bug</code>.   </p>

<p>8.Based on the things we said above, we will show a piece of code to demonstrate how to get and set attributes in perl.</p>

<p>```pl
package CD::Music;
use strict;</p>

<p>{
    my $_count = 0;
    sub get_count{$_count}
    sub _incr_count{++$_count}
}</p>

<p>sub new {
    my ($class, @arg) = @<em>;
    $class-&gt;_incr_count();
    bless{
        name =&gt; $</em>[1],
        singer =&gt; $<em>[2],
        album =&gt; $</em>[3],
        rating =&gt; $_[4],
    }, $class;
}</p>

<p>sub name{ $<em>[0] -&gt; {name} }
sub singer{ $</em>[0] -&gt; {singer} }
sub album{ $_[0] -&gt; {album} }</p>

<p>sub rating {
    my ($self, $rating) = @_;
    $self -&gt; {rating} = $rating if $rating;
}</p>

<p>package main;</p>

<p>my $cd = CD::Music-&gt;new(“谁的眼泪在飞”, “孟庭苇”, “谁的眼泪在飞”, 7);</p>

<p>print $cd-&gt;name, “\n”;</p>

<p>print $cd-&gt;singer.”\n”;</p>

<p>print $cd-&gt;album, “\n”;</p>

<p>print $cd-&gt;rating(8).”\n”;</p>

<p>print “There have been “, CD::Music-&gt;get_count(), “ CD[s] created\n”;
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Perl Chap02]]></title>
    <link href="http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap02/"/>
    <updated>2014-10-28T14:08:34+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap02</id>
    <content type="html"><![CDATA[<p>This is a note about chap02 in “Object oriented perl”.  </p>

<p>1.For a hash, we have two ways to get the key-value pair.  </p>

<p>```pl
my %hash = (
    steven =&gt; “good”,
    sun    =&gt; “bad”,
);</p>

<p>my $nextkey;</p>

<p>while (defined($nextkey = each %hash)){
    print “the key $nextkey has the value $hash{$nextkey}\n”;
}
```   </p>

<p>The other way is:  </p>

<p>```pl
my %hash = (
    steven =&gt; “good”,
    sun    =&gt; “bad”,
);</p>

<p>while (($nextkey, $nextval) = each %hash){
    print “the key $nextkey has value $nextval\n”;
}
```   </p>

<p>2.Subroutines can also be declared with a prototype, which is a series of specifiers that tells the compiler to restrict the type and number of arguments with which the subroutine may be invoked. For example, in the subroutine definition:  </p>

<p><code>pl
sub insensitive_less_than ($$) {
	return lc($_[0]) lt lc($_[1]);
}
</code>  </p>

<p>The prototype is <code>($$)</code> and specifies that the subroutine insensitive_less_than can only be called with exactly two arguments, each of which will be treated as a scalar—even if it’s actually an array!  </p>

<p>Prototypes are only enforced when a subroutine is called using the name(args) syntax. Prototypes are not enforced when a subroutine is called with a leading &amp; or through a subroutine reference.   </p>

<p>3.Here is a clear illustration of how to use reference in Perl:  </p>

<p>```pl
my @row1 = (1, 2, 3);
my @row2 = (4, 5, 6);
my @row3 = (7, 8, 9);</p>

<p>my @cols = (\@row1, \@row2, \@row3);
my $table = \@cols;</p>

<p>print “2 x 3 is “, $table-&gt;[1]-&gt;[2];
```  </p>

<p>4.Here is a script to realize the function of skipping along an array by a fixed step size. It uses anynymous soubroutine and closure.  </p>

<p>```pl
sub hop_along{
    my ($from, $to, $step) = @<em>;
    my $next = $from - $step;
    my $closure_ref = sub{
        $next += $step;
        return if $next &gt; $to;
        $</em>[0] = $next;
        return 1;
    };
    return $closure_ref;
}</p>

<p>$iterator = hop_along(1, 100, 7);
while($iterator-&gt;($next)){
    print $next.” “;
}
``` </p>

<p>The sad thing is, I am not sure if this is the best way to achieve the function.</p>
]]></content>
  </entry>
  
</feed>
