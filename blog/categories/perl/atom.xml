<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-10-29T14:29:28+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object Oriented Perl Chap03]]></title>
    <link href="http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap03/"/>
    <updated>2014-10-28T16:58:25+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap03</id>
    <content type="html"><![CDATA[<p>This is a note about chap03 in “Object oriented perl”.  </p>

<p>1.In object oriented perl, there are three rules,</p>

<p><code>pl
1. rule1: To create a class, build a package.   
2. rule2: To create a method, write a subroutine.
3. rule3: To create an object, bless a referent.
</code>    </p>

<p>2.Some cases while calling a method through an arrow:  </p>

<p><code>pl
$hsh_ref-&gt;{"key"};# Access the hash referred to by $hashref
$arr_ref-&gt;[$index];# Access the array referred to by $arrayref
$sub_ref-&gt;(@args);# Access the sub referred to by $subref
$obj_ref-&gt;method(@args);# Access the object referred to by $objref
</code>  </p>

<p>4.When a method like <code>Bug::print_me</code> is called, the argument list that it receives begins with the object reference through which it was called, followed by any arguments that were explicitly given to the method. That means that calling </p>

<p><code>pl
Bug::print_me("logfile")
</code> </p>

<p>is not the same as calling </p>

<p><code>pl
$nextbug-&gt;print_me("logfile")
</code></p>

<p>In the first case, print_me is treated as a regular subroutine so the argument list passed to <code>Bug::print_me</code> is equivalent to:</p>

<p><code>pl
( "logfile" )
</code>
In the second case, <code>print_me</code> is treated as a method so the argument list is equivalent to:   </p>

<p><code>pl
( $objref, "logfile" )
</code> 
Having a reference to the object passed as the first parameter is vital, because it means that the method then has access to the object on which it’s supposed to operate. Hence you’ll find that most methods in Perl start with something equivalent to this:   </p>

<p><code>pl
package Bug;
sub print_me{
	my ($self) = shift;
}
</code><br />
or better still:<br />
<code>pl
package Bug;
sub print_me{
	my ($self, @args) = @_;
}
</code><br />
This second version is better because it provides a lexically scoped copy of the argument list <code>(@args)</code>.   </p>

<p>5.Unlike other object-oriented languages, Perl doesn’t require that an object be a special kind of recordlike data structure. In fact, you can use any existing type of Perl variable—a scalar, an array, a hash—as an object in Perl.   </p>

<p>6.The <code>bless</code> function takes two arguments: a reference to the variable to be marked and a string containing the name of the class. It then sets an internal flag on the variable, indicating that it now belongs to the class.  </p>

<p>7.We didn’t bless the reference; we blessed the referent. The scalar didn’t change—only the nameless hash it refers to has been marked.   </p>

<p>8.You can check that the blessing succeeded by applying the built-in ref function to $nextbug. Normally, when <code>ref</code> is applied to a reference, it returns the type of that reference.  </p>

<p><code>pl
my $nextbug = {
    _id =&gt; "00001",
    _type =&gt; "fatal",
    _descr =&gt; "application does not compile"
};
bless $nextbug, "Bug";
print ref($nextbug);
</code>
THe above code gives out the result, <code>Bug</code>.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Perl Chap02]]></title>
    <link href="http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap02/"/>
    <updated>2014-10-28T14:08:34+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/28/object-oriented-perl-chap02</id>
    <content type="html"><![CDATA[<p>This is a note about chap02 in “Object oriented perl”.  </p>

<p>1.For a hash, we have two ways to get the key-value pair.  </p>

<p>```pl
my %hash = (
    steven =&gt; “good”,
    sun    =&gt; “bad”,
);</p>

<p>my $nextkey;</p>

<p>while (defined($nextkey = each %hash)){
    print “the key $nextkey has the value $hash{$nextkey}\n”;
}
```   </p>

<p>The other way is:  </p>

<p>```pl
my %hash = (
    steven =&gt; “good”,
    sun    =&gt; “bad”,
);</p>

<p>while (($nextkey, $nextval) = each %hash){
    print “the key $nextkey has value $nextval\n”;
}
```   </p>

<p>2.Subroutines can also be declared with a prototype, which is a series of specifiers that tells the compiler to restrict the type and number of arguments with which the subroutine may be invoked. For example, in the subroutine definition:  </p>

<p><code>pl
sub insensitive_less_than ($$) {
	return lc($_[0]) lt lc($_[1]);
}
</code>  </p>

<p>The prototype is <code>($$)</code> and specifies that the subroutine insensitive_less_than can only be called with exactly two arguments, each of which will be treated as a scalar—even if it’s actually an array!  </p>

<p>Prototypes are only enforced when a subroutine is called using the name(args) syntax. Prototypes are not enforced when a subroutine is called with a leading &amp; or through a subroutine reference.   </p>

<p>3.Here is a clear illustration of how to use reference in Perl:  </p>

<p>```pl
my @row1 = (1, 2, 3);
my @row2 = (4, 5, 6);
my @row3 = (7, 8, 9);</p>

<p>my @cols = (\@row1, \@row2, \@row3);
my $table = \@cols;</p>

<p>print “2 x 3 is “, $table-&gt;[1]-&gt;[2];
```  </p>

<p>4.Here is a script to realize the function of skipping along an array by a fixed step size. It uses anynymous soubroutine and closure.  </p>

<p>```pl
sub hop_along{
    my ($from, $to, $step) = @<em>;
    my $next = $from - $step;
    my $closure_ref = sub{
        $next += $step;
        return if $next &gt; $to;
        $</em>[0] = $next;
        return 1;
    };
    return $closure_ref;
}</p>

<p>$iterator = hop_along(1, 100, 7);
while($iterator-&gt;($next)){
    print $next.” “;
}
``` </p>

<p>The sad thing is, I am not sure if this is the best way to achieve the function.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use of Select in Perl]]></title>
    <link href="http://isunix.github.io/blog/2014/10/24/use-of-select-in-perl/"/>
    <updated>2014-10-24T13:34:51+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/24/use-of-select-in-perl</id>
    <content type="html"><![CDATA[<p>One of the best illustration of the use of select I read maybe from the book “data munging with perl”.   </p>

<p>Look at the the differences between the following 3 ones.  </p>

<p><code>pl
print;    
print LIST;
print FILEHANDLE LIST;
</code></p>

<p>For the first one “print”, since on target is specified, the contents of <code>$_</code> are printed to the default output file handle(usually STDOUT).    </p>

<p>For the second one “print LIST”, the contents of LIST are printed to the default output file handle.  </p>

<p>For the third one “print FILEHANDLE LIST”, the contents of LIST are printed to the specified file handle, “FILEHANDLE”.  </p>

<p>If you call select with no parameters, it will return the name of the currently selected output file handle, so </p>

<p><code>pl
print select; 
</code><br />
will normally print main::STDOUT.   </p>

<p>If you call select with the name of a file handle, it will replace the current default output file handle with the new one. It returns the previously selected file handle so that you can store it and reset it later. If you
need to write a lot of data to a particular file, you could use code like this:   </p>

<p><code>pl
open FILE, '&gt;out.txt' or die "Can't open out.txt: $!";
my $old = select FILE;
foreach (@data) {
	print;
}
select $old;
</code>    </p>

<p>Another variable that is useful when writing data is <code>$|</code>. Setting this variable to a nonzero value will force the output buffer to be flushed immediately after every print (or write) statement. This has the effect of making the output stream look as if it were unbuffered. This variable acts on the currently selected output file handle. If you want to unbuffer any other file handle, you will need to select it, change the value of <code>$|</code>, and then reselect the previous file handle using code like this:   </p>

<p><code>pl
my $file = select FILE;
$| = 1;
select $file;
</code>  </p>

<p>In its compact form, it can be written as:  </p>

<p><code>pl
select((select(FILE), $| = 1)[0]);
</code>   </p>

<p>Finally we will take a look at an example,  </p>

<p><code>pl
open(FILE,"&gt;./test.out");
$oldHandle = select(FILE);
print select;
print "This is sent to test.out.\n";
$second = select($oldHandle);
print "to default stdout!\n";
print $second;
</code>  </p>

<p>If you understand how “select” works, the output for this piece of code is quite obvious.  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Perl Script to Rename File Names]]></title>
    <link href="http://isunix.github.io/blog/2014/10/17/a-perl-script-to-rename-file-names/"/>
    <updated>2014-10-17T16:15:19+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/17/a-perl-script-to-rename-file-names</id>
    <content type="html"><![CDATA[<p>I have some files with file name quite weird in the format, “[Alex_Holmes]_Hadoop_in_Practice(BookZZ.org).pdf
“. What I want to achieve is removing the parts in the [] or ().  Here below is the perl script I wrote. </p>

<p>```pl
use strict;
use warnings;
use Data::Dumper;
use Cwd;</p>

<p>my $target_dir = getcwd();</p>

<table>
  <tbody>
    <tr>
      <td>opendir(my $dh, $target_dir)</td>
      <td> </td>
      <td>die “can’t opendir $target_dir: $!”;</td>
    </tr>
  </tbody>
</table>

<p>my @files = grep { /\w/ &amp;&amp; -f “$_” &amp;&amp; !/^./} readdir($dh);
# [Alex_Holmes]_Hadoop_in_Practice(BookZZ.org).pdf
#files not staring with “.” and contains char, thus (., .., .DS_STORE) will be ignored.
#print Dumper @files;</p>

<p>for(@files){
    my $file = $_;
    if(/^(?:[[\S\s]+])([\S\s]+)(?:([\S\s]+)).pdf$/){
        my $new_name = $1.”.pdf”;
        rename(“$file”, “$new_name”) || die(“error in renaming: $!”);
    }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl Bebugger Tips]]></title>
    <link href="http://isunix.github.io/blog/2014/10/16/perl-bebugger-tips/"/>
    <updated>2014-10-16T15:31:54+08:00</updated>
    <id>http://isunix.github.io/blog/2014/10/16/perl-bebugger-tips</id>
    <content type="html"><![CDATA[<p>Knowing how to debug a perl program is really important. I am saying this not simply because it is supposed to be so, but also because I have encountered several occasions where I am stucked because I do not know how to debug and I have to ask for help from others. </p>

<p>I am writing this post currently based on two perl pods, one is “perldebug”, the other is “perldebtut”. There is book named “perl debugged” which focuses on how to debug a perl program. Also google it to find post and materials as to how to debug a perl program. I am preparing to stuff all tips and knowledges regrading to perl debugging in this post.  </p>

<p>1.if we want to do a syntax check, we can use the following way:  </p>

<p><code>pl
perl -c hello
</code></p>

<p>2.The line shown is the one that is about to be executed next, it hasn’t happened yet. So while we can print a variable with the letter ‘p’, at this point all we’d get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an ‘s’. Then you can see the previous shown variable using the “p varname” format.  </p>

<p>3.type something like “x keys %data” will print out the data in a pretty format. </p>

<p><code>pl
Evals expr in list context, dumps the result or lists methods
</code>  </p>

<p>4.using the “x” operator on a hash is not quite useful here. since a couple of welcomes in there, but no indication of which are keys, and which are values, it’s just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a reference to the data structure:  </p>

<p><code>pl
x \%data
</code>  </p>

<p>5.Know the differences between “qw” and “q”: qw// is simply q// followed by a split on whitespace. No way to conserve blanks. Thus if the quoted words have blank spaces, and you want to treat them as a whole, use q rather than qw.  </p>

<p>5.perl -w script-name will execute the script and give out the warning messages.  </p>

<p>6.Take a closer look at the ‘x’ command, it’s really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it.   </p>

<p>7.If we want to start the debugger and want some form of input from STDIN, we give it something non-committal, a zero: </p>

<p><code>pl
perl -de 0	
or 
perl -de0
</code></p>

<p>8.typing “perl -de 0” into the terminal, build an on-the-fly object over a couple of lines (note the backslash):  </p>

<p><code>pl
DB&lt;1&gt; $obj = bless({'unique_id'=&gt;'123', 'attr'=&gt; \
cont: 	{'col' =&gt; 'black', 'things' =&gt; [qw(this that etc)]}}, 'MY_class')
</code></p>

<p>9.use the “x” command to see the internals of the obj. </p>

<p><code>pl
DB&lt;2&gt; x $obj
</code></p>

<p>10.To give more examples on using the “perl -de 0” command, I will just copy the code from the “perldebtut” pod page.  </p>

<p><code>pl
DB&lt;3&gt; @data = qw(this that the other atheism leather theory scythe)
DB&lt;4&gt; p 'saw -&gt; '.($cnt += map { print "\t:\t$_\n" } grep(/the/, sort @data))
</code></p>

<p>11.If you want to see the command History, type an ‘H’:</p>

<p><code>pl
DB&lt;5&gt; H
</code>  </p>

<p>12.And if you want to repeat any previous command, use the exclamation: ‘!’:  </p>

<p><code>pl
DB&lt;5&gt; !4
</code></p>

<p>13.If we want to put a breakpoint on a line, we can use this:  </p>

<p><code>pl
b linenum
</code>   </p>

<p>14.We can see what breakpoints are set by using the list ‘L’ command:  </p>

<p><code>pl
DB&lt;3&gt; L
</code>  </p>

<p>15.To delete a break point on a line, we use the “B” command. </p>

<p><code>pl
DB&lt;3&gt; B 16
</code></p>

<p>16.At the end of the tutorial, its recommended to refer to the following tutorials:  </p>

<p><code>
perldebug, perldebguts, perldiag, perlrun
</code>  </p>

<p>17.Option s and n does step by step execution of each statements. Option s steps into the subroutine. Option n executes the subroutine in a single step (stepping over it).</p>

<p>The s option does stepping into the subroutine while n option which would execute the subroutine(stepping over it).</p>

]]></content>
  </entry>
  
</feed>
