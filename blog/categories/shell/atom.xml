<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shell | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2017-09-14T10:22:51+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Weird Things Happen When Scripts Executing With . And Passing Args With Getopts]]></title>
    <link href="http://isunix.github.io/blog/2016/07/19/weird-things-happen-when-scripts-executing-with-and-passing-args-with-getopts/"/>
    <updated>2016-07-19T17:43:32+08:00</updated>
    <id>http://isunix.github.io/blog/2016/07/19/weird-things-happen-when-scripts-executing-with-and-passing-args-with-getopts</id>
    <content type="html"><![CDATA[<p>I have met the following scripts, say aa.sh</p>

<p>```sh
echo “OPTIND for aa.sh before calling is: “ $OPTIND
while getopts “t:c:” opt
do
    case “$opt” in
        t) time=”${OPTARG}”;;
        c) count=”${OPTARG}”;;
    esac
done</p>

<p>echo “time for aa.sh is $time”
echo “count for aa.sh is $count”
echo “OPTIND for aa.sh after calling is: “ $OPTIND<code>sh
</code>``</p>

<p>and bb.sh</p>

<p>```sh
echo “OPTIND for bb.sh before calling is: “ $OPTIND
echo “we are setting the OPTIND to 1”
while getopts “t:c:” opt
do
    case “$opt” in
        t) time=”${OPTARG}”;;
        c) count=”${OPTARG}”;;
    esac
done</p>

<p>echo “time for bb.sh is $time”
echo “count for bb.sh is $count”</p>

<p>echo “OPTIND for bb.sh after calling is: “ $OPTIND
```</p>

<p>and call.sh</p>

<p><code>sh
. ./aa.sh -t 2016-07-15 -c 4
. ./bb.sh -a 2016-07-20 -c 0
</code></p>

<p>and now execute the script, it will give out the followig result,</p>

<p><code>
OPTIND for aa.sh before calling is:  1
time for aa.sh is 2016-07-15
count for aa.sh is 4
OPTIND for aa.sh after calling is:  5
OPTIND for bb.sh before calling is:  5
=time for bb.sh is 2016-07-15
count for bb.sh is 4
OPTIND for bb.sh after calling is:  5
</code></p>

<p>Which is definitely not what we want.</p>

<p>We can now change bb.sh into the following to test it again.</p>

<p>```sh
echo “OPTIND for bb.sh before calling is: “ $OPTIND</p>

<p>OPTIND=1</p>

<p>echo “we are setting the OPTIND to 1”
while getopts “t:c:” opt
do
    case “$opt” in
        t) time=”${OPTARG}”;;
        c) count=”${OPTARG}”;;
    esac
done</p>

<p>echo “time for bb.sh is $time”
echo “count for bb.sh is $count”</p>

<p>echo “OPTIND for bb.sh after calling is: “ $OPTIND
```</p>

<p>and now “sh call.sh” will give out the following result,</p>

<p><code>
OPTIND for aa.sh before calling is:  1
time for aa.sh is 2016-07-15
count for aa.sh is 4
OPTIND for aa.sh after calling is:  5
OPTIND for bb.sh before calling is:  5
we are setting the OPTIND to 1
time for bb.sh is 2016-07-20
count for bb.sh is 0
OPTIND for bb.sh after calling is:  5
</code></p>

<p>What if we set the OPTIND to 3 now?</p>

<p><code>sh
OPTIND for aa.sh before calling is:  1
time for aa.sh is 2016-07-15
count for aa.sh is 4
OPTIND for aa.sh after calling is:  5
OPTIND for bb.sh before calling is:  5
we are setting the OPTIND to 3
time for bb.sh is 2016-07-15
count for bb.sh is 0
OPTIND for bb.sh after calling is:  5
</code></p>

<p>Now the count value is changed to 0, however time is still not changed.</p>

<p>How to understand this? First let us look at the definitions of $OPTIND and getopts</p>

<p><code>
A getopts construct usually comes packaged in a while loop, which processes the options and
arguments one at a time, then increments the implicit $OPTIND variable to point to the next.
</code></p>

<p>In a while loop contaning getopts, getopts will use $OPTIND to find the arguments. if we call the script using “dot” which is the same as using “source”, $OPTIND will be global and available to the next script using getopts, and the next script will then can not find the right argument using $OPTIND now. </p>

<p>The solution here is, we can reset $OPTIND to 1 or we can call the script using “sh” rather than “.”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Useful Shell Scripts]]></title>
    <link href="http://isunix.github.io/blog/2016/07/19/some-useful-shell-scripts/"/>
    <updated>2016-07-19T09:31:05+08:00</updated>
    <id>http://isunix.github.io/blog/2016/07/19/some-useful-shell-scripts</id>
    <content type="html"><![CDATA[<p>Here is a collection of those *sh commands I used that I think might be useful for later usage.</p>

<p>1.compare two directories and see if the differences between them.</p>

<p><code>sh
diff -urNa test test1
</code></p>

<p>2.find all files with “old” in their filename, and then romove them</p>

<p><code>sh
find ./ -name "*old*" -exec rm -i {} \;
</code></p>

<p>3.grep</p>

<p><code>sh
ll | grep "Jul 20" | awk '{print $NF}' | xargs -I , grep -i "Successfully" , | wc -l
</code></p>

<p>4.substitute string in multiple files and backup the orignal files with “~”</p>

<p><code>sh
find . | xargs grep "good" -sl | uniq | xargs perl -pi~ -e 's/good/bad/g'
</code></p>

<p>5.substitute string in multiple files and backup the orignal files with extension “bak”</p>

<p><code>sh
find . | xargs grep "bad" -sl | uniq | xargs perl -i.bak -p -e 's/bad/excellent/g'
</code></p>

<p>After checking that everything is ok, we can then remove those “bak” files</p>

<p><code>sh
find ./ -name "*bak*" -exec rm -i {} \;
</code></p>

<p>6.grep lines before and aftern certain matching line</p>

<p><code>sh
grep -C 4 '. $kpi_shell $load_date' orig_cron_kpi.sh  | grep "\.sh" | less
</code></p>

<p>7.grep lines in one file while not in the other.</p>

<p><code>sh
grep -F -x -v -f bb.txt aa.txt | grep "\.sh" | less
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎么去除windows编辑过的文件中的^M字符]]></title>
    <link href="http://isunix.github.io/blog/2016/07/18/zen-yao-qu-chu-windowsbian-ji-guo-de-wen-jian-zhong-de-mzi-fu/"/>
    <updated>2016-07-18T08:12:34+08:00</updated>
    <id>http://isunix.github.io/blog/2016/07/18/zen-yao-qu-chu-windowsbian-ji-guo-de-wen-jian-zhong-de-mzi-fu</id>
    <content type="html"><![CDATA[<p>We can use the following two methods to get rid of the “^M” character in a file which was edited on windows using vim.</p>

<p>1.</p>

<p><code>sh
:%s/\r//g
</code></p>

<p>2.</p>

<p><code>sh
:%s/ctrl-v ctrl-m//g
</code></p>

<p>The second one means pressing ctrl-v, then ctrl-m first.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tmux: Error While Loading Shared Libraries: libevent-2.0.so.5]]></title>
    <link href="http://isunix.github.io/blog/2016/07/12/tmux-error-while-loading-shared-libraries-libevent-2-dot-0-so-dot-5/"/>
    <updated>2016-07-12T10:34:50+08:00</updated>
    <id>http://isunix.github.io/blog/2016/07/12/tmux-error-while-loading-shared-libraries-libevent-2-dot-0-so-dot-5</id>
    <content type="html"><![CDATA[<p>I have kept a blog on tmux installation which is about missing module libevent, and the post is on:</p>

<p><code>html
http://isunix.github.io/blog/2014/12/24/libevent-not-found-error-while-install-tmux/
</code></p>

<p>Recently even after I install the livevent module, I still get the following errors after installing tmux and then running tmux:</p>

<p><code>
 ./tmux: error while loading shared libraries: libevent-2.0.so.5: cannot open shared object file: No such file or 
</code></p>

<p>I installed the libevent lib in $HOME/local/lib, and tmux says it can not find the library, Weird. With the help of one of my colleague, this problem is solved.</p>

<p><code>sh
export DIR="$HOME/local"
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$DIR/lib
./configure --prefix=$DIR CFLAGS="-I$DIR/include" LDFLAGS="-L$DIR/lib"
make
make install
</code></p>

<p>As we can see, the point here is setting the “LD_LIBRARY_PATH” variable.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Shell Commands]]></title>
    <link href="http://isunix.github.io/blog/2016/05/30/useful-shell-commands/"/>
    <updated>2016-05-30T16:13:41+08:00</updated>
    <id>http://isunix.github.io/blog/2016/05/30/useful-shell-commands</id>
    <content type="html"><![CDATA[<p>1.In bash shell, it provides us with two options to make debugging very much easier. “-v” and “-x”.</p>

<p>Take the following small script for an example.</p>

<p><code>sh
#!/bin/bash
echo "You are using $0"
echo "Hello $*"
exit 0
</code></p>

<p>If run with the follwoing “-v” option, </p>

<p><code>sh
bash -v aa.sh steven
</code></p>

<p>We will get the following result,</p>

<p><code>
#!/bin/bash
echo "You are using $0"
You are using aa.sh
echo "Hello $*"
Hello steven
exit 0
</code></p>

<p>If run with the “-x” option, we will get the following result.</p>

<p><code>
+ echo 'You are using aa.sh'
You are using aa.sh
+ echo 'Hello steven'
Hello steven
+ exit 0
</code></p>

<p>As we can see, “-x” might be more helpful to us.</p>

<p>2.We can use “read -p” to read from the user input and store the input into an variable. Like this:</p>

<p><code>sh
read -p "Enter your name: " name
echo $name
exit 0
</code></p>

<p>3.use the “-s” option with “read” to control the visibility of the entered text.</p>

<p><code>sh
#!/bin/bash
read -p "May I ask your name: " name
echo "Hello $name"
read -sn1 -p "Press any key to exit"
echo
exit 0
</code></p>

<p>4.Grep with “-c” option to list the number of items grepped.</p>
]]></content>
  </entry>
  
</feed>
