<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shell | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-12-25T18:09:29+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Libevent Not Found Error While Install Tmux]]></title>
    <link href="http://isunix.github.io/blog/2014/12/24/libevent-not-found-error-while-install-tmux/"/>
    <updated>2014-12-24T21:13:11+08:00</updated>
    <id>http://isunix.github.io/blog/2014/12/24/libevent-not-found-error-while-install-tmux</id>
    <content type="html"><![CDATA[<p>While I was installing tmux on cent-os, I met the error saying that “libevent not found”, something like this. Then I download libevent and install it into the location ‘/home/stsun/local’ dir.</p>

<p>Still I get the error saying that “libevent not found”. I solved the problem by the following way.</p>

<p><code>sh
DIR="$HOME/local"
./configure --prefix=$DIR CFLAGS="-I$DIR/include" LDFLAGS="-L$DIR/lib"
</code></p>

<p>Since I install libevent with the option, “–prefix=$HOME/local”.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Shell Scripting With Zsh]]></title>
    <link href="http://isunix.github.io/blog/2014/12/24/learning-shell-scripting-with-zsh/"/>
    <updated>2014-12-24T19:58:13+08:00</updated>
    <id>http://isunix.github.io/blog/2014/12/24/learning-shell-scripting-with-zsh</id>
    <content type="html"><![CDATA[<p>Zsh is more convenient than bash. I use this post to keep notes while I am studying the book “Learning Shell Scripting With Zsh”. </p>

<p>1.You can tell zsh to look for your configuration files in another folder by setting the parameter ZDOTDIR
to a directory of your choice in your .zshenv file under <code>$HOME</code>:
<code>perl
ZDOTDIR=/etc/my_kewl_folder/.zshrc
</code></p>

<p>2.Try to keep in mind the following order when setting preferences on your files:</p>

<p><code>perl
zshenv, zsh_profile, zshrc, zlogin
</code> </p>

<p>3.If zsh is not called as an interactive shell, zprofile and zshrc together with their counterparts in <code>(~/.zprofile and ~/.zshrc)</code> will not be sourced. In addition, if zsh is not called as a login shell, zlogin and <code>$HOME/.zlogin</code> will also be skipped.</p>

<p>4.<code>~/.zsh_profile</code>: This is the companion to <code>/etc/zsh_profile</code> and kind of the boring guy out of the startup files bunch. You should put here any scripts you want executed before <code>~/.zshrc</code>.  </p>

<p>5.<code>~/.zshrc</code>: This is your workhorse. Most of your user settings and shell preferences end up here. Keep in mind it’ll only be taken into account for interactive shells. As we’ll see later on, you can declutter and expand its reach by sourcing multiple files.  </p>

<p>6.<code>~/.zlogin</code>: This will be executed right after <code>~/.zshrc</code> and works pretty much like <code>~/.zsh_profile</code>, so you should put the scripts that you want called after your main startup file here.  </p>

<p>7.Parameter expansion
<code>perl
% foo=Hello
% echo "${foo}, world!"
</code>
8.command substitution
<code>perl
print $(which zsh)
print `which zsh`
</code>
9.arithmetic expansion
<code>perl
% echo $(( 5 + 4 ))
</code></p>

<p>10.brace expansion
<code>perl
echo picture.jp{eg,g}
touch log_00{1,2,3}.txt
touch log_{007..011}.nfo
</code><br />
or 
<code>perl
% foo=(A B C)
% bar=(1 2 3)
% echo $^foo-$^bar
</code>	</p>

<p>11.One of the ways zsh provides for you to access your history is via the so-called history expansion. This works whenever your input begins with the bang <code>!</code> special character. Like, 
<code>perl
!cat
</code>
12.The star works as a wildcard, allowing you to match any filenames, even if you provide no pattern at all:</p>

<p><code>perl
% echo *
</code>
This will list all file names in the current directory.</p>

<p>13.The question mark symbol works pretty much like the star, except it matches a single character instead of many.<br />
<code>perl
% echo *.??
script.sh
% echo main.?*
main.c main.o main.tmp
</code></p>

<p>14.You can use the square brackets construct to match a group of characters within a pattern. For example, you can use <code>[ML]*</code> to match any filename that starts with either an uppercase letter M or L.</p>

<p><code>perl
% ls
Log.log Main.rb README.md script.sh
% echo [ML]*
Log.log Main.rb
</code>
or</p>

<p><code>perl
% echo *.log_[1-9]
out.log_1 out.log_2 out.log_3
% echo [1-5M]*.*
Main.rb
</code></p>

<p>15.we can get the complement of a class via the caret <code>(^)</code> operator:
<code>perl
% echo *.[^o]
bindings.c bindings.h main.c
</code></p>

<p>16.Arguably, the most popular pattern out there is recursive searching. Accessible through the <code>**/</code> combination, this pattern tells zsh to perform a recursive search, starting from the current directory and working its way inwards along the directory tree.
<code>perl
% echo **/*.md
README.md brew/README.md git/README.md scripts/README.md zsh/README.md
% find **/*.md | xargs echo
</code></p>

<p>17.You can make the shell match any series of digits it encounters with the <code>&lt;-&gt;</code> special pattern. What makes this construct great though, is that it can match any series of digits without a length restriction , this is because the shell processes each digit independently and not as a whole integer.
<code>perl
% echo log_&lt;-&gt;.txt
</code>
What if we want those logfiles from 10 upwards? Zsh has you covered:</p>

<p><code>perl
% echo log_&lt;10-&gt;.txt
log_010.txt log_030.txt log_031.txt
</code>
As you can see, the <code>&lt;-&gt;</code> pattern can define a range with lower and upper bounds. Let’s try again, this time for files between 10 and 20:
<code>perl
% echo log_&lt;10-20&gt;.txt
log_010.txt
</code></p>

<p>18.revisit the caret <code>(^)</code> operator:
<code>perl
% echo b^*.o
bindings.c bindings.h
</code>
So basically, we’re telling the shell to expand that pattern so as to match the filenames that start with b but do not have an .o extension.</p>

<p>19.Similar to the caret operator’s second usage, the tilde <code>(~)</code> operator can be used to define a pattern that consists of a part that should match and a second part that shouldn’t:</p>

<p><code>perl
% ls
README.md README.txt bindings.c bindings.h bindings.o main.c main.o
% echo b*~*.o
bindings.c bindings.h
</code></p>

<p>20.add to the file <code>.zshrc</code>:
<code>perl
autoload zmv
</code>
to load the function “zmv”.</p>

<p>21.Z shell will load anything that belongs to its function path or <code>$fpath</code>, a series of directories that
contain the files with the functions required for completion.
<code>perl
% print -l $fpath
</code></p>

<p>22.Resouces on learning zsh
<code>perl
http://zsh.sourceforge.net/Intro/intro_toc.html
http://zshwiki.org/home/
http://grml.org/zsh/zsh-lovers.html
https://github.com/zsh-users
https://github.com/sorin-ionescu/prezto
http://explainshell.com/
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make Zsh the Default Shell Without Root Access]]></title>
    <link href="http://isunix.github.io/blog/2014/12/24/how-to-make-zsh-the-default-shell-without-root-access/"/>
    <updated>2014-12-24T19:01:06+08:00</updated>
    <id>http://isunix.github.io/blog/2014/12/24/how-to-make-zsh-the-default-shell-without-root-access</id>
    <content type="html"><![CDATA[<p>As depicted by the title, this post keeps notes on how to make zsh the default shell without root access. BTW, I am using oh-my-zsh configuration files.</p>

<p>In the .bash_profile, add the following lines,</p>

<p><code>sh
export SHELL=/bin/zsh
exec /bin/zsh -l
</code></p>

<p>Where zsh will be your own location of your zsh file.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Shell Scripts]]></title>
    <link href="http://isunix.github.io/blog/2014/11/10/notes-on-shell-scripts/"/>
    <updated>2014-11-10T16:40:55+08:00</updated>
    <id>http://isunix.github.io/blog/2014/11/10/notes-on-shell-scripts</id>
    <content type="html"><![CDATA[<p>While reading some of the scripts written by my colleagus, I found some usages to be quite tricky. Thus I keep a note of the usage here.</p>

<p>1.filename and extension parts</p>

<p><code>sh
echo `basename $PWD` # Basename of current working directory.
echo "${PWD##*/}" # Basename of current working directory.
echo
echo `basename $0` # Name of script.
echo $0 # Name of script.
echo "${0##*/}" # Name of script.
echo
filename=test.data
echo "${filename##*.}" # data
# Extension of filename.
</code>  </p>

<p>2.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Script to List All Methods in a Perl Module]]></title>
    <link href="http://isunix.github.io/blog/2014/09/25/bash-script-to-list-all-methods-in-a-perl-module/"/>
    <updated>2014-09-25T16:21:52+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/25/bash-script-to-list-all-methods-in-a-perl-module</id>
    <content type="html"><![CDATA[<p>In the post “Dynamicly Adding a Method to a Module”, I showed how to use a perl one-liner to list all the methods in a module.  </p>

<p>I will show how to do it in a shell script thus we can accept the module on the command line, </p>

<p><code>sh
#!/bin/bash
perl -e "use Data::Dumper; use $1; print Dumper \%$1::"
</code></p>

]]></content>
  </entry>
  
</feed>
