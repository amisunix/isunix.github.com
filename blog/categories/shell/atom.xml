<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shell | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2015-12-31T13:59:10+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Useful Awk Commands]]></title>
    <link href="http://isunix.github.io/blog/2015/12/21/useful-awk-commands/"/>
    <updated>2015-12-21T16:51:15+08:00</updated>
    <id>http://isunix.github.io/blog/2015/12/21/useful-awk-commands</id>
    <content type="html"><![CDATA[<p>The following blogs are referenced, </p>

<p><code>html
http://www.catonmat.net/blog/awk-one-liners-explained-part-one/
http://www.grymoire.com/Unix/Awk.html
</code></p>

<p>And I will list some of the commands I think might be useful for later usage here.</p>

<p>1.Print the total number of lines containing word “Regex”.</p>

<p><code>sh
cat file | awk '/Regex/ { n++ }; END { print n+0 }'
</code></p>

<p>2.Print every line with more than 4 fields.</p>

<p><code>sh
cat file | awk 'NF &gt; 4'
</code></p>

<p>3.Print every line where the value of the last field is greater than 4.</p>

<p><code>sh
cat file | awk '$NF &gt; 4'
</code></p>

<p>4.Convert Windows/DOS newlines (CRLF) to Unix newlines (LF) from Unix.</p>

<p><code>sh
cat file | awk '{ sub(/\r$/,""); print }'
</code></p>

<p>5.Convert Unix newlines (LF) to Windows/DOS newlines (CRLF) from Unix.</p>

<p><code>sh
cat file | awk '{ sub(/$/,"\r"); print }'
</code></p>

<p>6.Delete leading whitespace (spaces and tabs) from the beginning of each line (ltrim).</p>

<p><code>sh
cat file | awk '{ sub(/^[ \t]+/, ""); print }'
</code></p>

<p>7.Delete trailing whitespace (spaces and tabs) from the end of each line (rtrim).</p>

<p><code>sh
cat file | awk '{ sub(/[ \t]+$/, ""); print }'
</code></p>

<p>8.Delete both leading and trailing whitespaces from each line (trim).</p>

<p><code>sh
cat file | awk '{ gsub(/^[ \t]+|[ \t]+$/, ""); print }'
</code></p>

<p>9.Insert 5 blank spaces at beginning of each line.</p>

<p><code>sh
cat file | awk '{ sub(/^/, "     "); print }'
</code></p>

<p>10.Center all text on a 79-character width.</p>

<p><code>sh
cat file | awk '{ l=length(); s=int((79-l)/2); printf "%"(s+l)"s\n", $0 }'
</code></p>

<p>11.Substitute (find and replace) “foo” with “bar” on each line.</p>

<p><code>sh
cat file | awk '{ sub(/foo/,"bar"); print }'
</code></p>

<p>12.Substitute “foo” with “bar” only on lines that contain “baz”.</p>

<p><code>sh
cat file | awk '/baz/ { gsub(/foo/, "bar") }; { print }'
</code></p>

<p>13.Substitute “foo” with “bar” only on lines that do not contain “baz”.</p>

<p><code>sh
cat file | awk '!/baz/ { gsub(/foo/, "bar") }; { print }'
</code></p>

<p>14.Change “scarlet” or “ruby” or “puce” to “red”.</p>

<p><code>sh
cat file | awk '{ gsub(/scarlet|ruby|puce/, "red"); print}'
</code></p>

<p>15.Reverse order of lines (emulate “tac”).</p>

<p><code>sh
cat file | awk '{ a[i++] = $0 } END { for (j=i-1; j&gt;=0;) print a[j--] }'
</code></p>

<p>16.Swap first field with second on every line.</p>

<p><code>sh
cat file | awk '{ temp = $1; $1 = $2; $2 = temp; print }'
</code></p>

<p>17.Delete the second field on each line.</p>

<p><code>sh
cat file | awk '{ $2 = ""; print }'
</code></p>

<p>18.Print the fields in reverse order on every line.</p>

<p><code>sh
cat file | awk '{ for (i=NF; i&gt;0; i--) printf("%s ", $i); printf ("\n") }'
</code></p>

<p>19.Remove duplicate, consecutive lines (emulate “uniq”)</p>

<p><code>sh
cat file | awk 'a !~ $0; { a = $0 }'
</code></p>

<p>20.Remove duplicate, nonconsecutive lines.</p>

<p><code>sh
cat file | awk '!a[$0]++'
</code></p>

<p>21.Concatenate every 5 lines of input with a comma.</p>

<p><code>sh
cat file | awk 'ORS=NR%5?",":"\n"'
</code></p>

<p>22.Print only the lines that match a regular expression “/regex/” (emulates “grep”).</p>

<p><code>sh
cat file | awk '/regex/'
</code></p>

<p>23.Print only the lines that do not match a regular expression “/regex/” (emulates “grep -v”).</p>

<p><code>sh
cat file | awk '!/regex/'
</code></p>

<p>24.Print the line immediately before a line that matches “/regex/” (but not the line that matches itself).</p>

<p><code>sh
cat file | awk '/regex/ { print x }; { x=$0 }'
</code></p>

<p>25.Print the line immediately after a line that matches “/regex/” (but not the line that matches itself).</p>

<p><code>sh
cat file | awk '/regex/ { getline; print }'
</code></p>

<p>26.Print lines that match any of “AAA” or “BBB”, or “CCC”.</p>

<p><code>sh
cat file | awk '/AAA|BBB|CCC/'
</code></p>

<p>27.Print lines that contain “AAA” and “BBB”, and “CCC” in this order.</p>

<p><code>sh
cat file | awk '/AAA.*BBB.*CCC/'
</code></p>

<p>28.Print only the lines that are 65 characters in length or longer.</p>

<p><code>sh
cat file | awk 'length &gt; 64'
</code></p>

<p>29.Print a section of file from regular expression to end of file.</p>

<p><code>sh
cat file | awk '/regex/,0'
</code></p>

<p>30.Print lines 8 to 12 (inclusive).</p>

<p><code>sh
cat file | awk 'NR==8,NR==12'
</code></p>

<p>31.Print line number 52.</p>

<p><code>sh
cat file | awk 'NR==52'
</code></p>

<p>32.Print section of a file between two regular expressions (inclusive).</p>

<p><code>sh
cat file | awk '/Iowa/,/Montana/'
</code></p>

<p>33.Delete all blank lines from a file.</p>

<p><code>sh
cat file | awk NF
</code> </p>

<p>This one-liner uses the special NF variable that contains number of fields on the line. For empty lines, NF is 0, that evaluates to false, and false statements do not get the line printed.</p>

<p>34.Create a string of a specific length (generate a string of x’s of length 513).</p>

<p><code>sh
awk 'BEGIN { while (a++&lt;513) s=s "x"; print s }'
</code></p>

<p>35.Insert a string of specific length at a certain character position (insert 49 x’s after 6th char).</p>

<p><code>sh
gawk --re-interval 'BEGIN{ while(a++&lt;49) s=s "x" }; { sub(/^.{6}/,"&amp;" s) }; 1'
</code></p>

<p>36.Print all lines where 5th field is equal to “abc123”.
<code>sh
cat file | awk '$5 == "abc123"'
</code></p>

<p>37.Print any line where field #5 is not equal to “abc123”.</p>

<p><code>sh
cat file | awk '$5 != "abc123"'
</code></p>

<p>38.Print all lines whose 7th field matches a regular expression.</p>

<p><code>sh
cat file | awk '$7  ~ /^[a-f]/'
or 
cat file | awk '$7 !~ /^[a-f]/'
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun Shell Tricks]]></title>
    <link href="http://isunix.github.io/blog/2015/12/21/fun-shell-tricks/"/>
    <updated>2015-12-21T15:04:39+08:00</updated>
    <id>http://isunix.github.io/blog/2015/12/21/fun-shell-tricks</id>
    <content type="html"><![CDATA[<p>1.Print the 10 most frequent words in the input.</p>

<p><code>sh
cat * | tr -sc A-Za-z '\n' | sort | uniq -c | sort -n | tail
</code></p>

<p>Sadly this is not totally correct, it will give out something like:</p>

<p><code>
22 pl
38 d
</code></p>

<p>which are not exactly words.</p>

<p>2.use awk with substr:</p>

<p><code>sh
date | awk '{print substr($4, 1, 5)}'
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed One-liners]]></title>
    <link href="http://isunix.github.io/blog/2015/12/18/sed-one-liners/"/>
    <updated>2015-12-18T14:48:18+08:00</updated>
    <id>http://isunix.github.io/blog/2015/12/18/sed-one-liners</id>
    <content type="html"><![CDATA[<p>The following is a collection of sed. They are from the following blogs.</p>

<p>```html
http://www.catonmat.net/blog/sed-one-liners-explained-part-one/
http://www.catonmat.net/blog/sed-one-liners-explained-part-two/
http://www.catonmat.net/blog/sed-one-liners-explained-part-three/</p>

<p>http://www.grymoire.com/Unix/Sed.html
http://www.catonmat.net/blog/wp-content/uploads/2008/09/sed1line.txt
```</p>

<p>I will pick some I that I think might be useful for me and listed them here.</p>

<p>1.Insert a blank line above every line that matches “regex”.</p>

<p><code>sh
cat file | sed '/regex/{x;p;x;}'
</code></p>

<p>2.Insert a blank line below every line that matches “regex”.</p>

<p><code>sh
cat file | sed '/regex/G'
</code></p>

<p>3.Insert a blank line above and below every line that matches “regex”.</p>

<p><code>sh
cat file | sed '/regex/{x;p;x;G;}'
</code></p>

<p>4.Number each line of a file (named filename). Left align the number.</p>

<p><code>sh
sed = filename | sed 'N;s/\n/\t/'
</code></p>

<p>5.Convert DOS/Windows newlines (CRLF) to Unix newlines (LF). (All 3 have not been tested!)</p>

<p><code>sh
cat file | sed 's/.$//'
cat file | sed 's/^M$//'
cat file | sed 's/\x0D$//'
</code></p>

<p>6.Convert Unix newlines (LF) to DOS/Windows newlines (CRLF). (All 3 have not been tested!)</p>

<p><code>sh
sed 's/$/\r/'
sed "s/$//"
sed "s/$/`echo -e \\\r`/"
</code></p>

<p>7.Delete leading whitespace (tabs and spaces) from each line.</p>

<p><code>sh
cat file | sed 's/^[ \t]*//'
</code></p>

<p>8.Delete trailing whitespace (tabs and spaces) from each line.</p>

<p><code>sh
cat file | sed 's/[ \t]*$//'
</code></p>

<p>9.Delete both leading and trailing whitespace from each line.</p>

<p><code>sh
cat file | sed 's/^[ \t]*//;s/[ \t]*$//'
</code></p>

<p>10.Insert five blank spaces at the beginning of each line.</p>

<p><code>sh
cat file | sed 's/^/     /'
</code></p>

<p>11.Substitute (find and replace) the fourth occurrence of “foo” with “bar” on each line.</p>

<p><code>sh
cat file | sed 's/foo/bar/4'
</code></p>

<p>12.Substitute (find and replace) the first occurrence of a repeated occurrence of “foo” with “bar”.</p>

<p><code>sh
cat file | sed 's/\(.*\)foo\(.*foo\)/\1bar\2/'
</code></p>

<p>13.Substitute all occurrences of “foo” with “bar” on all lines that contain “baz”.</p>

<p><code>sh
cat file | sed '/baz/s/foo/bar/g'
</code></p>

<p>14.Substitute all occurrences of “foo” with “bar” on all lines that DO NOT contain “baz”.</p>

<p><code>sh
cat file | sed '/baz/!s/foo/bar/g'
</code></p>

<p>15.Change text “scarlet”, “ruby” or “puce” to “red”.</p>

<p><code>sh
cat file | sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'
</code></p>

<p>16.Add a blank line after every five lines.</p>

<p><code>sh
cat file | sed 'n;n;n;n;G;'
</code></p>

<p>17.Print the first 10 lines of a file (emulates “head -10”).</p>

<p><code>sh
cat file | sed 10q
</code></p>

<p>18.Print only the lines that match a regular expression (emulates “grep”).</p>

<p><code>sh
cat file | sed -n '/regexp/p'
</code></p>

<p>19.Print only the lines that do not match a regular expression (emulates “grep -v”).</p>

<p><code>sh
cat file | sed -n '/regexp/!p'
</code></p>

<p>20.Print the line immediately before regexp, but not the line containing the regexp.</p>

<p><code>sh
cat file | sed -n '/regexp/{g;1!p;};h'
</code></p>

<p>21.Print the line immediately after regexp, but not the line containing the regexp.</p>

<p><code>sh
cat file | sed -n '/regexp/{n;p;}'
</code></p>

<p>22.Print one line before and after regexp. Also print the line matching regexp and its line number. (emulates “grep -A1 -B1”).</p>

<p><code>sh
cat file | sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h
</code></p>

<p>23.Grep for “AAA” and “BBB” and “CCC” in any order.</p>

<p><code>sh
cat file | sed '/AAA/!d; /BBB/!d; /CCC/!d'
</code></p>

<p>24.Grep for “AAA” and “BBB” and “CCC” in that order.</p>

<p><code>sh
cat file | sed '/AAA.*BBB.*CCC/!d'
</code></p>

<p>25.Grep for “AAA” or “BBB”, or “CCC”.</p>

<p><code>sh
cat file | sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
</code></p>

<p>26.Print only the lines that are 65 characters in length or more.</p>

<p><code>sh
cat file | sed -n '/^.\{65\}/p'
</code></p>

<p>27.Print only the lines that are less than 65 chars.</p>

<p><code>sh
cat file | sed '/^.\{65\}/d'
</code></p>

<p>28.Print section of a file from a regex to end of file.</p>

<p><code>sh
cat file | sed -n '/regexp/,$p'
</code></p>

<p>29.Print lines 8-12 (inclusive) of a file.</p>

<p><code>sh
cat file | sed -n '8,12p'
</code></p>

<p>30.Print line number 52.</p>

<p><code>sh
cat file | sed -n '52p'
</code></p>

<p>31.Beginning at line 3, print every 7th line.</p>

<p><code>sh
cat file | sed -n '3,${p;n;n;n;n;n;n;}'
</code></p>

<p>32.Print section of lines between two regular expressions (inclusive).</p>

<p><code>sh
cat file | sed -n '/Iowa/,/Montana/p'
</code></p>

<p>33.Print all lines in the file except a section between two regular expressions.</p>

<p><code>sh
cat file | sed '/Iowa/,/Montana/d'
</code></p>

<p>34.Delete duplicate, consecutive lines from a file (emulates “uniq”).</p>

<p><code>sh
cat file | sed '$!N; /^\(.*\)\n\1$/!P; D'
</code></p>

<p>35.Delete all lines except duplicate consecutive lines (emulates “uniq -d”).</p>

<p><code>sh
cat file | sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'
</code></p>

<p>36.Delete the first 10 lines of a file.</p>

<p><code>sh
cat file | sed '1,10d'
</code></p>

<p>37.Delete the last line of a file.</p>

<p><code>sh
cat file | sed '$d'
</code></p>

<p>38.Delete the last 2 lines of a file.</p>

<p><code>sh
cat file | sed 'N;$!P;$!D;$d'
</code></p>

<p>39.Delete lines that match regular expression pattern.</p>

<p><code>sh
cat file | sed '/pattern/d'
</code></p>

<p>40.Delete all blank lines in a file (emulates “grep ‘.’”.</p>

<p><code>sh
cat file | sed '/^$/d'
</code></p>

<p>41.Delete all consecutive blank lines from a file (emulates “cat -s”).</p>

<p><code>sh
cat file | sed '/./,/^$/!d'
</code></p>

<p>42.Delete all leading blank lines at the top of a file.</p>

<p><code>sh
cat file | sed '/./,$!d'
</code></p>

<p>43.Delete all trailing blank lines at the end of a file.</p>

<p><code>sh
cat file | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grep Lines in One File and Not in the Other]]></title>
    <link href="http://isunix.github.io/blog/2015/12/14/grep-lines-in-one-file-and-not-in-the-other/"/>
    <updated>2015-12-14T14:46:10+08:00</updated>
    <id>http://isunix.github.io/blog/2015/12/14/grep-lines-in-one-file-and-not-in-the-other</id>
    <content type="html"><![CDATA[<p>Say we have a file a, which has the following contentL:</p>

<p><code>
a
b
c
d
e
</code></p>

<p>and b,</p>

<p><code>
c
d
</code></p>

<p>What if we want to get all those in file a and not in file b, in this case, a, b, e?</p>

<p><code>sh
grep -F -x -v -f b.txt a.txt
</code></p>

<p>To qutoe from the page</p>

<p><code>html
http://unix.stackexchange.com/questions/28158/is-there-a-tool-to-get-the-lines-in-one-file-that-are-not-in-another
</code></p>

<p>The above command is doing the following things:</p>

<p><code>
This works by using each line in b.txt as a pattern (-f b.txt) and treating it as a plain string to match (not a regular regex) (-F). You force the match to happen on the whole line (-x) and print out only the lines that don't match (-v). Therefore you are printing out the lines in a.txt that don't contain the same data as any line in b.txt.
</code></p>

<p>So remember the order of file a and b matters if you really understand what the command is doing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Most Used Shell Commands]]></title>
    <link href="http://isunix.github.io/blog/2015/11/02/the-most-used-shell-commands/"/>
    <updated>2015-11-02T16:21:57+08:00</updated>
    <id>http://isunix.github.io/blog/2015/11/02/the-most-used-shell-commands</id>
    <content type="html"><![CDATA[<p>We can use the following shell scripts to find the 10 most used shell commands for a user.</p>

<p><code>sh
history | awk '{a[$2]++} END {for(i in a) {print a[i]" "i}}'| sort -rn | head
</code></p>
]]></content>
  </entry>
  
</feed>
