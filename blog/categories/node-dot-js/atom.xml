<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Node.js | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/node-dot-js/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2015-12-08T16:25:25+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes on the Use of Module in node.js]]></title>
    <link href="http://isunix.github.io/blog/2014/08/08/notes-on-the-use-of-module-in-node-dot-js/"/>
    <updated>2014-08-08T17:11:27+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/08/notes-on-the-use-of-module-in-node-dot-js</id>
    <content type="html"><![CDATA[<ol>
  <li>
    <p>require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。  </p>
  </li>
  <li>
    <p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获
取模块的 exports 对象。   </p>
  </li>
  <li>
    <p>exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口.   </p>
  </li>
  <li>
    <p>Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>
  </li>
  <li>
    <p>following the following steps to create and publish a module. </p>
  </li>
</ol>

<ul>
  <li>mkdir stsunmodule  </li>
  <li>cd stsunmodule  </li>
  <li>npm init  (then answer all the questions as been prompted)    </li>
  <li>touch index.js   </li>
  <li>npm adduser  </li>
  <li>npm whoami  (use this command to test if your account is created successfully)   </li>
  <li>npm publish   </li>
</ul>

<p>then you can go to the site “https://search.npmjs.org” to check if your module is published successfully.<br />
You can also use “npm unpublish” to unpublish your module.  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Callback Function in node.js]]></title>
    <link href="http://isunix.github.io/blog/2014/08/08/callback-function-in-node-dot-js/"/>
    <updated>2014-08-08T16:03:41+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/08/callback-function-in-node-dot-js</id>
    <content type="html"><![CDATA[<p>Asynchronous IO in Node.js is very hard to understand. Here is one example from the book “Node.js开发指南”.  </p>

<p>```js </p>

<p>function readFileCallBack(err, data) {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
}</p>

<p>var fs = require(‘fs’);
fs.readFile(‘file.txt’, ‘utf-8’, readFileCallBack);
console.log(‘end.’);  </p>

<p>```  </p>

<p>When fs.readFile is called, it just sents the asynchronous I/O to the operating system, then it comes back and executes the statements following it. After that, it enters into the event loop to listen on the event. When fs accepts the event finished by the I/O request, the event loop will call the callback function to finish the following work.  </p>

<p>Thus in this case, we will see the “end.” first and then the contents of the file.txt.   </p>

<p>To understand how it works, it may help for us to get a basic knowledge of what is event. </p>

<p>Take the following code as an example.    </p>

<p>```js  </p>

<p>var EventEmitter = require(‘events’).EventEmitter;
var event = new EventEmitter();</p>

<p>event.on(‘some_event’, function(){
  console.log(‘some_event occured.’);
});</p>

<p>setTimeout(function () {
  event.emit(‘some_event’);
}, 1000);
```  </p>

<p>We will see that “some_event occurred” appeares on the console. It is because event object registes a listener on the event some_event, we sent to “event” object the event some_event after a second(1000 ms) through setTimeout, it then will call the listener on some_event and the function is executed.   </p>

<p>Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。</p>

<p>与其他语言不同的是，Node.js 没有显式的事件循环，类似 Ruby 的 EventMachine::run()的函数在 Node.js 中是不存在的。Node.js 的事件循环对开发者不可见，由 libev 库实现。libev支持多种类型的事件，如 ev_io、ev_timer、ev_signal、ev_idle 等，在 Node.js 中均被EventEmitter 封装。libev 事件循环的每一次迭代，在 Node.js 中就是一次 Tick，libev 不断检查是否有活动的、可供检测的事件监听器，直到检测不到时才退出事件循环，进程结束。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node Express Upgrade With Modules Deprecated]]></title>
    <link href="http://isunix.github.io/blog/2014/08/08/node-express-upgrade-with-modules-deprecated/"/>
    <updated>2014-08-08T15:17:47+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/08/node-express-upgrade-with-modules-deprecated</id>
    <content type="html"><![CDATA[<p>The “express” web application framework for node updates termly. Thus some of the apis may not be usable after a while. Here below are some of the apis deprecated between version2.5.2 and version4.8.2.   </p>

<p>```js</p>

<p><code>express.createServer()</code> - it has been deprecated for a long time. Use <code>express()</code> </p>

<p>deprecate <code>connect.createServer()</code> – use <code>connect()</code> instead</p>

<p>deprecate <code>.createServer()</code> &amp; remove old stale examples</p>

<p>Added <code>express.createServer()</code> for BC</p>

<p>Fixed for middleware stacked via <code>createServer()</code></p>

<p>previously the <code>foo</code> middleware passed to <code>createServer(foo)</code> </p>

<p>express.bodyParser() will have to be installed separately.</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
