<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[catogories：Data&ML&AI | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/data-and-ml-and-ai/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2019-07-30T10:44:31+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python中从ndarray或者DataFrame里获取数据和标签]]></title>
    <link href="http://isunix.github.io/blog/2019/07/23/pythonzhong-cong-ndarrayhuo-zhe-dataframeli-huo-qu-shu-ju-he-biao-qian/"/>
    <updated>2019-07-23T11:27:22+08:00</updated>
    <id>http://isunix.github.io/blog/2019/07/23/pythonzhong-cong-ndarrayhuo-zhe-dataframeli-huo-qu-shu-ju-he-biao-qian</id>
    <content type="html"><![CDATA[<p>如果我们有一个ndarray, 最后一列是label，前面几列是data, 我们可以通过如下的方式去获取数据(假如我们有9列):</p>

<p><code>
X = dataset[:,0:-1] or X = dataset[:,0:8]
Y = dataset[:,8]
</code></p>

<p>如果我们有个DataFrame, 我们可以通过如下的方式去获取:</p>

<p><code>
X, y = data.iloc[:,:-1], data.iloc[:,-1]
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[机器学习的流程图]]></title>
    <link href="http://isunix.github.io/blog/2019/07/07/ji-qi-xue-xi-de-liu-cheng-tu/"/>
    <updated>2019-07-07T07:32:15+08:00</updated>
    <id>http://isunix.github.io/blog/2019/07/07/ji-qi-xue-xi-de-liu-cheng-tu</id>
    <content type="html"><![CDATA[<p>下面的机器学习的一个流程图是从某视频中看到的，现在记录如下:</p>

<p>{% img /images/sun/machine_learning_flow.001.jpeg %}</p>

<p>虽然说会的不难， 但是里面的每一步都很艰辛。比如被很多人认为脏活累活的”加载预处理数据集”这块，这个大家实践下来的基本共识是，这块就占了整个机器学习流程的60%到80%的工作量。所以，不要心存美好幻想，觉得机器学习或者人工智能是多么高大上和美好的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R语言的一些记录]]></title>
    <link href="http://isunix.github.io/blog/2019/07/05/ryu-yan-de-%5B%3F%5D-xie-ji-lu/"/>
    <updated>2019-07-05T08:00:01+08:00</updated>
    <id>http://isunix.github.io/blog/2019/07/05/ryu-yan-de-[?]-xie-ji-lu</id>
    <content type="html"><![CDATA[<p>在R语言中，如果我们有一个<code>vector</code> 叫 <code>x</code>, <code>x</code> 的值中有 <code>NA</code>，如果我们想要过滤掉 <code>x</code> 中的 <code>NA</code>, 并把过滤后的结果，赋值给变量 <code>y</code>， 可以如下操作:</p>

<p><code>r
y &lt;- x[!is.na(x)]
</code></p>

<p>如果我们再想找出 <code>y</code> 中元素大于0的元素，可以如下操作L:</p>

<p><code>r
y[y &gt; 0]
</code></p>

<p>以上两步合在一起，可以如下操作:</p>

<p><code>r
x[!is.na(x) &amp; x &gt; 0]
</code></p>

<p>如果我们直接使用 <code>x[x &gt; 0]</code> 是不行的，会得到如下的包含<code>NA</code> 值的一个 <code>vector</code>:</p>

<p><code>
 NA        NA 0.3488261        NA 2.4099262        NA        NA        NA        NA        NA 0.4626879
</code></p>

<p>创建一个4行5列的<code>matrix</code>，包含的数值是从1到20，</p>

<p><code>r
my_matrix &lt;- matrix(data=1:20, nrow = 4, ncol = 5)
</code></p>

<p>如果我想给这个<code>matrix</code>的每行添加一列，作为名字，可以采用如下的方式</p>

<p><code>r
patients &lt;- c("Bill", "Gina", "Kelly", "Sean")
cbind(patients, my_matrix)
</code></p>

<p>但是上面这种方式，会导致<code>implicit coercion</code>, 把数字变成字符，为了解决这个问题，我们可以使用如下的方式</p>

<p><code>r
my_data &lt;- data.frame(patients, my_matrix)
</code></p>

<p>如果我们再想给每个列增加一个<code>name</code>, 可以使用如下的方式:</p>

<p><code>r
cnames &lt;- c("patient", "age", "weight", "bp", "rating", "test")
colnames(my_data) &lt;- cnames
</code></p>

<p>如果我们想要获取当前的工作目录,</p>

<p><code>r
getwd()
</code></p>

<p>如果我们想要切换到另外一个目录，可以</p>

<p><code>r
setwd("~/data/ISLR")
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据分析和机器学习一些摘抄]]></title>
    <link href="http://isunix.github.io/blog/2019/07/04/shu-ju-fen-xi-he-ji-qi-xue-xi-%5B%3F%5D-xie-zhai-chao/"/>
    <updated>2019-07-04T18:24:50+08:00</updated>
    <id>http://isunix.github.io/blog/2019/07/04/shu-ju-fen-xi-he-ji-qi-xue-xi-[?]-xie-zhai-chao</id>
    <content type="html"><![CDATA[<ul>
  <li>怎么对待缺失值</li>
</ul>

<p><code>Missing values play an important role in statistics and data analysis. Often, missing values must not be ignored, but rather they should be carefully
| studied to see if there's an underlying pattern or cause for their missingness.</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Numpy的一些数据处理备忘]]></title>
    <link href="http://isunix.github.io/blog/2019/07/04/numpyde-%5B%3F%5D-xie-shu-ju-chu-li-bei-wang/"/>
    <updated>2019-07-04T11:43:34+08:00</updated>
    <id>http://isunix.github.io/blog/2019/07/04/numpyde-[?]-xie-shu-ju-chu-li-bei-wang</id>
    <content type="html"><![CDATA[<h2 id="numpy">记录numpy中的一些数据处理的方法.</h2>

<ul>
  <li>比如我们通过如下的方式，获取到了iris的数据,</li>
</ul>

<p>```py
import pandas as pd
import numpy as np
from sklearn.datasets import load_iris</p>

<p>iris = load_iris()
df = pd.DataFrame(iris.data, columns=iris.feature_names)</p>

<p>df.columns = [‘sepal length’, ‘sepal width’, ‘petal length’, ‘petal width’, ‘label’]
```</p>

<p>A. 如果我们想要去取第一列，第二列，和最后一列(label), 可以使用如下的方式:</p>

<p><code>py
data = np.array(df.iloc[:100, [0, 1, -1]])
</code></p>

<p><code>df.shape</code> 是 <code>(150, 5)</code>, <code>data.shape</code> 是 <code>(100, 3)</code></p>

<p><code>data</code> 现在是<code>lists in list</code> 的一个<code>ndarray</code></p>

<p>B. 如果我们想要去取<code>data</code>的每行的前两列， 还有最后一列，可以使用如下的方式:</p>

<p><code>py
X, y = data[:, :-1], data[:, -1]
</code></p>

<p><code>X, y</code> 都是 ndarray. <code>x.shape</code> 是 <code>(100, 2)</code>, <code>y.shape</code> 是 <code>(100,)</code></p>

<p>C. 如果要对标签进行二分类，我们可以使用 python 的 list comprehension:</p>

<p><code>py
y = np.array([1 if i == 1 else -1 for i in y])
</code></p>

<p>这样处理了之后，y 的 shape 还是跟之前是一样的.</p>

<ul>
  <li>如果我们又一个ndarray, <code>an_ndarray = np.array([[11,12,13,14], [21,22,23,24], [31,32,33,34]])</code></li>
</ul>

<p><code>row_rank1 = an_array[1, :]</code> 和 <code>row_rank2 = an_array[1:2, :]</code> 将会给出不同的结果，可以输出来看看有啥不同， 这个很重要.</p>

<ul>
  <li>我们也可以使用如下的方式，对array中的元素进行判断</li>
</ul>

<p><code>py
an_ndarray = np.array([[11,12], [21, 22], [31, 31]])
bigger_than_fifteen = (an_array &gt; 15)
an_ndarray[bigger_than_fifteen]
</code></p>

<p>或者我们也可以直接如下操作:</p>

<p><code>py
an_ndarray[(an_ndarray &gt; 15)]
</code></p>

<ul>
  <li>下面是针对上面的<code>an_ndarray</code>进行的一些数学操作</li>
</ul>

<p>```py
# 求各个元素的均值
an_ndarray.mean()</p>

<h1 id="section">求每行的均值</h1>
<p>an_ndarray.mean(axis=1)</p>

<h1 id="section-1">求每列的均值</h1>
<p>an_ndarray.mean(axis=0)</p>

<h1 id="section-2">求所有元素的和</h1>
<p>an_ndarray.sum()</p>

<h1 id="section-3">求每行的中位数</h1>
<p>np.median(an_ndarray, axix=1)</p>

<h1 id="section-4">求每列的中位数</h1>
<p>np.median(an_ndarray, axix=0)</p>

<h1 id="unique">想要找到unique的元素</h1>
<p>np.unique(an_ndarray)</p>

<h1 id="section-5">下面是一些集合的操作</h1>
<p>s1 = np.array([‘desk’,’chair’,’bulb’])
s2 = np.array([‘lamp’,’bulb’,’chair’])
(s1, s2)</p>

<h1 id="s1--s2-">s1 和 s2 交集</h1>
<p>np.intersect1d(s1, s2)</p>

<h1 id="s1--s2--1">s1 和 s2 去重并集</h1>
<p>np.union1d(s1, s2)</p>

<h1 id="s1s2">在s1然后不在s2中的元素</h1>
<p>np.setdiff1d(s1, s2)</p>

<h1 id="s1s2-1">判断s1中的元素是不是在s2中</h1>
<p>np.in1d(s1, s2)
```</p>

<ul>
  <li>
    <p>广播
最好的操作方式是能打印出来看看长啥样.</p>
  </li>
  <li>
    <p>文件的存取</p>
  </li>
</ul>

<p>```py
x = np.array([ 23.23, 24.24])
np.save(‘an_array’, x)
np.load(‘an_array.npy’)</p>

<p>np.savetxt(‘array.txt’, X=x, delimiter=’,’)
np.loadtxt(‘array.txt’, delimiter=’,’)
```</p>

<ul>
  <li>拼接数据集</li>
</ul>

<p>```py
K = np.random.randint(low=2,high=50,size=(2,2))
M = np.random.randint(low=2,high=50,size=(2,2))</p>

<p>np.vstack((K,M))
np.hstack((K,M))</p>

<p>np.concatenate([K, M], axis = 0)
np.concatenate([K, M.T], axis = 1)</p>

<h1 id="vstack--hstack---">vstack 和 hstack 和  最下面的两种方式是等价的</h1>
<p>```</p>
]]></content>
  </entry>
  
</feed>
