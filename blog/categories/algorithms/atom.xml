<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2019-05-23T08:52:45+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[顺序栈和链栈的c语言实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian/"/>
    <updated>2014-08-19T21:29:35+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian</id>
    <content type="html"><![CDATA[<p>1.sequence stack </p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 顺序栈结构 <em>/
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /</em> 用于栈顶指针 */
}SqStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S <em>/
Status InitStack(SqStack *S)
{
        /</em> S.data=(SElemType <em>)malloc(MAXSIZE</em>sizeof(SElemType)); */
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(SqStack *S)
{
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(SqStack S)
{
        if (S.top==-1)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(SqStack S)
{
        return S.top+1;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(SqStack S,SElemType *e)
{
        if (S.top==-1)
                return ERROR;
        else
                *e=S.data[S.top];
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /</em> 栈满 <em>/
        {
                return ERROR;
        }
        S-&gt;top++;				/</em> 栈顶指针增加一 <em>/
        S-&gt;data[S-&gt;top]=e;  /</em> 将新插入元素赋值给栈顶空间 */
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top];	/</em> 将要删除的栈顶元素赋值给e <em>/
        S-&gt;top–;				/</em> 栈顶指针减一 */
        return OK;
}</p>

<p>/* 从栈底到栈顶依次对栈中每个元素显示 */
Status StackTraverse(SqStack S)
{
        int i;
        i=0;
        while(i&lt;=S.top)
        {
                visit(S.data[i++]);
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        SqStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));</p>

<pre><code>    return 0; } ```  
</code></pre>

<p>2.Linked stack</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 链栈结构 <em>/
typedef struct StackNode
{
        SElemType data;
        struct StackNode *next;
}StackNode,</em>LinkStackPtr;</p>

<p>typedef struct
{
        LinkStackPtr top;
        int count;
}LinkStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S */
Status InitStack(LinkStack *S)
{
        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
        if(!S-&gt;top)
                return ERROR;
        S-&gt;top=NULL;
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(LinkStack *S)
{
        LinkStackPtr p,q;
        p=S-&gt;top;
        while(p)
        {
                q=p;
                p=p-&gt;next;
                free(q);
        }
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(LinkStack S)
{
        if (S.count==0)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(LinkStack S)
{
        return S.count;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(LinkStack S,SElemType *e)
{
        if (S.top==NULL)
                return ERROR;
        else
                *e=S.top-&gt;data;
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(LinkStack *S,SElemType e)
{
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s-&gt;data=e;
        s-&gt;next=S-&gt;top;	/</em> 把当前的栈顶元素赋值给新结点的直接后继 <em>/
        S-&gt;top=s;         /</em> 将新的结点s赋值给栈顶指针 */
        S-&gt;count++;
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(</em>S))
                return ERROR;
        <em>e=S-&gt;top-&gt;data;
        p=S-&gt;top;					/</em> 将栈顶结点赋值给p <em>/
        S-&gt;top=S-&gt;top-&gt;next;    /</em> 使得栈顶指针下移一位，指向后一结点 <em>/
        free(p);                    /</em> 释放结点p */
        S-&gt;count–;
        return OK;
}</p>

<p>Status StackTraverse(LinkStack S)
{
        LinkStackPtr p;
        p=S.top;
        while(p)
        {
                 visit(p-&gt;data);
                 p=p-&gt;next;
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        LinkStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates From an Unsorted Linked List]]></title>
    <link href="http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list/"/>
    <updated>2014-08-18T15:12:52+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list</id>
    <content type="html"><![CDATA[<p>Write code to remove duplicates from an unsorted linked list.</p>

<p>FOLLOW UP</p>

<p>How would you solve this problem if a temporary buffer is not allowed?  </p>

<p>```cpp
#include <iostream>
#include <cstring>
using namespace std;</cstring></iostream></p>

<p>typedef struct node{
    int data;
    node *next;
}node;
bool myhash[100];</p>

<p>node* init(int a[], int n){
    node *head, *p;
    for(int i=0; i&lt;n; ++i){
        node *nd = new node();
        nd-&gt;data = a[i];
        if(i==0){
            head = p = nd;
            continue;
        }
        p-&gt;next = nd;
        p = nd;
    }
    return head;
}
void removedulicate(node *head){
    if(head==NULL) return;
    node *p=head, *q=head-&gt;next;
    myhash[head-&gt;data] = true;
    while(q){
        if(myhash[q-&gt;data]){
            node *t = q;
            p-&gt;next = q-&gt;next;
            q = p-&gt;next;
            delete t;
        }
        else{
            myhash[q-&gt;data] = true;
            p = q; q = q-&gt;next;
        }
    }
}
void removedulicate1(node *head){
    if(head==NULL) return;
    node *p, *q, *c=head;
    while(c){
        p=c; q=c-&gt;next;
        int d = c-&gt;data;
        while(q){
            if(q-&gt;data==d){
                node *t = q;
                p-&gt;next = q-&gt;next;
                q = p-&gt;next;
                delete t;
            }
            else{
                p = q; q = q-&gt;next;
            }
        }
        c = c-&gt;next;
    }
}
void print(node *head){
    while(head){
        cout«head-&gt;data«” ”;
        head = head-&gt;next;
    }
    cout«endl;
}
int main(){
    int n = 10;
    int a[] = {
        3, 2, 1, 3, 5, 6, 2, 6, 3, 1
    };
    memset(myhash, false, sizeof(myhash));
    node *head = init(a, n);
    removedulicate1(head);
    print(head);
    return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Python to Implement a Stack]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack/"/>
    <updated>2014-08-14T10:53:40+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack</id>
    <content type="html"><![CDATA[<p>In this post, we are going to implement a stack using Python. We are gonna do it using two ways. The first is by pushing to the end of the list, and pop out the rightmost item. The second is by “pushing” to the leftmost and pop out the leftmost item.  </p>

<ol>
  <li>push to the end  </li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

def push(self, item):
    self.items.append(item)

def pop(self):
    return self.items.pop()

'''
returns the top item from the stack but does not remove it.
It needs no parameters.
The stack is not modified.
'''
def peek(self):
    return self.items[len(self.items) - 1]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
print (s.is_empty())
s.push(4)
s.push(‘dog’)
print (s.peek())
print(“\n”)
print (s.peek())
s.push(True)
print (s.size())
print (s.is_empty())
s.push(8.4)
print (s.pop())
print (s.pop())
print (s.size())
```  </p>

<ol>
  <li>push to the front end</li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

#push, inserting at the front end.
def push(self, item):
    self.items.insert(0, item)

#pop out the leftest item.
def pop(self):
    return self.items.pop(0)

def peek(self):
    return self.items[0]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
s.push(‘hello’)
s.push(‘true’)
print(s.pop())
print (s.pop())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Tips Using Java to Practice Algorithms]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms/"/>
    <updated>2014-08-14T10:07:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms</id>
    <content type="html"><![CDATA[<p>There are common structues and tips while practicing algorithms and data structueres using java. I will try to keep them down in this post.   </p>

<p>1.hash tables  </p>

<p><code>java
public HashMap&lt;Integer, Student&gt; buildMap(Student[] students) {
  HashMap&lt;IntegerJ Student&gt; map = new HashMap&lt;Integer, Student&gt;();
    for (Student s : students) map.put(s.getld(), s);
    return map;
}
</code> </p>

<p>2.ArrayList(Dinamically Resizing Array) </p>

<p><code>java
public ArrayList&lt;String&gt; merge(String[] words, String[] more) {
  ArrayList&lt;String&gt; sentence = new Arrayl_ist&lt;String&gt;();
  for (String w : words) sentence.add(w);
  for (String w : more) sentence.add(w);
  return sentence;
}
</code>   </p>

<p>3.StringBuffer   </p>

<p><code>java
public String joinWords(String[] words){
  StringBuffer sentence = new StringBuffer();
  for (String w : words){
    sentence.append(w);
  }
  return sentence.toString();
}
</code>  </p>

<p>4.LinkedList  </p>

<p>```java<br />
class Node {
  Node next = null;
  int data;</p>

<p>public Node(int d) {
  data = d;
  }</p>

<p>void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while (n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```  </p>

<p>5.Deleting a node from a singly linkes list.  </p>

<p>```java
Node deleteNode(Node head, int d) {
  Node n = head;</p>

<p>if (n.data == d) {
    return head.next; /* moved head */
  }</p>

<p>while (n.next 1= null) {
    if (n.next.data == d) {
      n.next = n.next.next;
      return head; /* head didn’t change */
    }
    n = n.next;
  }
  return head;
}
```  </p>

<p>6.Implementing a stack</p>

<p>```java
class Stack {
  Node top;</p>

<p>Object pop() {
    if(top != null) {
      Object item = top.data;
      p = top.next;
      return item;
    }
    return null;
  }</p>

<p>void push(0bject item) {
    Node t = new Node(item);
    next = top;
    top = t;
  }</p>

<p>Object peek() {
    return top.data;
  }
}
```  </p>

<p>7.Implementing a queue.  </p>

<p>```java<br />
class Queue {
  Node first, last;</p>

<p>void enqueue(0bject item) {
    if(first == null) {
      last = new Node(item);
      first = last;
      } else {
        last.next = new Node(item);
        last = last.next;
      }
  }</p>

<p>Object dequeueQ {
    if (first != null) {
      Object item = first.data;
      first = first.next;
      return item;
    }
    return null;
  }
}
```</p>

<p>8.pseudocode to implement DFS</p>

<p><code>java
void search(Node root) {
  if (root == null) return;
  visit(root);
  root.visited = true;
  foreach (Node n in root.adjacent) {
    if (n.visited == false) {
      search(n);
    }
  }
}
</code>  </p>

<p>9.BFS.</p>

<p>```java
void search(Node root) {
  Queue queue = new QueueQ;
  root.visited = true;
  visit(root);
  queue.enqueue(root); // Add to end of queue</p>

<p>while (!queue.isEmpty()) {
    Node r = queue.dequeueQ; // Remove from front of queue
    foreach (Node n in r.adjacent) {
      if (n.visited == false) {
        visit(n);
        n.visited = true;
        queue.enqueue(n);
      }
    }
  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树遍历的递归与非递归实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/13/er-cha-shu-bian-li-de-di-gui-yu-fei-di-gui-shi-xian/"/>
    <updated>2014-08-13T11:00:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/13/er-cha-shu-bian-li-de-di-gui-yu-fei-di-gui-shi-xian</id>
    <content type="html"><![CDATA[<p>Just as is depicted by the title, in this post, we are going to realize the recursive traversing and non-recursive traveersing of a binary tree.   </p>

<p>First we will show the recursive one. This example is from the book ‘大话数据结构’.</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0</p>

<h1 id="define-maxsize-100---">define MAXSIZE 100 /* 存储空间初始分配量 */</h1>
<p>#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */</p>

<p>typedef int Status;		/* Status是函数的类型,其值是函数结果状态代码，如OK等 <em>/
typedef int TElemType;  /</em> 树结点的数据类型，目前暂定为整型 <em>/
typedef TElemType SqBiTree[MAX_TREE_SIZE]; /</em> 0号单元存储根结点  */  </p>

<p>typedef struct
{
	int level,order; /* 结点的层,本层序号(按满二叉树计算) */
}Position;</p>

<p>TElemType Nil=0; /*  设整型以0为空 */</p>

<p>Status visit(TElemType c)
{
	printf(“%d “,c);
	return OK;
}  </p>

<p>/* 构造空二叉树T。因为T是固定数组，不会改变，故不需要&amp; <em>/
Status InitBiTree(SqBiTree T)
{
	int i;
	for(i=0;i&lt;MAX_TREE_SIZE;i++)
		T[i]=Nil; /</em> 初值为空 */
	return OK;
}  </p>

<p>/* 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T */
Status CreateBiTree(SqBiTree T)
{
	int i=0;
 	printf(“请按层序输入结点的值(整型)，0表示空结点，输999结束。结点数≤%d:\n”,MAX_TREE_SIZE);
	while(i&lt;10)
	{
		T[i]=i+1;</p>

<pre><code>	if(i!=0&amp;&amp;T[(i+1)/2-1]==Nil&amp;&amp;T[i]!=Nil) /* 此结点(不空)无双亲且不是根 */
	{
		printf("出现无双亲的非根结点%d\n",T[i]);
		exit(ERROR);
	}
	i++;
}
while(i&lt;MAX_TREE_SIZE)
{
	T[i]=Nil; /* 将空赋值给T的后面的结点 */
	i++;
}

return OK; }
</code></pre>

<h1 id="define-clearbitree-initbitree---">define ClearBiTree InitBiTree /* 在顺序存储结构中，两函数完全一样 */</h1>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果: 若T为空二叉树,则返回TRUE,否则FALSE <em>/
Status BiTreeEmpty(SqBiTree T)
{
	if(T[0]==Nil) /</em> 根结点为空,则树空 */
		return TRUE;
	else
		return FALSE;
}</p>

<p>/* 初始条件: 二叉树T存在。操作结果: 返回T的深度 <em>/
int BiTreeDepth(SqBiTree T)
{
   int i,j=-1;
   for(i=MAX_TREE_SIZE-1;i&gt;=0;i–) /</em> 找到最后一个结点 <em>/
     if(T[i]!=Nil)
       break;
   i++;
   do
     j++;
   while(i&gt;=powl(2,j));/</em> 计算2的j次幂。 */
   return j;
}</p>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果:  当T不空,用e返回T的根,返回OK;否则返回ERROR,e无定义 <em>/
Status Root(SqBiTree T,TElemType *e)
{
	if(BiTreeEmpty(T)) /</em> T空 */
		return ERROR;
	else
	{
		*e=T[0];
		return OK;
	}
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点(的位置) <em>/
/</em> 操作结果: 返回处于位置e(层,本层序号)的结点的值 */
TElemType Value(SqBiTree T,Position e)
{
	 return T[(int)powl(2,e.level-1)+e.order-2];
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点(的位置) <em>/
/</em> 操作结果: 给处于位置e(层,本层序号)的结点赋新值value <em>/
Status Assign(SqBiTree T,Position e,TElemType value)
{
	int i=(int)powl(2,e.level-1)+e.order-2; /</em> 将层、本层序号转为矩阵的序号 <em>/
	if(value!=Nil&amp;&amp;T[(i+1)/2-1]==Nil) /</em> 给叶子赋非空值但双亲为空 <em>/
		return ERROR;
	else if(value==Nil&amp;&amp;(T[i</em>2+1]!=Nil||T[i<em>2+2]!=Nil)) /</em>  给双亲赋空值但有叶子（不空） */
		return ERROR;
	T[i]=value;
	return OK;
}  </p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 若e是T的非根结点,则返回它的双亲,否则返回＂空＂ <em>/
TElemType Parent(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e) /</em> 找到e <em>/
			return T[(i+1)/2-1];
	return Nil; /</em> 没找到e */
}  </p>

<ul>
  <li>初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的左孩子。若e无左孩子,则返回＂空＂ <em>/
TElemType LeftChild(SqBiTree T,TElemType e)
{
  int i;
  if(T[0]==Nil) /</em> 空树 <em>/
      return Nil;
  for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
      if(T[i]==e) /</em> 找到e <em>/
          return T[i</em>2+1];
  return Nil; /* 没找到e */
}  </li>
</ul>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的右孩子。若e无右孩子,则返回＂空＂ <em>/
TElemType RightChild(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e) /</em> 找到e <em>/
			return T[i</em>2+2];
	return Nil; /* 没找到e */
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的左兄弟。若e是T的左孩子或无左兄弟,则返回＂空＂ <em>/
TElemType LeftSibling(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e&amp;&amp;i%2==0) /</em> 找到e且其序号为偶数(是右孩子) <em>/
			return T[i-1];
	return Nil; /</em> 没找到e */
}  </p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的右兄弟。若e是T的右孩子或无右兄弟,则返回＂空＂ <em>/
TElemType RightSibling(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e&amp;&amp;i%2) /</em> 找到e且其序号为奇数(是左孩子) <em>/
			return T[i+1];
	return Nil; /</em> 没找到e */
}  </p>

<p>/* PreOrderTraverse()调用 <em>/
void PreTraverse(SqBiTree T,int e)
{
	visit(T[e]);
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		PreTraverse(T,2</em>e+1);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		PreTraverse(T,2</em>e+2);
}</p>

<p>/* 初始条件: 二叉树存在 <em>/
/</em> 操作结果: 先序遍历T。 <em>/
Status PreOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
	 PreTraverse(T,0);
	printf(“\n”);
	return OK;
}  </p>

<p>/* InOrderTraverse()调用 <em>/
void InTraverse(SqBiTree T,int e)
{
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		InTraverse(T,2</em>e+1);
	visit(T[e]);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		InTraverse(T,2</em>e+2);
}  </p>

<p>/* 初始条件: 二叉树存在 <em>/
/</em> 操作结果: 中序遍历T。 <em>/
Status InOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
		InTraverse(T,0);
	printf(“\n”);
	return OK;
}</p>

<p>/* PostOrderTraverse()调用 <em>/
void PostTraverse(SqBiTree T,int e)
{
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		PostTraverse(T,2</em>e+1);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		PostTraverse(T,2</em>e+2);
	visit(T[e]);
}  </p>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果: 后序遍历T。 <em>/
Status PostOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
		PostTraverse(T,0);
	printf(“\n”);
	return OK;
}</p>

<p>/* 层序遍历二叉树 <em>/
void LevelOrderTraverse(SqBiTree T)
{
	int i=MAX_TREE_SIZE-1,j;
	while(T[i]==Nil)
		i–; /</em> 找到最后一个非空结点的序号 <em>/
	for(j=0;j&lt;=i;j++)  /</em> 从根结点起,按层序遍历二叉树 <em>/
		if(T[j]!=Nil)
			visit(T[j]); /</em> 只遍历非空的结点 */
	printf(“\n”);
}  </p>

<p>/* 逐层、按本层序号输出二叉树 */
void Print(SqBiTree T)
{
	int j,k;
	Position p;
	TElemType e;
	for(j=1;j&lt;=BiTreeDepth(T);j++)
	{
		printf(“第%d层: “,j);
		for(k=1;k&lt;=powl(2,j-1);k++)
		{
			p.level=j;
			p.order=k;
			e=Value(T,p);
			if(e!=Nil)
				printf(“%d:%d “,k,e);
		}
		printf(“\n”);
	}
}  </p>

<p>int main()
{
	Status i;
	Position p;
	TElemType e;
	SqBiTree T;
	InitBiTree(T);
	CreateBiTree(T);
	printf(“建立二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n”,BiTreeEmpty(T),BiTreeDepth(T));
	i=Root(T,&amp;e);
	if(i)
		printf(“二叉树的根为：%d\n”,e);
	else
		printf(“树空，无根\n”);
	printf(“层序遍历二叉树:\n”);
	LevelOrderTraverse(T);
	printf(“前序遍历二叉树:\n”);
	PreOrderTraverse(T);
	printf(“中序遍历二叉树:\n”);
	InOrderTraverse(T);
	printf(“后序遍历二叉树:\n”);
	PostOrderTraverse(T);
	printf(“修改结点的层号3本层序号2。”);
	p.level=3;
	p.order=2;
	e=Value(T,p);
	printf(“待修改结点的原值为%d请输入新值:50 “,e);
	e=50;
	Assign(T,p,e);
	printf(“前序遍历二叉树:\n”);
	PreOrderTraverse(T);
	printf(“结点%d的双亲为%d,左右孩子分别为”,e,Parent(T,e));
	printf(“%d,%d,左右兄弟分别为”,LeftChild(T,e),RightChild(T,e));
	printf(“%d,%d\n”,LeftSibling(T,e),RightSibling(T,e));
	ClearBiTree(T);
	printf(“清除二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n”,BiTreeEmpty(T),BiTreeDepth(T));
	i=Root(T,&amp;e);
	if(i)
		printf(“二叉树的根为：%d\n”,e);
	else
		printf(“树空，无根\n”);</p>

<pre><code>return 0; }
</code></pre>

<p>```   </p>

<p>Now we will show you how to do without using the recursion method.  </p>

]]></content>
  </entry>
  
</feed>
