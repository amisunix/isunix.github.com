<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-08-22T14:41:22+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CTCI-Q1.2]]></title>
    <link href="http://isunix.github.io/blog/2014/08/20/ctci-q1-dot-2/"/>
    <updated>2014-08-20T10:58:48+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/20/ctci-q1-dot-2</id>
    <content type="html"><![CDATA[<p>The question is:  </p>

<p><code>
Implement a function void reverse(char* str) in C or C++ which reverses a null-terminated string.
</code></p>

<p>We have two solutions here, the first is to swap the i and n-i-1 element.</p>

<p>```cpp
#include <iostream>
#include <cstring /></iostream></p>

<p>using namespace std;</p>

<p>void swap(char &amp;a, char &amp;b){
  a = a^b;
  b = a^b;
  a = a^b;
}</p>

<p>void reverse(char *s){
  int n = strlen(s);
  int i;
  for (i = 0; i &lt; n/2; i++) {
    swap(s[i], s[n-i-1]);
  }
}</p>

<p>int main(){
  char s1[] = “123456789”;
  char s2[] = “abcdefg”;
  reverse(s1);
  cout«s1«endl;
  reverse(s2);
  cout«s2«endl;
}
```</p>

<p>```cpp
#include <iostream>
#include <cstring /></iostream></p>

<p>using namespace std;</p>

<p>void reverse(char <em>str){
  char</em> end = str;
  char tmp;
  if(str){
    while(*end){
      ++end;
    }
    –end;
    //find the end of the string, since the last char is nul, we use –end to set one char back.
    while(str &lt; end){
      tmp = *str;
      *str++ = *end;
      *end– = tmp;
    }
  }
}</p>

<p>int main(){
  char s1[] = “123456789”;
  char s2[] = “abcdefg”;
  reverse(s1);
  cout«s1«endl;
  reverse(s2);
  cout«s2«endl;
}
```</p>

<p>For the python version, we use recursion to get the last char of the string first and then the second to last char by using the recursion method. </p>

<p>```py
#!/usr/local/bin/python3
# -<em>- coding: utf-8 -</em>-</p>

<p>def reverseStringRecursive(str):
    if str != “”:
        return str[-1:] + reverseStringRecursive(str[:-1])
    else:
        return “”</p>

<p>str1 = “abcdef”
str2 = “123456”</p>

<p>print(reverseStringRecursive(str1))
print(reverseStringRecursive(str2))
```<br />
This method is very elegant.  </p>

<p>As to the java version, I have no idea how to implement it in java: so sad!</p>

<p>```java
import java.util.*;</p>

<p>public class Solution{
  public static void swap(char a, char b){
    char temp;
    temp = a;
    a = b;
    b = temp;
  }</p>

<p>public static String reverse(String s){
    int n = s.length();
    int i;
    for (i=0; i&lt;n/2; i++) {
      swap(s.charAt(i), s.charAt(n-i-1));
    }
    return s;
  }</p>

<p>public static void main(String[] args){
    String str = “abcdef”;
    Solution slt = new Solution();
    System.out.println(“the original string is “ + str + “ and the reversed string is:\n” + slt.reverse(str));
  }
}
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[顺序栈和链栈的c语言实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian/"/>
    <updated>2014-08-19T21:29:35+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian</id>
    <content type="html"><![CDATA[<p>1.sequence stack </p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 顺序栈结构 <em>/
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /</em> 用于栈顶指针 */
}SqStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S <em>/
Status InitStack(SqStack *S)
{
        /</em> S.data=(SElemType <em>)malloc(MAXSIZE</em>sizeof(SElemType)); */
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(SqStack *S)
{
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(SqStack S)
{
        if (S.top==-1)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(SqStack S)
{
        return S.top+1;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(SqStack S,SElemType *e)
{
        if (S.top==-1)
                return ERROR;
        else
                *e=S.data[S.top];
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /</em> 栈满 <em>/
        {
                return ERROR;
        }
        S-&gt;top++;				/</em> 栈顶指针增加一 <em>/
        S-&gt;data[S-&gt;top]=e;  /</em> 将新插入元素赋值给栈顶空间 */
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top];	/</em> 将要删除的栈顶元素赋值给e <em>/
        S-&gt;top–;				/</em> 栈顶指针减一 */
        return OK;
}</p>

<p>/* 从栈底到栈顶依次对栈中每个元素显示 */
Status StackTraverse(SqStack S)
{
        int i;
        i=0;
        while(i&lt;=S.top)
        {
                visit(S.data[i++]);
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        SqStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));</p>

<pre><code>    return 0; } ```  
</code></pre>

<p>2.Linked stack</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 链栈结构 <em>/
typedef struct StackNode
{
        SElemType data;
        struct StackNode *next;
}StackNode,</em>LinkStackPtr;</p>

<p>typedef struct
{
        LinkStackPtr top;
        int count;
}LinkStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S */
Status InitStack(LinkStack *S)
{
        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
        if(!S-&gt;top)
                return ERROR;
        S-&gt;top=NULL;
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(LinkStack *S)
{
        LinkStackPtr p,q;
        p=S-&gt;top;
        while(p)
        {
                q=p;
                p=p-&gt;next;
                free(q);
        }
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(LinkStack S)
{
        if (S.count==0)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(LinkStack S)
{
        return S.count;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(LinkStack S,SElemType *e)
{
        if (S.top==NULL)
                return ERROR;
        else
                *e=S.top-&gt;data;
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(LinkStack *S,SElemType e)
{
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s-&gt;data=e;
        s-&gt;next=S-&gt;top;	/</em> 把当前的栈顶元素赋值给新结点的直接后继 <em>/
        S-&gt;top=s;         /</em> 将新的结点s赋值给栈顶指针 */
        S-&gt;count++;
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(</em>S))
                return ERROR;
        <em>e=S-&gt;top-&gt;data;
        p=S-&gt;top;					/</em> 将栈顶结点赋值给p <em>/
        S-&gt;top=S-&gt;top-&gt;next;    /</em> 使得栈顶指针下移一位，指向后一结点 <em>/
        free(p);                    /</em> 释放结点p */
        S-&gt;count–;
        return OK;
}</p>

<p>Status StackTraverse(LinkStack S)
{
        LinkStackPtr p;
        p=S.top;
        while(p)
        {
                 visit(p-&gt;data);
                 p=p-&gt;next;
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        LinkStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CTCI-Q1.1]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/ctci-q1-dot-1/"/>
    <updated>2014-08-19T16:16:38+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/ctci-q1-dot-1</id>
    <content type="html"><![CDATA[<p>The question is: </p>

<p><code>yaml
Implement an algorithm to determine if a string has all unique characters. What if you can not use additional data structures?
</code></p>

<p>We will try to solve this problem using four languages c++, java, python.</p>

<p>In order to simplify this problem, we shorten the character set to ASCII.</p>

<p>In this case, if the string is longer that 256, surely at least two will be the same. </p>

<p>We can create an array char_set whose values are booleans. thus char_set[val] = true means that the char is in the array and char_set[val] = false means that the char is not in the array.  </p>

<p>1.java version:</p>

<p><code>java
public static boolean isUnique(String str) {
        if (str.length() &gt; 256) {
            return false;
        }
        boolean[] acsii_set = new boolean[256];
        for (int i = 0; i &lt; str.length(); i++) {
            int val = str.charAt(i);
            if (ascii_set[val]) return false;
            ascii_set[val] = true;
        }
        return true;
    }
</code></p>

<p>2.c++ version:</p>

<p><code>cpp
bool isUnique(string str){
	if(str.length() &gt; 256){
		return false;
	}
	bool ascii_set[256] = {false};
	for (int i=0; i &lt; str.length(); i++){
		int val = str[i];
		if (ascii_set[val]){
			return false;
		}
		ascii_set[value] = true;
	}
	reutrn true;
}
</code>  </p>

<p>3.python version:</p>

<p>```py
#!/usr/local/bin/python3
# -<em>- coding: utf-8 -</em>-</p>

<p>def is_unique(str):
    charsTable = set()
    for c in str:
        if c in charsTable:
            return False
        charsTable.add(c)
    return True</p>

<p>test_str1 = “hello”
test_str2 = “abcdef”
ans1 = is_unique(test_str1)
ans2 = is_unique(test_str2)
print(ans1)
print(ans2)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates From an Unsorted Linked List]]></title>
    <link href="http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list/"/>
    <updated>2014-08-18T15:12:52+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list</id>
    <content type="html"><![CDATA[<p>Write code to remove duplicates from an unsorted linked list.</p>

<p>FOLLOW UP</p>

<p>How would you solve this problem if a temporary buffer is not allowed?  </p>

<p>```cpp
#include <iostream>
#include <cstring>
using namespace std;</cstring></iostream></p>

<p>typedef struct node{
    int data;
    node *next;
}node;
bool myhash[100];</p>

<p>node* init(int a[], int n){
    node *head, *p;
    for(int i=0; i&lt;n; ++i){
        node *nd = new node();
        nd-&gt;data = a[i];
        if(i==0){
            head = p = nd;
            continue;
        }
        p-&gt;next = nd;
        p = nd;
    }
    return head;
}
void removedulicate(node *head){
    if(head==NULL) return;
    node *p=head, *q=head-&gt;next;
    myhash[head-&gt;data] = true;
    while(q){
        if(myhash[q-&gt;data]){
            node *t = q;
            p-&gt;next = q-&gt;next;
            q = p-&gt;next;
            delete t;
        }
        else{
            myhash[q-&gt;data] = true;
            p = q; q = q-&gt;next;
        }
    }
}
void removedulicate1(node *head){
    if(head==NULL) return;
    node *p, *q, *c=head;
    while(c){
        p=c; q=c-&gt;next;
        int d = c-&gt;data;
        while(q){
            if(q-&gt;data==d){
                node *t = q;
                p-&gt;next = q-&gt;next;
                q = p-&gt;next;
                delete t;
            }
            else{
                p = q; q = q-&gt;next;
            }
        }
        c = c-&gt;next;
    }
}
void print(node *head){
    while(head){
        cout«head-&gt;data«” ”;
        head = head-&gt;next;
    }
    cout«endl;
}
int main(){
    int n = 10;
    int a[] = {
        3, 2, 1, 3, 5, 6, 2, 6, 3, 1
    };
    memset(myhash, false, sizeof(myhash));
    node *head = init(a, n);
    removedulicate1(head);
    print(head);
    return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Python to Implement a Stack]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack/"/>
    <updated>2014-08-14T10:53:40+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack</id>
    <content type="html"><![CDATA[<p>In this post, we are going to implement a stack using Python. We are gonna do it using two ways. The first is by pushing to the end of the list, and pop out the rightmost item. The second is by “pushing” to the leftmost and pop out the leftmost item.  </p>

<ol>
  <li>push to the end  </li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

def push(self, item):
    self.items.append(item)

def pop(self):
    return self.items.pop()

'''
returns the top item from the stack but does not remove it.
It needs no parameters.
The stack is not modified.
'''
def peek(self):
    return self.items[len(self.items) - 1]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
print (s.is_empty())
s.push(4)
s.push(‘dog’)
print (s.peek())
print(“\n”)
print (s.peek())
s.push(True)
print (s.size())
print (s.is_empty())
s.push(8.4)
print (s.pop())
print (s.pop())
print (s.size())
```  </p>

<ol>
  <li>push to the front end</li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

#push, inserting at the front end.
def push(self, item):
    self.items.insert(0, item)

#pop out the leftest item.
def pop(self):
    return self.items.pop(0)

def peek(self):
    return self.items[0]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
s.push(‘hello’)
s.push(‘true’)
print(s.pop())
print (s.pop())
```</p>
]]></content>
  </entry>
  
</feed>
