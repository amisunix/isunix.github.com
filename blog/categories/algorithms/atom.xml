<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-08-19T15:56:58+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates From an Unsorted Linked List]]></title>
    <link href="http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list/"/>
    <updated>2014-08-18T15:12:52+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list</id>
    <content type="html"><![CDATA[<p>Write code to remove duplicates from an unsorted linked list.</p>

<p>FOLLOW UP</p>

<p>How would you solve this problem if a temporary buffer is not allowed?  </p>

<p>```cpp
#include <iostream>
#include <cstring>
using namespace std;</cstring></iostream></p>

<p>typedef struct node{
    int data;
    node *next;
}node;
bool myhash[100];</p>

<p>node* init(int a[], int n){
    node *head, *p;
    for(int i=0; i&lt;n; ++i){
        node *nd = new node();
        nd-&gt;data = a[i];
        if(i==0){
            head = p = nd;
            continue;
        }
        p-&gt;next = nd;
        p = nd;
    }
    return head;
}
void removedulicate(node *head){
    if(head==NULL) return;
    node *p=head, *q=head-&gt;next;
    myhash[head-&gt;data] = true;
    while(q){
        if(myhash[q-&gt;data]){
            node *t = q;
            p-&gt;next = q-&gt;next;
            q = p-&gt;next;
            delete t;
        }
        else{
            myhash[q-&gt;data] = true;
            p = q; q = q-&gt;next;
        }
    }
}
void removedulicate1(node *head){
    if(head==NULL) return;
    node *p, *q, *c=head;
    while(c){
        p=c; q=c-&gt;next;
        int d = c-&gt;data;
        while(q){
            if(q-&gt;data==d){
                node *t = q;
                p-&gt;next = q-&gt;next;
                q = p-&gt;next;
                delete t;
            }
            else{
                p = q; q = q-&gt;next;
            }
        }
        c = c-&gt;next;
    }
}
void print(node *head){
    while(head){
        cout«head-&gt;data«” ”;
        head = head-&gt;next;
    }
    cout«endl;
}
int main(){
    int n = 10;
    int a[] = {
        3, 2, 1, 3, 5, 6, 2, 6, 3, 1
    };
    memset(myhash, false, sizeof(myhash));
    node *head = init(a, n);
    removedulicate1(head);
    print(head);
    return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Python to Implement a Stack]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack/"/>
    <updated>2014-08-14T10:53:40+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack</id>
    <content type="html"><![CDATA[<p>In this post, we are going to implement a stack using Python. We are gonna do it using two ways. The first is by pushing to the end of the list, and pop out the rightmost item. The second is by “pushing” to the leftmost and pop out the leftmost item.  </p>

<ol>
  <li>push to the end  </li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

def push(self, item):
    self.items.append(item)

def pop(self):
    return self.items.pop()

'''
returns the top item from the stack but does not remove it.
It needs no parameters.
The stack is not modified.
'''
def peek(self):
    return self.items[len(self.items) - 1]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
print (s.is_empty())
s.push(4)
s.push(‘dog’)
print (s.peek())
print(“\n”)
print (s.peek())
s.push(True)
print (s.size())
print (s.is_empty())
s.push(8.4)
print (s.pop())
print (s.pop())
print (s.size())
```  </p>

<ol>
  <li>push to the front end</li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

#push, inserting at the front end.
def push(self, item):
    self.items.insert(0, item)

#pop out the leftest item.
def pop(self):
    return self.items.pop(0)

def peek(self):
    return self.items[0]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
s.push(‘hello’)
s.push(‘true’)
print(s.pop())
print (s.pop())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Tips Using Java to Practice Algorithms]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms/"/>
    <updated>2014-08-14T10:07:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms</id>
    <content type="html"><![CDATA[<p>There are common structues and tips while practicing algorithms and data structueres using java. I will try to keep them down in this post.   </p>

<p>1.hash tables  </p>

<p><code>java
public HashMap&lt;Integer, Student&gt; buildMap(Student[] students) {
  HashMap&lt;IntegerJ Student&gt; map = new HashMap&lt;Integer, Student&gt;();
    for (Student s : students) map.put(s.getld(), s);
    return map;
}
</code> </p>

<p>2.ArrayList(Dinamically Resizing Array) </p>

<p><code>java
public ArrayList&lt;String&gt; merge(String[] words, String[] more) {
  ArrayList&lt;String&gt; sentence = new Arrayl_ist&lt;String&gt;();
  for (String w : words) sentence.add(w);
  for (String w : more) sentence.add(w);
  return sentence;
}
</code>   </p>

<p>3.StringBuffer   </p>

<p><code>java
public String joinWords(String[] words){
  StringBuffer sentence = new StringBuffer();
  for (String w : words){
    sentence.append(w);
  }
  return sentence.toString();
}
</code>  </p>

<p>4.LinkedList  </p>

<p>```java<br />
class Node {
  Node next = null;
  int data;</p>

<p>public Node(int d) {
  data = d;
  }</p>

<p>void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while (n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```  </p>

<p>5.Deleting a node from a singly linkes list.  </p>

<p>```java
Node deleteNode(Node head, int d) {
  Node n = head;</p>

<p>if (n.data == d) {
    return head.next; /* moved head */
  }</p>

<p>while (n.next 1= null) {
    if (n.next.data == d) {
      n.next = n.next.next;
      return head; /* head didn’t change */
    }
    n = n.next;
  }
  return head;
}
```  </p>

<p>6.Implementing a stack</p>

<p>```java
class Stack {
  Node top;</p>

<p>Object pop() {
    if(top != null) {
      Object item = top.data;
      p = top.next;
      return item;
    }
    return null;
  }</p>

<p>void push(0bject item) {
    Node t = new Node(item);
    next = top;
    top = t;
  }</p>

<p>Object peek() {
    return top.data;
  }
}
```  </p>

<p>7.Implementing a queue.  </p>

<p>```java<br />
class Queue {
  Node first, last;</p>

<p>void enqueue(0bject item) {
    if(first == null) {
      last = new Node(item);
      first = last;
      } else {
        last.next = new Node(item);
        last = last.next;
      }
  }</p>

<p>Object dequeueQ {
    if (first != null) {
      Object item = first.data;
      first = first.next;
      return item;
    }
    return null;
  }
}
```</p>

<p>8.pseudocode to implement DFS</p>

<p><code>java
void search(Node root) {
  if (root == null) return;
  visit(root);
  root.visited = true;
  foreach (Node n in root.adjacent) {
    if (n.visited == false) {
      search(n);
    }
  }
}
</code>  </p>

<p>9.BFS.</p>

<p>```java
void search(Node root) {
  Queue queue = new QueueQ;
  root.visited = true;
  visit(root);
  queue.enqueue(root); // Add to end of queue</p>

<p>while (!queue.isEmpty()) {
    Node r = queue.dequeueQ; // Remove from front of queue
    foreach (Node n in r.adjacent) {
      if (n.visited == false) {
        visit(n);
        n.visited = true;
        queue.enqueue(n);
      }
    }
  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树遍历的递归与非递归实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/13/er-cha-shu-bian-li-de-di-gui-yu-fei-di-gui-shi-xian/"/>
    <updated>2014-08-13T11:00:50+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/13/er-cha-shu-bian-li-de-di-gui-yu-fei-di-gui-shi-xian</id>
    <content type="html"><![CDATA[<p>Just as is depicted by the title, in this post, we are going to realize the recursive traversing and non-recursive traveersing of a binary tree.   </p>

<p>First we will show the recursive one. This example is from the book ‘大话数据结构’.</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0</p>

<h1 id="define-maxsize-100---">define MAXSIZE 100 /* 存储空间初始分配量 */</h1>
<p>#define MAX_TREE_SIZE 100 /* 二叉树的最大结点数 */</p>

<p>typedef int Status;		/* Status是函数的类型,其值是函数结果状态代码，如OK等 <em>/
typedef int TElemType;  /</em> 树结点的数据类型，目前暂定为整型 <em>/
typedef TElemType SqBiTree[MAX_TREE_SIZE]; /</em> 0号单元存储根结点  */  </p>

<p>typedef struct
{
	int level,order; /* 结点的层,本层序号(按满二叉树计算) */
}Position;</p>

<p>TElemType Nil=0; /*  设整型以0为空 */</p>

<p>Status visit(TElemType c)
{
	printf(“%d “,c);
	return OK;
}  </p>

<p>/* 构造空二叉树T。因为T是固定数组，不会改变，故不需要&amp; <em>/
Status InitBiTree(SqBiTree T)
{
	int i;
	for(i=0;i&lt;MAX_TREE_SIZE;i++)
		T[i]=Nil; /</em> 初值为空 */
	return OK;
}  </p>

<p>/* 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T */
Status CreateBiTree(SqBiTree T)
{
	int i=0;
 	printf(“请按层序输入结点的值(整型)，0表示空结点，输999结束。结点数≤%d:\n”,MAX_TREE_SIZE);
	while(i&lt;10)
	{
		T[i]=i+1;</p>

<pre><code>	if(i!=0&amp;&amp;T[(i+1)/2-1]==Nil&amp;&amp;T[i]!=Nil) /* 此结点(不空)无双亲且不是根 */
	{
		printf("出现无双亲的非根结点%d\n",T[i]);
		exit(ERROR);
	}
	i++;
}
while(i&lt;MAX_TREE_SIZE)
{
	T[i]=Nil; /* 将空赋值给T的后面的结点 */
	i++;
}

return OK; }
</code></pre>

<h1 id="define-clearbitree-initbitree---">define ClearBiTree InitBiTree /* 在顺序存储结构中，两函数完全一样 */</h1>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果: 若T为空二叉树,则返回TRUE,否则FALSE <em>/
Status BiTreeEmpty(SqBiTree T)
{
	if(T[0]==Nil) /</em> 根结点为空,则树空 */
		return TRUE;
	else
		return FALSE;
}</p>

<p>/* 初始条件: 二叉树T存在。操作结果: 返回T的深度 <em>/
int BiTreeDepth(SqBiTree T)
{
   int i,j=-1;
   for(i=MAX_TREE_SIZE-1;i&gt;=0;i–) /</em> 找到最后一个结点 <em>/
     if(T[i]!=Nil)
       break;
   i++;
   do
     j++;
   while(i&gt;=powl(2,j));/</em> 计算2的j次幂。 */
   return j;
}</p>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果:  当T不空,用e返回T的根,返回OK;否则返回ERROR,e无定义 <em>/
Status Root(SqBiTree T,TElemType *e)
{
	if(BiTreeEmpty(T)) /</em> T空 */
		return ERROR;
	else
	{
		*e=T[0];
		return OK;
	}
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点(的位置) <em>/
/</em> 操作结果: 返回处于位置e(层,本层序号)的结点的值 */
TElemType Value(SqBiTree T,Position e)
{
	 return T[(int)powl(2,e.level-1)+e.order-2];
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点(的位置) <em>/
/</em> 操作结果: 给处于位置e(层,本层序号)的结点赋新值value <em>/
Status Assign(SqBiTree T,Position e,TElemType value)
{
	int i=(int)powl(2,e.level-1)+e.order-2; /</em> 将层、本层序号转为矩阵的序号 <em>/
	if(value!=Nil&amp;&amp;T[(i+1)/2-1]==Nil) /</em> 给叶子赋非空值但双亲为空 <em>/
		return ERROR;
	else if(value==Nil&amp;&amp;(T[i</em>2+1]!=Nil||T[i<em>2+2]!=Nil)) /</em>  给双亲赋空值但有叶子（不空） */
		return ERROR;
	T[i]=value;
	return OK;
}  </p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 若e是T的非根结点,则返回它的双亲,否则返回＂空＂ <em>/
TElemType Parent(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e) /</em> 找到e <em>/
			return T[(i+1)/2-1];
	return Nil; /</em> 没找到e */
}  </p>

<ul>
  <li>初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的左孩子。若e无左孩子,则返回＂空＂ <em>/
TElemType LeftChild(SqBiTree T,TElemType e)
{
  int i;
  if(T[0]==Nil) /</em> 空树 <em>/
      return Nil;
  for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
      if(T[i]==e) /</em> 找到e <em>/
          return T[i</em>2+1];
  return Nil; /* 没找到e */
}  </li>
</ul>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的右孩子。若e无右孩子,则返回＂空＂ <em>/
TElemType RightChild(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=0;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e) /</em> 找到e <em>/
			return T[i</em>2+2];
	return Nil; /* 没找到e */
}</p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的左兄弟。若e是T的左孩子或无左兄弟,则返回＂空＂ <em>/
TElemType LeftSibling(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e&amp;&amp;i%2==0) /</em> 找到e且其序号为偶数(是右孩子) <em>/
			return T[i-1];
	return Nil; /</em> 没找到e */
}  </p>

<p>/* 初始条件: 二叉树T存在,e是T中某个结点 <em>/
/</em> 操作结果: 返回e的右兄弟。若e是T的右孩子或无右兄弟,则返回＂空＂ <em>/
TElemType RightSibling(SqBiTree T,TElemType e)
{
	int i;
	if(T[0]==Nil) /</em> 空树 <em>/
		return Nil;
	for(i=1;i&lt;=MAX_TREE_SIZE-1;i++)
		if(T[i]==e&amp;&amp;i%2) /</em> 找到e且其序号为奇数(是左孩子) <em>/
			return T[i+1];
	return Nil; /</em> 没找到e */
}  </p>

<p>/* PreOrderTraverse()调用 <em>/
void PreTraverse(SqBiTree T,int e)
{
	visit(T[e]);
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		PreTraverse(T,2</em>e+1);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		PreTraverse(T,2</em>e+2);
}</p>

<p>/* 初始条件: 二叉树存在 <em>/
/</em> 操作结果: 先序遍历T。 <em>/
Status PreOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
	 PreTraverse(T,0);
	printf(“\n”);
	return OK;
}  </p>

<p>/* InOrderTraverse()调用 <em>/
void InTraverse(SqBiTree T,int e)
{
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		InTraverse(T,2</em>e+1);
	visit(T[e]);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		InTraverse(T,2</em>e+2);
}  </p>

<p>/* 初始条件: 二叉树存在 <em>/
/</em> 操作结果: 中序遍历T。 <em>/
Status InOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
		InTraverse(T,0);
	printf(“\n”);
	return OK;
}</p>

<p>/* PostOrderTraverse()调用 <em>/
void PostTraverse(SqBiTree T,int e)
{
	if(T[2</em>e+1]!=Nil) /* 左子树不空 <em>/
		PostTraverse(T,2</em>e+1);
	if(T[2<em>e+2]!=Nil) /</em> 右子树不空 <em>/
		PostTraverse(T,2</em>e+2);
	visit(T[e]);
}  </p>

<p>/* 初始条件: 二叉树T存在 <em>/
/</em> 操作结果: 后序遍历T。 <em>/
Status PostOrderTraverse(SqBiTree T)
{
	if(!BiTreeEmpty(T)) /</em> 树不空 */
		PostTraverse(T,0);
	printf(“\n”);
	return OK;
}</p>

<p>/* 层序遍历二叉树 <em>/
void LevelOrderTraverse(SqBiTree T)
{
	int i=MAX_TREE_SIZE-1,j;
	while(T[i]==Nil)
		i–; /</em> 找到最后一个非空结点的序号 <em>/
	for(j=0;j&lt;=i;j++)  /</em> 从根结点起,按层序遍历二叉树 <em>/
		if(T[j]!=Nil)
			visit(T[j]); /</em> 只遍历非空的结点 */
	printf(“\n”);
}  </p>

<p>/* 逐层、按本层序号输出二叉树 */
void Print(SqBiTree T)
{
	int j,k;
	Position p;
	TElemType e;
	for(j=1;j&lt;=BiTreeDepth(T);j++)
	{
		printf(“第%d层: “,j);
		for(k=1;k&lt;=powl(2,j-1);k++)
		{
			p.level=j;
			p.order=k;
			e=Value(T,p);
			if(e!=Nil)
				printf(“%d:%d “,k,e);
		}
		printf(“\n”);
	}
}  </p>

<p>int main()
{
	Status i;
	Position p;
	TElemType e;
	SqBiTree T;
	InitBiTree(T);
	CreateBiTree(T);
	printf(“建立二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n”,BiTreeEmpty(T),BiTreeDepth(T));
	i=Root(T,&amp;e);
	if(i)
		printf(“二叉树的根为：%d\n”,e);
	else
		printf(“树空，无根\n”);
	printf(“层序遍历二叉树:\n”);
	LevelOrderTraverse(T);
	printf(“前序遍历二叉树:\n”);
	PreOrderTraverse(T);
	printf(“中序遍历二叉树:\n”);
	InOrderTraverse(T);
	printf(“后序遍历二叉树:\n”);
	PostOrderTraverse(T);
	printf(“修改结点的层号3本层序号2。”);
	p.level=3;
	p.order=2;
	e=Value(T,p);
	printf(“待修改结点的原值为%d请输入新值:50 “,e);
	e=50;
	Assign(T,p,e);
	printf(“前序遍历二叉树:\n”);
	PreOrderTraverse(T);
	printf(“结点%d的双亲为%d,左右孩子分别为”,e,Parent(T,e));
	printf(“%d,%d,左右兄弟分别为”,LeftChild(T,e),RightChild(T,e));
	printf(“%d,%d\n”,LeftSibling(T,e),RightSibling(T,e));
	ClearBiTree(T);
	printf(“清除二叉树后,树空否？%d(1:是 0:否) 树的深度=%d\n”,BiTreeEmpty(T),BiTreeDepth(T));
	i=Root(T,&amp;e);
	if(i)
		printf(“二叉树的根为：%d\n”,e);
	else
		printf(“树空，无根\n”);</p>

<pre><code>return 0; }
</code></pre>

<p>```   </p>

<p>Now we will show you how to do without using the recursion method.  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表的两种实现方式]]></title>
    <link href="http://isunix.github.io/blog/2014/08/02/lian-biao-de-liang-chong-shi-xian-fang-shi/"/>
    <updated>2014-08-02T10:31:18+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/02/lian-biao-de-liang-chong-shi-xian-fang-shi</id>
    <content type="html"><![CDATA[<p>这是关于线性表链式存住的两种实现方式，一个使用指针，一个使用c++中的引用。其实这两种方式是大同小异的。  </p>

<p>The first method will use pointer in c.  </p>

<p>```c<br />
/<em>first inlcude all those need header files.</em>/
#include “stdio.h”
#include “string.h”
#include “ctype.h”
#include “stdlib.h”
#include “math.h”</p>

<p>/<em>define those constants needed</em>/
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0</p>

<p>/<em>define the initial size allocated.</em>/
#define MAXSIZE 20</p>

<p>/<em>define the return type of a function</em>/
typedef int Status;
typedef int ElemType;</p>

<p>/<em>define a struct Node with the name Node, and make LinkList a pointer point to Node</em>/
typedef struct Node {
    ElemType data;
    struct Node *next;
}Node;
typedef struct Node *LinkList;</p>

<p>/<em>initialize the LinkList</em>/
Status InitList(LinkList <em>L)
{
    *L=(LinkList)malloc(sizeof(Node));   <br />
    if(!(</em>L)) 
    	return ERROR;
    (*L)-&gt;next=NULL; </p>

<pre><code>return OK; }
</code></pre>

<p>Status ListEmpty(LinkList L){
    if(L-&gt;next)
    	return FALSE;
    else
    	return TRUE;
}</p>

<p>/<em>if the linklist already exists, set it to empty</em>/
Status ClearList(LinkList <em>L)
{
	LinkList p,q;
	p=(</em>L)-&gt;next;     /<em>p points to the first node</em>/    <br />
	while(p)          /<em>it means not to the end of the linklist</em>/    <br />
	{
		q=p-&gt;next;
		free(p);
		p=q;
	}
	(<em>L)-&gt;next=NULL;  /</em>pointer field for the head Node will be null*/     <br />
	return OK;
}</p>

<p>/<em>return the length of the linklist</em>/
int ListLength(LinkList L)
{
    int i=0;
    LinkList p=L-&gt;next;  /<em>p points to the first node</em>/
    while(p)
    {
        i++;
        p=p-&gt;next;
    }
    return i;
}</p>

<p>/<em>get the i th element of L and returning its value using e</em>/
Status GetElem(LinkList L,int i,ElemType <em>e) {
	int j;
	LinkList p;		/</em> declare a node “p” <em>/
	p = L-&gt;next;		/</em> let p point to the first node of L <em>/
	j = 1;		
	while (p &amp;&amp; j&lt;i)<br />
	{
		p = p-&gt;next;  /</em> let p point to the next node <em>/
		++j;
	}
	if ( !p || j&gt;i )
		return ERROR;  /</em>  the i th element does not exist <em>/
	*e = p-&gt;data;   /</em>  get the data of the i th element */
	return OK;
}</p>

<p>/* locate element e in L <em>/<br />
int LocateElem(LinkList L,ElemType e) {
    int i=0;
    LinkList p=L-&gt;next;
    while(p)
    {
        i++;
        if(p-&gt;data==e) /</em> find the element */
                return i;
        p=p-&gt;next;
    }</p>

<pre><code>return 0; }
</code></pre>

<p>/<em>insert at the location of the i th element</em>/ 	
Status ListInsert(LinkList <em>L,int i,ElemType e)
{
	int j;
	LinkList p,s;
	p = *L;
	j = 1;
	while (p &amp;&amp; j &lt; i)     /</em> find the i th node */
	{
		p = p-&gt;next;
		++j;
	}
	if (!p || j &gt; i)
		return ERROR; <br />
	s = (LinkList)malloc(sizeof(Node));<br />
	s-&gt;data = e;
	s-&gt;next = p-&gt;next;    <br />
	p-&gt;next = s;        <br />
	return OK;
}  </p>

<p>/<em>delete the i th element, returning its value using e</em>/</p>

<p>Status ListDelete(LinkList *L,int i,ElemType *e)
{
	int j;
	LinkList p,q;
	p = *L;
	j = 1;
	while (p-&gt;next &amp;&amp; j &lt; i)	
	{
        p = p-&gt;next;
        ++j;
	}
	if (!(p-&gt;next) || j &gt; i)
	    return ERROR;         <br />
	q = p-&gt;next;
	p-&gt;next = q-&gt;next;			
	*e = q-&gt;data;             <br />
	free(q);                 <br />
	return OK;
}</p>

<p>/<em>print out all elements</em>/  </p>

<p>Status visit(ElemType c) {
    printf(“%d “,c);
    return OK;
}</p>

<p>Status ListTraverse(LinkList L)
{
    LinkList p=L-&gt;next;
    while(p)
    {
        visit(p-&gt;data);
        p=p-&gt;next;
    }
    printf(“\n”);
    return OK;
}</p>

<p>/<em>create the data for the n elements randomly, create a linked list with head node</em>/</p>

<p>void CreateListHead(LinkList <em>L, int n)
{
	LinkList p;
	int i;
	srand(time(0));                       <br />
	*L = (LinkList)malloc(sizeof(Node));
	(</em>L)-&gt;next = NULL;                    <br />
	for (i=0; i&lt;n; i++)
	{
		p = (LinkList)malloc(sizeof(Node)); 
		p-&gt;data = rand()%100+1;           <br />
		p-&gt;next = (<em>L)-&gt;next;
		(</em>L)-&gt;next = p;						
	}
}</p>

<p>/<em>create the data for the n elements randomly, create a linked list with tail node</em>/</p>

<p>void CreateListTail(LinkList <em>L, int n)
{
	LinkList p,r;
	int i;
	srand(time(0));                    <br />
	*L = (LinkList)malloc(sizeof(Node)); 
	r=</em>L;                              <br />
	for (i=0; i&lt;n; i++)
	{
		p = (Node *)malloc(sizeof(Node)); 
		p-&gt;data = rand()%100+1;         <br />
		r-&gt;next=p;                      <br />
		r = p;                          <br />
	}
	r-&gt;next = NULL;                     <br />
}</p>

<p>/<em>in the main function you  have to do the following initializations</em>/ </p>

<p>int main()
{
    LinkList L;
    ElemType e;
    Status i;
    int j,k;
    i=InitList(&amp;L);
	/<em>blahblah</em>/
}</p>

<p>```  </p>

<p>The following is a version using c++’s reference “&amp;”, it is a little different, but mostly wil be the same as the above.  </p>

<p>```cpp
#include <stdio.h>
#include <stdlib.h /></stdio.h></p>

<p>typedef char ElemType;
typedef struct LNode  		
{
	ElemType data;
	struct LNode *next;		
} LinkList;</p>

<p>/<em>creating the linked list by inserting at the head</em>/  </p>

<p>void CreateListF(LinkList *&amp;L,ElemType a[],int n)
{
	LinkList *s;int i;
	L=(LinkList *)malloc(sizeof(LinkList));  	
	L-&gt;next=NULL;
	for (i=0;i&lt;n;i++)
	{
		s=(LinkList *)malloc(sizeof(LinkList));
		s-&gt;data=a[i];
		s-&gt;next=L-&gt;next;			
		L-&gt;next=s;
	}
}</p>

<p>/<em>creating the linked list by inserting at the tail</em>/
void CreateListR(LinkList <em>&amp;L,ElemType a[],int n)
{
	LinkList *s,</em>r;int i;
	L=(LinkList *)malloc(sizeof(LinkList));  	
	L-&gt;next=NULL;
	r=L;					
	for (i=0;i&lt;n;i++)
	{
		s=(LinkList *)malloc(sizeof(LinkList));
		s-&gt;data=a[i];
		r-&gt;next=s;			
		r=s;
	}
	r-&gt;next=NULL;			
}</p>

<p>/<em>and blah and blah</em>/</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
