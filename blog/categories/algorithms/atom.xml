<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2014-11-18T13:56:21+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Study of Hash Function]]></title>
    <link href="http://isunix.github.io/blog/2014/09/19/study-of-hash-function/"/>
    <updated>2014-09-19T10:26:02+08:00</updated>
    <id>http://isunix.github.io/blog/2014/09/19/study-of-hash-function</id>
    <content type="html"><![CDATA[<p>Recently I come across an algorithm, and I am sure I have no idea what it is doing, when I ask my colleague, he said it is hash algorithm.  Thus comes out this article talking about hash algorithms.  </p>

<p>First I will list some of the sites I visited while I am learning what is hash function, how to create it and how to use it.  </p>

<p>```
http://isthe.com/chongo/tech/comp/fnv/#fnv-prime
I did not spend any time on this post yet.     </p>

<p>http://www.azillionmonkeys.com/qed/hash.html
This is said to be a very good article on hash function.</p>

<p>http://burtleburtle.net/bob/hash/doobs.html
This is also a very good article.</p>

<p>http://en.wikipedia.org/wiki/Hash_function
http://www.benfrederickson.com/heap-visualization/
http://blog.csdn.net/wuliming_sc/article/details/1365962
and difinitely http://www.benfrederickson.com/ is a very good site for learning some knowledge of algorithms.</p>

<p>http://blog.163.com/clevertanglei900@126/blog/static/111352259201171111938208/
this post gives a very clear explanation of what hash function is
``` </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boyer-Moore 算法实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/26/boyer-moore-suan-fa-shi-xian/"/>
    <updated>2014-08-26T11:52:34+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/26/boyer-moore-suan-fa-shi-xian</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CTCI-Q1.2]]></title>
    <link href="http://isunix.github.io/blog/2014/08/20/ctci-q1-dot-2/"/>
    <updated>2014-08-20T10:58:48+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/20/ctci-q1-dot-2</id>
    <content type="html"><![CDATA[<p>The question is:  </p>

<p><code>
Implement a function void reverse(char* str) in C or C++ which reverses a null-terminated string.
</code></p>

<p>We have two solutions here, the first is to swap the i and n-i-1 element.</p>

<p>```cpp
#include <iostream>
#include <cstring /></iostream></p>

<p>using namespace std;</p>

<p>void swap(char &amp;a, char &amp;b){
  a = a^b;
  b = a^b;
  a = a^b;
}</p>

<p>void reverse(char *s){
  int n = strlen(s);
  int i;
  for (i = 0; i &lt; n/2; i++) {
    swap(s[i], s[n-i-1]);
  }
}</p>

<p>int main(){
  char s1[] = “123456789”;
  char s2[] = “abcdefg”;
  reverse(s1);
  cout«s1«endl;
  reverse(s2);
  cout«s2«endl;
}
```</p>

<p>```cpp
#include <iostream>
#include <cstring /></iostream></p>

<p>using namespace std;</p>

<p>void reverse(char <em>str){
  char</em> end = str;
  char tmp;
  if(str){
    while(*end){
      ++end;
    }
    –end;
    //find the end of the string, since the last char is nul, we use –end to set one char back.
    while(str &lt; end){
      tmp = *str;
      *str++ = *end;
      *end– = tmp;
    }
  }
}</p>

<p>int main(){
  char s1[] = “123456789”;
  char s2[] = “abcdefg”;
  reverse(s1);
  cout«s1«endl;
  reverse(s2);
  cout«s2«endl;
}
```</p>

<p>For the python version, we use recursion to get the last char of the string first and then the second to last char by using the recursion method. </p>

<p>```py
#!/usr/local/bin/python3
# -<em>- coding: utf-8 -</em>-</p>

<p>def reverseStringRecursive(str):
    if str != “”:
        return str[-1:] + reverseStringRecursive(str[:-1])
    else:
        return “”</p>

<p>str1 = “abcdef”
str2 = “123456”</p>

<p>print(reverseStringRecursive(str1))
print(reverseStringRecursive(str2))
```<br />
This method is very elegant.  </p>

<p>As to the java version, I have no idea how to implement it in java: so sad!</p>

<p>```java
import java.util.*;</p>

<p>public class Solution{
  public static void swap(char a, char b){
    char temp;
    temp = a;
    a = b;
    b = temp;
  }</p>

<p>public static String reverse(String s){
    int n = s.length();
    int i;
    for (i=0; i&lt;n/2; i++) {
      swap(s.charAt(i), s.charAt(n-i-1));
    }
    return s;
  }</p>

<p>public static void main(String[] args){
    String str = “abcdef”;
    Solution slt = new Solution();
    System.out.println(“the original string is “ + str + “ and the reversed string is:\n” + slt.reverse(str));
  }
}
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[顺序栈和链栈的c语言实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian/"/>
    <updated>2014-08-19T21:29:35+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian</id>
    <content type="html"><![CDATA[<p>1.sequence stack </p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 顺序栈结构 <em>/
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /</em> 用于栈顶指针 */
}SqStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S <em>/
Status InitStack(SqStack *S)
{
        /</em> S.data=(SElemType <em>)malloc(MAXSIZE</em>sizeof(SElemType)); */
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(SqStack *S)
{
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(SqStack S)
{
        if (S.top==-1)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(SqStack S)
{
        return S.top+1;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(SqStack S,SElemType *e)
{
        if (S.top==-1)
                return ERROR;
        else
                *e=S.data[S.top];
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /</em> 栈满 <em>/
        {
                return ERROR;
        }
        S-&gt;top++;				/</em> 栈顶指针增加一 <em>/
        S-&gt;data[S-&gt;top]=e;  /</em> 将新插入元素赋值给栈顶空间 */
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top];	/</em> 将要删除的栈顶元素赋值给e <em>/
        S-&gt;top–;				/</em> 栈顶指针减一 */
        return OK;
}</p>

<p>/* 从栈底到栈顶依次对栈中每个元素显示 */
Status StackTraverse(SqStack S)
{
        int i;
        i=0;
        while(i&lt;=S.top)
        {
                visit(S.data[i++]);
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        SqStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));</p>

<pre><code>    return 0; } ```  
</code></pre>

<p>2.Linked stack</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 链栈结构 <em>/
typedef struct StackNode
{
        SElemType data;
        struct StackNode *next;
}StackNode,</em>LinkStackPtr;</p>

<p>typedef struct
{
        LinkStackPtr top;
        int count;
}LinkStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S */
Status InitStack(LinkStack *S)
{
        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
        if(!S-&gt;top)
                return ERROR;
        S-&gt;top=NULL;
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(LinkStack *S)
{
        LinkStackPtr p,q;
        p=S-&gt;top;
        while(p)
        {
                q=p;
                p=p-&gt;next;
                free(q);
        }
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(LinkStack S)
{
        if (S.count==0)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(LinkStack S)
{
        return S.count;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(LinkStack S,SElemType *e)
{
        if (S.top==NULL)
                return ERROR;
        else
                *e=S.top-&gt;data;
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(LinkStack *S,SElemType e)
{
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s-&gt;data=e;
        s-&gt;next=S-&gt;top;	/</em> 把当前的栈顶元素赋值给新结点的直接后继 <em>/
        S-&gt;top=s;         /</em> 将新的结点s赋值给栈顶指针 */
        S-&gt;count++;
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(</em>S))
                return ERROR;
        <em>e=S-&gt;top-&gt;data;
        p=S-&gt;top;					/</em> 将栈顶结点赋值给p <em>/
        S-&gt;top=S-&gt;top-&gt;next;    /</em> 使得栈顶指针下移一位，指向后一结点 <em>/
        free(p);                    /</em> 释放结点p */
        S-&gt;count–;
        return OK;
}</p>

<p>Status StackTraverse(LinkStack S)
{
        LinkStackPtr p;
        p=S.top;
        while(p)
        {
                 visit(p-&gt;data);
                 p=p-&gt;next;
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        LinkStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CTCI-Q1.1]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/ctci-q1-dot-1/"/>
    <updated>2014-08-19T16:16:38+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/ctci-q1-dot-1</id>
    <content type="html"><![CDATA[<p>The question is: </p>

<p><code>yaml
Implement an algorithm to determine if a string has all unique characters. What if you can not use additional data structures?
</code></p>

<p>We will try to solve this problem using four languages c++, java, python.</p>

<p>In order to simplify this problem, we shorten the character set to ASCII.</p>

<p>In this case, if the string is longer that 256, surely at least two will be the same. </p>

<p>We can create an array char_set whose values are booleans. thus char_set[val] = true means that the char is in the array and char_set[val] = false means that the char is not in the array.  </p>

<p>1.java version:</p>

<p><code>java
public static boolean isUnique(String str) {
        if (str.length() &gt; 256) {
            return false;
        }
        boolean[] acsii_set = new boolean[256];
        for (int i = 0; i &lt; str.length(); i++) {
            int val = str.charAt(i);
            if (ascii_set[val]) return false;
            ascii_set[val] = true;
        }
        return true;
    }
</code></p>

<p>2.c++ version:</p>

<p><code>cpp
bool isUnique(string str){
	if(str.length() &gt; 256){
		return false;
	}
	bool ascii_set[256] = {false};
	for (int i=0; i &lt; str.length(); i++){
		int val = str[i];
		if (ascii_set[val]){
			return false;
		}
		ascii_set[value] = true;
	}
	reutrn true;
}
</code>  </p>

<p>3.python version:</p>

<p>```py
#!/usr/local/bin/python3
# -<em>- coding: utf-8 -</em>-</p>

<p>def is_unique(str):
    charsTable = set()
    for c in str:
        if c in charsTable:
            return False
        charsTable.add(c)
    return True</p>

<p>test_str1 = “hello”
test_str2 = “abcdef”
ans1 = is_unique(test_str1)
ans2 = is_unique(test_str2)
print(ans1)
print(ans2)
```</p>
]]></content>
  </entry>
  
</feed>
